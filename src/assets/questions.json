[
    {
        "id": 1,
        "type": "mcq",
        "metadata": {
            "category": "asosiy-til-xususiyatlari",
            "subcategory": "pattern matching",
            "concepts": [
                "pattern-matching",
                "switch-expressions",
                "property-patterns",
                "guard-clauses"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "8.0",
            "estimatedTimeSeconds": 120,
            "prerequisites": [
                "switch-expressions"
            ],
            "learningObjectives": [
                "Mantiqiy operatorlar bilan property pattern sintaksisini tushunish",
                "Switch expressionlarda range patternlarni qo'llash",
                "Pattern matching bajarilish tartibini tanib olish"
            ],
            "commonMistakes": [
                "> 5 va < 10 degani aniq 6-9 orasida ekanini unutish",
                "Inclusive va exclusive chegara farqini chalkashtirib yuborish"
            ],
            "relatedQuestions": [
                10,
                25
            ],
            "tags": [
                "property-patterns",
                "oraliq-tekshirish",
                "mantiqiy-operatorlar"
            ]
        },
        "codeBefore": "```csharp\nbool IsLong(string? s) => s switch\n{\n    null                  => false,\n    { Length: > 5 and < 10 } => true,\n    _                     => false\n};\n```",
        "codeAfter": "",
        "prompt": "Quyidagi chaqiruvlardan qaysi biri `true` natija qaytaradi? (Pattern: uzunlik 5 dan katta VA 10 dan kichik bo'lishi kerak)",
        "options": [
            {
                "id": "A",
                "option": "`IsLong(\"123456\")` - uzunlik 6",
                "explanation": "Uzunlik 6 bo'lsa > 5 va < 10 shartiga mos keladi"
            },
            {
                "id": "B",
                "option": "`IsLong(\"1234567890\")` - uzunlik 10",
                "explanation": "Uzunlik 10 bo'lsa < 10 shartiga mos kelmaydi"
            },
            {
                "id": "C",
                "option": "`IsLong(null!)` - null qiymat",
                "explanation": "Null birinchi patternга mos keladi va false qaytaradi"
            },
            {
                "id": "D",
                "option": "`IsLong(\"abcd\")` - uzunlik 4",
                "explanation": "Uzunlik 4 bo'lsa > 5 shartiga mos kelmaydi"
            }
        ],
        "answer": [
            "A"
        ],
        "explanation": "Property pattern `{ Length: > 5 and < 10 }` uzunligi 6-9 orasidagi stringlarni tanlaydi. Faqat A variant uzunligi 6 bo'lib bu shartni qanoatlantiradi."
    },
    {
        "id": 2,
        "type": "mcq",
        "metadata": {
            "category": "metod-xususiyatlari",
            "subcategory": "parametrlar",
            "concepts": [
                "in-parameters",
                "out-parameters",
                "params-arrays"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "7.2",
            "estimatedTimeSeconds": 100,
            "prerequisites": [
                "parameters"
            ],
            "learningObjectives": [
                "in parametrning readonly xususiyatlarini tushunish",
                "out parametrning write-only cheklovlarini bilish",
                "params array parametr qoidalarini qo'llash"
            ],
            "commonMistakes": [
                "Bir xil o'zgaruvchini in va out parametrlarda ishlatish",
                "in parametrlarning readonly reference ekanini unutish"
            ],
            "relatedQuestions": [
                7
            ],
            "tags": [
                "parametr-modifikatorlari",
                "metod-imzolari"
            ]
        },
        "codeBefore": "```csharp\nvoid M(in int x, out int y, params object[] rest) { }\n```",
        "codeAfter": "",
        "prompt": "Quyidagi funksiyani chaqirish usullaridan qaysi biri **noto'g'ri**? (`in` parametr readonly, `out` parametr write-only)",
        "options": [
            {
                "id": "A",
                "option": "`M(5, out var y)` - literal `in` parametrga berilmoqda",
                "explanation": "Literals can be passed to in parameters",
                "explanation_uz": "Literallarni in parametrlarga berish mumkin"
            },
            {
                "id": "B",
                "option": "`int a = 1; M(a, out a)` - bir xil o'zgaruvchi `in` va `out` uchun",
                "explanation": "Same variable cannot be used for both in and out parameters",
                "explanation_uz": "Bir xil o'zgaruvchini in va out parametrlarda ishlatib bo'lmaydi"
            },
            {
                "id": "C",
                "option": "`M(in 5, out _, 1, 2)` - `in` kalit so'zi bilan",
                "explanation": "Explicit in keyword is allowed",
                "explanation_uz": "Aniq in kalit so'zini ishlatish mumkin"
            },
            {
                "id": "D",
                "option": "`M(5, out var y, \"x\", 3)` - params bilan qo'shimcha argumentlar",
                "explanation": "Additional arguments for params are allowed",
                "explanation_uz": "params uchun qo'shimcha argumentlar ruxsat etilgan"
            }
        ],
        "answer": [
            "B"
        ],
        "explanation": "The same variable cannot be used for both `in` (readonly) and `out` (write-only) parameters in the same method call.",
        "explanation_uz": "Bir xil o'zgaruvchini bir metod chaqiruvida ham `in` (readonly) ham `out` (write-only) parametr sifatida ishlatib bo'lmaydi."
    },
    {
        "id": 3,
        "type": "mcq",
        "metadata": {
            "category": "asosiy-til-xususiyatlari",
            "subcategory": "records",
            "subcategory_uz": "record tiplari",
            "concepts": [
                "records",
                "positional-records",
                "with-expressions"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "9.0",
            "estimatedTimeSeconds": 110,
            "learningObjectives": [
                "Understand positional record limitations",
                "Know record equality semantics",
                "Apply with expressions correctly"
            ],
            "learningObjectives_uz": [
                "Positional record cheklovlarini tushunish",
                "Record tenglik semantikasini bilish",
                "with expressionlarni to'g'ri qo'llash"
            ],
            "commonMistakes": [
                "Thinking parameterless constructors can be added to positional records",
                "Misunderstanding record equality"
            ],
            "commonMistakes_uz": [
                "Positional recordlarga parametrsiz konstruktor qo'shish mumkin deb o'ylash",
                "Record tengligini noto'g'ri tushunish"
            ],
            "relatedQuestions": [
                12,
                22
            ],
            "tags": [
                "value-equality",
                "immutability"
            ],
            "tags_uz": [
                "qiymat-tengligi",
                "o'zgarmas-obyektlar"
            ]
        },
        "codeBefore": "```csharp\npublic record Point(int X, int Y);\nvar p = new Point(1,2) with { Y = 3 };\n```",
        "codeAfter": "",
        "prompt": "Positional record `Point` haqida qaysi fikr **noto'g'ri**?",
        "options": [
            {
                "id": "A",
                "option": "Agar `Point` obyektlarining `X` va `Y` qiymatlari bir xil bo'lsa, ular teng deb hisoblanadi.",
                "explanation": "Records have value-based equality",
                "explanation_uz": "Recordlar qiymatga asoslangan tenglikka ega"
            },
            {
                "id": "B",
                "option": "`record` tipida `ToString()` metodini override qilish mumkin.",
                "explanation": "ToString() can be overridden in records",
                "explanation_uz": "Recordlarda ToString() metodini override qilish mumkin"
            },
            {
                "id": "C",
                "option": "`with` operatori mavjud obyektdan yangi obyekt yaratadi.",
                "explanation": "with expression creates new instances",
                "explanation_uz": "with expression yangi instanslar yaratadi"
            },
            {
                "id": "D",
                "option": "Positional record uchun qo'shimcha parametrsiz konstruktor qo'shish mumkin.",
                "explanation": "Positional records cannot have additional parameterless constructors",
                "explanation_uz": "Positional recordlarga qo'shimcha parametrsiz konstruktor qo'shib bo'lmaydi"
            }
        ],
        "answer": [
            "D"
        ],
        "explanation": "Positional records cannot have additional parameterless constructors. The primary constructor is the only way to create instances.",
        "explanation_uz": "Positional recordlarga qo'shimcha parametrsiz konstruktor qo'shib bo'lmaydi. Primary konstruktor yagona yaratish usulidir."
    },
    {
        "id": 4,
        "type": "mcq",
        "metadata": {
            "category": "asosiy-til-xususiyatlari",
            "subcategory": "file-scoped-types",
            "subcategory_uz": "fayl doirasidagi turlar",
            "concepts": [
                "file-scoped-types",
                "access-modifiers"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "11.0",
            "estimatedTimeSeconds": 90,
            "learningObjectives": [
                "Understand file-scoped type visibility",
                "Know partial class file distribution rules",
                "Distinguish between file and partial modifiers"
            ],
            "learningObjectives_uz": [
                "Fayl doirasidagi turlarning ko'rinuvchanligini tushunish",
                "Partial klaslarning fayl bo'ylab taqsimlanish qoidalarini bilish",
                "file va partial modifikatorlar orasidagi farqni ajratish"
            ],
            "commonMistakes": [
                "Thinking file types can be accessed from other files",
                "Confusing file and partial modifiers"
            ],
            "commonMistakes_uz": [
                "File turlarni boshqa fayllardan chaqirish mumkin deb o'ylash",
                "file va partial modifikatorlarni chalkashtirib yuborish"
            ],
            "relatedQuestions": [
                8,
                11
            ],
            "tags": [
                "visibility",
                "encapsulation"
            ],
            "tags_uz": [
                "ko'rinuvchanlik",
                "inkapsulyatsiya"
            ]
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "`partial` va `file` modifikatorlari haqida qaysi fikr **to'g'ri**?",
        "options": [
            {
                "id": "A",
                "option": "`partial class` bir nechta fayl bo'ylab bo'linishi mumkin.",
                "explanation": "Partial classes can span multiple files",
                "explanation_uz": "Partial klasslar bir nechta faylda bo'linishi mumkin"
            },
            {
                "id": "B",
                "option": "`file struct` ni boshqa fayldan chaqirish mumkin.",
                "explanation": "File types are only visible within the same file",
                "explanation_uz": "File turlari faqat o'sha fayl ichida ko'rinadi"
            },
            {
                "id": "C",
                "option": "Bir tipni bir vaqtning o'zida `partial` va `file` deb e'lon qilish mumkin.",
                "explanation": "Cannot combine file and partial modifiers",
                "explanation_uz": "file va partial modifikatorlarni birga ishlatib bo'lmaydi"
            },
            {
                "id": "D",
                "option": "`file class` da `private protected` a'zolar bo'lishi mumkin.",
                "explanation": "File classes cannot have private protected members",
                "explanation_uz": "File klasslarda private protected a'zolar bo'lishi mumkin emas"
            }
        ],
        "answer": [
            "A"
        ],
        "explanation": "Partial classes can be split across multiple files in the same assembly, allowing code organization and separation of concerns.",
        "explanation_uz": "Partial klasslar bir assemblydagi bir nechta faylga bo'linishi mumkin, bu kodni tashkil qilish va mas'uliyatlarni ajratishga yordam beradi."
    },
    {
        "id": 5,
        "type": "mcq",
        "metadata": {
            "category": "metod-xususiyatlari",
            "subcategory": "params-arrays",
            "subcategory_uz": "params massivlar",
            "concepts": [
                "params-arrays",
                "method-overloading"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "6.0",
            "estimatedTimeSeconds": 100,
            "learningObjectives": [
                "Understand params array parameter rules",
                "Know type compatibility in params arrays",
                "Recognize compilation errors with mixed arguments"
            ],
            "learningObjectives_uz": [
                "params array parametr qoidalarini tushunish",
                "params arrayda tip mosligi qoidalarini bilish",
                "Aralash argumentlarda kompilyatsiya xatolarini tanib olish"
            ],
            "commonMistakes": [
                "Mixing individual values with arrays incorrectly",
                "Not understanding params type restrictions"
            ],
            "commonMistakes_uz": [
                "Individual qiymatlar va arraylarni noto'g'ri aralashtirish",
                "params tip cheklovlarini tushunmaslik"
            ],
            "relatedQuestions": [
                2
            ],
            "tags": [
                "type-conversion",
                "method-parameters"
            ],
            "tags_uz": [
                "tip-konvertatsiya",
                "metod-parametrlari"
            ]
        },
        "codeBefore": "```csharp\nvoid F(params int[] nums) { }\n```",
        "codeAfter": "",
        "prompt": "`F(1, 2, new[]{3,4})` chaqirilganda nima sodir bo'ladi? (`params` faqat individual qiymatlar yoki bitta massiv qabul qiladi)",
        "options": [
            {
                "id": "A",
                "option": "Bitta massiv `[1,2,3,4]` uzatiladi.",
                "explanation": "Cannot mix individual values with arrays",
                "explanation_uz": "Individual qiymatlar va arraylarni aralashtirib bo'lmaydi"
            },
            {
                "id": "B",
                "option": "Uch argument uzatiladi: `1`, `2`, va `int[]` massiv.",
                "explanation": "Cannot pass array as individual element to int params",
                "explanation_uz": "Arrayni int params ga individual element sifatida berib bo'lmaydi"
            },
            {
                "id": "C",
                "option": "Kompilyatsiya xatosi - `int[]` ni `int` ga convert qilib bo'lmaydi.",
                "explanation": "Correct - cannot convert int[] to int for params parameter",
                "explanation_uz": "To'g'ri - int[] ni int ga convert qilib bo'lmaydi params parametr uchun"
            },
            {
                "id": "D",
                "option": "Runtime exception - noto'g'ri argument tipi.",
                "explanation": "This would be a compile-time error, not runtime",
                "explanation_uz": "Bu runtime emas, compile-time xatosi bo'ladi"
            }
        ],
        "answer": [
            "C"
        ],
        "explanation": "When using params, you can either pass individual values OR a single array, but not mix them. Here, mixing individual ints (1, 2) with an array (new[]{3,4}) causes a compilation error.",
        "explanation_uz": "params ishlatilganda yoki individual qiymatlar YOKI bitta array berish mumkin, lekin ularni aralashtirib bo'lmaydi. Bu yerda individual int-lar (1, 2) va array (new[]{3,4}) aralashtirilgani uchun kompilyatsiya xatosi paydo bo'ladi."
    },
    {
        "id": 6,
        "type": "mcq",
        "metadata": {
            "category": "tip-tizimi-oop",
            "subcategory": "generics-constraints",
            "subcategory_uz": "generic cheklovlar",
            "concepts": [
                "generics",
                "constraints",
                "generic-math"
            ],
            "difficulty": "murakkab",
            "csharpVersion": "11.0",
            "estimatedTimeSeconds": 150,
            "prerequisites": [
                "generics",
                "interfaces"
            ],
            "learningObjectives": [
                "Understand .NET 7+ generic math interfaces",
                "Apply INumber interface for arithmetic operations",
                "Use modern generic constraints for mathematical operations"
            ],
            "learningObjectives_uz": [
                ".NET 7+ generic math interfeyslari tushunish",
                "Arifmetik operatsiyalar uchun INumber interfeysi qo'llash",
                "Matematik operatsiyalar uchun zamonaviy generic cheklovlar ishlatish"
            ],
            "commonMistakes": [
                "Using old-style struct constraints for arithmetic",
                "Not knowing about new generic math interfaces"
            ],
            "commonMistakes_uz": [
                "Arifmetik uchun eski uslubdagi struct cheklovlarni ishlatish",
                "Yangi generic math interfeyslari haqida bilmaslik"
            ],
            "relatedQuestions": [
                21,
                26
            ],
            "tags": [
                "generic-math",
                "net7",
                "numeric-interfaces"
            ],
            "tags_uz": [
                "generic-math",
                "net7",
                "raqamli-interfeys"
            ]
        },
        "codeBefore": "```csharp\npublic static TResult Combine<TSource, TResult>(TSource a, TSource b)\n    where TSource : ________, IComparable<TSource>\n    where TResult : TSource, new()\n{\n    // arifmetik operatorlar ishlatiladi: +, -, *, /\n}\n```",
        "codeAfter": "",
        "prompt": "C# 12 da `TSource` uchun arifmetik operatorlardan foydalanish uchun qaysi generic constraint kerak?",
        "options": [
            {
                "id": "A",
                "option": "`INumber<TSource>` - generic math interface",
                "explanation": "INumber<T> provides arithmetic operators in .NET 7+",
                "explanation_uz": "INumber<T> .NET 7+ da arifmetik operatorlarni ta'minlaydi"
            },
            {
                "id": "B",
                "option": "`struct` - value type constraint",
                "explanation": "struct constraint doesn't provide arithmetic operators",
                "explanation_uz": "struct cheklovi arifmetik operatorlarni bermaydi"
            },
            {
                "id": "C",
                "option": "`IArithmetic<TSource>` - bunday interface yo'q",
                "explanation": "This interface doesn't exist in .NET",
                "explanation_uz": "Bunday interfeys .NET da mavjud emas"
            },
            {
                "id": "D",
                "option": "`class` - reference type constraint",
                "explanation": "class constraint doesn't provide arithmetic operators",
                "explanation_uz": "class cheklovi arifmetik operatorlarni bermaydi"
            }
        ],
        "answer": [
            "A"
        ],
        "explanation": "INumber<T> is the primary interface for generic math operations in .NET 7+, providing arithmetic operators like +, -, *, / through static abstract interface members.",
        "explanation_uz": "INumber<T> .NET 7+ da generic matematik operatsiyalar uchun asosiy interfeys bo'lib, static abstract interfeys a'zolari orqali +, -, *, / kabi arifmetik operatorlarni ta'minlaydi."
    },
    {
        "id": 7,
        "type": "mcq",
        "metadata": {
            "category": "metod-xususiyatlari",
            "subcategory": "extension-methods",
            "subcategory_uz": "extension metodlar",
            "concepts": [
                "extension-methods",
                "static-classes"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "6.0",
            "estimatedTimeSeconds": 100,
            "prerequisites": [
                "static-classes"
            ],
            "learningObjectives": [
                "Understand extension method requirements",
                "Know static keyword necessity for extension methods",
                "Identify compilation errors in extension method declarations"
            ],
            "learningObjectives_uz": [
                "Extension metod talablarini tushunish",
                "Extension metod uchun static kalit so'z zarurligini bilish",
                "Extension metod e'lonlaridagi kompilyatsiya xatolarini aniqlash"
            ],
            "commonMistakes": [
                "Forgetting static keyword for extension methods",
                "Mixing extension and instance methods incorrectly"
            ],
            "commonMistakes_uz": [
                "Extension metodlar uchun static kalit so'zni unutish",
                "Extension va instance metodlarni noto'g'ri aralashtirish"
            ],
            "relatedQuestions": [
                17,
                34
            ],
            "tags": [
                "static-methods",
                "method-definition"
            ],
            "tags_uz": [
                "static-metodlar",
                "metod-ta'rifi"
            ]
        },
        "codeBefore": "```csharp\npublic static class Extensions\n{\n    public static bool IsEven(this int number)\n    {\n        return (number % 2) == 0;\n    }\n\n    public bool IsOdd(int number)\n    {\n        return (number % 2) != 0;\n    }\n}\n```",
        "codeAfter": "",
        "prompt": "Extension methodlar haqida yuqoridagi kodda qaysi muammo bor?",
        "options": [
            {
                "id": "A",
                "option": "`IsEven` extension method, `IsOdd` esa oddiy instance method.",
                "explanation": "IsOdd is not an instance method, it's missing static keyword",
                "explanation_uz": "IsOdd instance metod emas, static kalit so'z etishmayapti"
            },
            {
                "id": "B",
                "option": "`IsEven` va `IsOdd` ikkalasi ham extension method bo'lishi mumkin.",
                "explanation": "Both could be extension methods if IsOdd had proper syntax",
                "explanation_uz": "Agar IsOdd to'g'ri sintaksisga ega bo'lsa, ikkalasi ham extension metod bo'lishi mumkin"
            },
            {
                "id": "C",
                "option": "`IsOdd` ni kompilyatsiya uchun `static` qilish kerak.",
                "explanation": "Correct - all methods in static class must be static",
                "explanation_uz": "To'g'ri - static klassdagi barcha metodlar static bo'lishi kerak"
            },
            {
                "id": "D",
                "option": "`this int` kalit so'zi extension methodda kerak emas.",
                "explanation": "'this' keyword is required for extension methods",
                "explanation_uz": "'this' kalit so'z extension metodlar uchun kerak"
            }
        ],
        "answer": [
            "C"
        ],
        "explanation": "In a static class, all methods must be static. IsOdd method is missing the static keyword, which will cause a compilation error.",
        "explanation_uz": "Static klassda barcha metodlar static bo'lishi kerak. IsOdd metodida static kalit so'z etishmayapti, bu kompilyatsiya xatosiga olib keladi."
    },
    {
        "id": 8,
        "type": "mcq",
        "metadata": {
            "category": "asosiy-til-xususiyatlari",
            "subcategory": "file-scoped-types",
            "subcategory_uz": "fayl doirasidagi turlar",
            "concepts": [
                "file-scoped-types",
                "interfaces"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "11.0",
            "estimatedTimeSeconds": 90,
            "prerequisites": [
                "interfaces",
                "access-modifiers"
            ],
            "learningObjectives": [
                "Understand file-scoped interface visibility",
                "Know file modifier restrictions on type access",
                "Apply file-scoped types for encapsulation"
            ],
            "learningObjectives_uz": [
                "Fayl doirasidagi interfeys ko'rinuvchanligini tushunish",
                "File modifikatorning tip kirish cheklovlarini bilish",
                "Inkapsulyatsiya uchun fayl doirasidagi turlarni qo'llash"
            ],
            "commonMistakes": [
                "Thinking file types are accessible from other files",
                "Confusing file scope with other access modifiers"
            ],
            "commonMistakes_uz": [
                "File turlarni boshqa fayllardan kirishga bo'ladi deb o'ylash",
                "File doirasini boshqa kirish modifikatorlari bilan chalkashtirib yuborish"
            ],
            "relatedQuestions": [
                4,
                11
            ],
            "tags": [
                "encapsulation",
                "interface-implementation"
            ],
            "tags_uz": [
                "inkapsulyatsiya",
                "interfeys-tatbiq"
            ]
        },
        "codeBefore": "```csharp\nfile interface IHelper\n{\n    void Help();\n}\n\n// In another file\n// class HelperImpl : IHelper { ... }\n```",
        "codeAfter": "",
        "prompt": "`file` modifier bilan e'lon qilingan `IHelper` haqida qaysi fikr **to'g'ri**?",
        "options": [
            {
                "id": "A",
                "option": "`IHelper` faqat shu faylda ko'rinadi va implementatsiya qilinishi mumkin.",
                "explanation": "Correct - file types are only visible within the same file",
                "explanation_uz": "To'g'ri - file turlari faqat o'sha fayl ichida ko'rinadi"
            },
            {
                "id": "B",
                "option": "`IHelper` butun assembly bo'ylab `public` hisoblanadi.",
                "explanation": "file modifier limits visibility to current file only",
                "explanation_uz": "file modifikatori ko'rinuvchanlikni faqat joriy fayl bilan cheklaydi"
            },
            {
                "id": "C",
                "option": "`IHelper` ni bir nechta faylda implementatsiya qilish mumkin.",
                "explanation": "Cannot access file-scoped interface from other files",
                "explanation_uz": "Fayl doirasidagi interfeyslarga boshqa fayllardan kira olmaydi"
            },
            {
                "id": "D",
                "option": "`file interface` noto'g'ri sintaksis.",
                "explanation": "file interface is valid syntax in C# 11+",
                "explanation_uz": "file interface C# 11+ da to'g'ri sintaksis"
            }
        ],
        "answer": [
            "A"
        ],
        "explanation": "File-scoped types (including interfaces) are only visible within the file where they are declared. They cannot be accessed or implemented from other files.",
        "explanation_uz": "Fayl doirasidagi turlar (interfeyslarga ham tegishli) faqat e'lon qilingan fayl ichida ko'rinadi. Ularni boshqa fayllardan kirish yoki tatbiq qilib bo'lmaydi."
    },
    {
        "id": 9,
        "type": "mcq",
        "metadata": {
            "category": "tip-tizimi-oop",
            "subcategory": "value-types",
            "subcategory_uz": "qiymat turlari",
            "concepts": [
                "structs",
                "value-semantics",
                "readonly"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "6.0",
            "estimatedTimeSeconds": 100,
            "prerequisites": [
                "structs",
                "value-types"
            ],
            "learningObjectives": [
                "Understand struct value semantics vs reference semantics",
                "Know how struct copying works",
                "Apply readonly fields in struct design"
            ],
            "learningObjectives_uz": [
                "Struct qiymat semantikasi va reference semantikasi farqini tushunish",
                "Struct nusxalash qanday ishlashini bilish",
                "Struct dizaynida readonly fieldlarni qo'llash"
            ],
            "commonMistakes": [
                "Confusing struct copying with reference sharing",
                "Thinking struct assignment creates references"
            ],
            "commonMistakes_uz": [
                "Struct nusxalashni reference sharing bilan chalkashtirib yuborish",
                "Struct tayinlash referenclar yaratadi deb o'ylash"
            ],
            "relatedQuestions": [
                15
            ],
            "tags": [
                "value-semantics",
                "struct-copying"
            ],
            "tags_uz": [
                "qiymat-semantika",
                "struct-nusxalash"
            ]
        },
        "codeBefore": "```csharp\npublic struct DataPoint\n{\n    public readonly int X;\n    public readonly int Y;\n    public DataPoint(int x, int y) => (X, Y) = (x, y);\n}\n\nvar d1 = new DataPoint(1,2);\nvar d2 = d1;  // struct copy\n\nd2 = new DataPoint(3,4);\nConsole.WriteLine(d1.X + \",\" + d1.Y);\n```",
        "codeAfter": "",
        "prompt": "Struct value semantics tufayli natija nima bo'ladi?",
        "options": [
            {
                "id": "A",
                "option": "`1,2` – chunki struct value type, d2 ni o'zgartirish d1 ga ta'sir qilmaydi.",
                "explanation": "Correct - structs have value semantics, d1 and d2 are independent",
                "explanation_uz": "To'g'ri - structlar qiymat semantikasiga ega, d1 va d2 mustaqil"
            },
            {
                "id": "B",
                "option": "`3,4` – chunki d2 o'zgartirilsa, d1 ham o'zgaradi.",
                "explanation": "This would be true for reference types, not value types",
                "explanation_uz": "Bu reference turlar uchun to'g'ri bo'lardi, qiymat turlari uchun emas"
            },
            {
                "id": "C",
                "option": "`1,2` – chunki readonly fieldlar o'zgarmaydi.",
                "explanation": "While readonly is a factor, the main reason is value semantics",
                "explanation_uz": "readonly omil bo'lsa-da, asosiy sabab qiymat semantikasidir"
            },
            {
                "id": "D",
                "option": "Kompilyatsiya xatosi, chunki DataPoint readonly.",
                "explanation": "No compilation error - readonly fields, not readonly struct",
                "explanation_uz": "Kompilyatsiya xatosi yo'q - readonly fieldlar, readonly struct emas"
            }
        ],
        "answer": [
            "A"
        ],
        "explanation": "Structs have value semantics, meaning assignment creates independent copies. When d2 is assigned a new value, d1 remains unchanged because they are separate copies.",
        "explanation_uz": "Structlar qiymat semantikasiga ega, ya'ni tayinlash mustaqil nusxalar yaratadi. d2 ga yangi qiymat tayinlanganda, d1 o'zgarishsiz qoladi chunki ular alohida nusxalardir."
    },
    {
        "id": 10,
        "type": "mcq",
        "metadata": {
            "category": "asosiy-til-xususiyatlari",
            "subcategory": "pattern-matching",
            "subcategory_uz": "pattern matching",
            "concepts": [
                "switch-expressions",
                "pattern-matching"
            ],
            "difficulty": "boshlang'ich",
            "csharpVersion": "8.0",
            "estimatedTimeSeconds": 80,
            "prerequisites": [
                "switch-expressions"
            ],
            "learningObjectives": [
                "Understand switch expression pattern matching order",
                "Know relational patterns evaluation",
                "Apply default pattern _ correctly"
            ],
            "learningObjectives_uz": [
                "Switch expression pattern matching tartibini tushunish",
                "Relational patternlar baholashini bilish",
                "Default pattern _ ni to'g'ri qo'llash"
            ],
            "commonMistakes": [
                "Confusing pattern matching evaluation order",
                "Not understanding default case behavior"
            ],
            "commonMistakes_uz": [
                "Pattern matching baholash tartibini chalkashtirib yuborish",
                "Default case xatti-harakatini tushunmaslik"
            ],
            "relatedQuestions": [
                1,
                25
            ],
            "tags": [
                "relational-patterns",
                "default-case"
            ],
            "tags_uz": [
                "relatsion-patternlar",
                "default-holat"
            ]
        },
        "codeBefore": "```csharp\nint Classify(int x) => x switch\n{\n    < 0 => -1,  // manfiy\n    > 0 => 1,   // musbat\n    _   => 0    // nol\n};\n\nvar result = Classify(0);\n```",
        "codeAfter": "",
        "prompt": "Switch expression da 0 qiymati qaysi case ga mos keladi?",
        "options": [
            {
                "id": "A",
                "option": "`-1` - chunki < 0",
                "explanation": "0 is not < 0, so this pattern doesn't match",
                "explanation_uz": "0 < 0 emas, shuning uchun bu pattern mos kelmaydi"
            },
            {
                "id": "B",
                "option": "`0` - chunki `_` (default) case",
                "explanation": "Correct - 0 matches neither < 0 nor > 0, so falls to default _",
                "explanation_uz": "To'g'ri - 0 na < 0 na > 0 ga mos kelmaydi, shuning uchun default _ ga tushadi"
            },
            {
                "id": "C",
                "option": "`1` - chunki > 0",
                "explanation": "0 is not > 0, so this pattern doesn't match",
                "explanation_uz": "0 > 0 emas, shuning uchun bu pattern mos kelmaydi"
            },
            {
                "id": "D",
                "option": "Kompilyatsiya xatosi",
                "explanation": "No compilation error - the switch is exhaustive with _ pattern",
                "explanation_uz": "Kompilyatsiya xatosi yo'q - switch _ pattern bilan to'liq"
            }
        ],
        "answer": [
            "B"
        ],
        "explanation": "In switch expressions, patterns are evaluated in order. Since 0 is neither < 0 nor > 0, it falls through to the default pattern _ which returns 0.",
        "explanation_uz": "Switch expressionlarda patternlar tartib bilan baholanadi. 0 na < 0 na > 0 bo'lgani uchun, default pattern _ ga tushadi va 0 qaytaradi."
    },
    {
        "id": 11,
        "type": "true_false",
        "metadata": {
            "category": "asosiy-til-xususiyatlari",
            "subcategory": "file-scoped-namespaces",
            "subcategory_uz": "fayl doirasidagi namespace-lar",
            "concepts": [
                "file-scoped-namespaces"
            ],
            "difficulty": "boshlang'ich",
            "csharpVersion": "10.0",
            "estimatedTimeSeconds": 60,
            "learningObjectives": [
                "Understand file-scoped namespace purpose",
                "Know file-scoped namespace limitations",
                "Distinguish between organization and access control"
            ],
            "learningObjectives_uz": [
                "Fayl doirasidagi namespace maqsadini tushunish",
                "Fayl doirasidagi namespace cheklovlarini bilish",
                "Tashkilot va kirish nazorati orasidagi farqni ajratish"
            ],
            "commonMistakes": [
                "Thinking file-scoped namespaces affect accessibility",
                "Confusing organization with access control"
            ],
            "commonMistakes_uz": [
                "Fayl doirasidagi namespace-larning dostuplikka ta'sir qiladi deb o'ylash",
                "Tashkilot va kirish nazoratini chalkashtirib yuborish"
            ],
            "relatedQuestions": [
                4,
                8
            ],
            "tags": [
                "namespace-organization",
                "code-structure"
            ],
            "tags_uz": [
                "namespace-tashkil",
                "kod-struktura"
            ]
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "File-scoped namespace (`namespace MyApp;`) faqat kodni tashkillashtirish uchun ishlatiladi va access modifierlar yoki ko'rinuvchanlikka ta'sir qilmaydi.",
        "answer": "true",
        "explanation": "File-scoped namespaces are purely for code organization and don't affect access modifiers or visibility rules.",
        "explanation_uz": "Fayl doirasidagi namespace-lar faqat kodni tashkil qilish uchun bo'lib, access modifierlar yoki ko'rinuvchanlik qoidalariga ta'sir qilmaydi."
    },
    {
        "id": 12,
        "type": "true_false",
        "metadata": {
            "category": "asosiy-til-xususiyatlari",
            "subcategory": "record-structs",
            "subcategory_uz": "record struct-lar",
            "concepts": [
                "record-structs",
                "structs"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "10.0",
            "estimatedTimeSeconds": 80,
            "prerequisites": [
                "records",
                "structs"
            ],
            "learningObjectives": [
                "Know record struct constructor capabilities",
                "Understand C# 10+ struct constructor enhancements",
                "Apply parameterless constructors in record structs"
            ],
            "learningObjectives_uz": [
                "Record struct konstruktor imkoniyatlarini bilish",
                "C# 10+ struct konstruktor yaxshilanishlarini tushunish",
                "Record struct-larda parametrsiz konstruktorlarni qo'llash"
            ],
            "commonMistakes": [
                "Thinking record structs follow old struct constructor rules",
                "Confusing record struct with regular struct limitations"
            ],
            "commonMistakes_uz": [
                "Record struct-lar eski struct konstruktor qoidalariga amal qiladi deb o'ylash",
                "Record struct va oddiy struct cheklovlarini chalkashtirib yuborish"
            ],
            "relatedQuestions": [
                3,
                15
            ],
            "tags": [
                "constructors",
                "struct-enhancements"
            ],
            "tags_uz": [
                "konstruktorlar",
                "struct-yaxshilanish"
            ]
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "C# 10+ da `record struct` uchun foydalanuvchi tomonidan yaratilgan parametrsiz konstruktor e'lon qilish mumkin.",
        "answer": "true",
        "explanation": "C# 10+ allows parameterless constructors in record structs, unlike earlier versions where this was restricted.",
        "explanation_uz": "C# 10+ da record struct-larda parametrsiz konstruktor e'lon qilish mumkin, oldingi versiyalardan farqli o'laroq bu cheklangan edi."
    },
    {
        "id": 13,
        "type": "true_false",
        "metadata": {
            "category": "asosiy-til-xususiyatlari",
            "subcategory": "expression-bodied-members",
            "subcategory_uz": "expression-bodied a'zolar",
            "concepts": [
                "expression-bodied-members"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "6.0",
            "estimatedTimeSeconds": 70,
            "learningObjectives": [
                "Understand expression-bodied member capabilities",
                "Know what can be written in => expressions",
                "Apply complex logic in expression-bodied members"
            ],
            "learningObjectives_uz": [
                "Expression-bodied a'zolarning imkoniyatlarini tushunish",
                "=> expression-larda nimalar yozish mumkinligini bilish",
                "Expression-bodied a'zolarda murakkab mantiqni qo'llash"
            ],
            "commonMistakes": [
                "Thinking expression-bodied members are limited to simple expressions",
                "Not knowing exceptions can be thrown in expressions"
            ],
            "commonMistakes_uz": [
                "Expression-bodied a'zolar oddiy expressionlar bilan cheklangan deb o'ylash",
                "Expressionlarda exception throw qilish mumkinligini bilmaslik"
            ],
            "relatedQuestions": [],
            "tags": [
                "lambda-expressions",
                "syntax-sugar"
            ],
            "tags_uz": [
                "lambda-expression",
                "sintaksis-qisqartma"
            ]
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "Expression-bodied member (`=>`) ichida exception throw qilish va kompleks mantiq yozish mumkin.",
        "answer": "true",
        "explanation": "Expression-bodied members can contain complex logic, including throwing exceptions, conditional expressions, and method calls.",
        "explanation_uz": "Expression-bodied a'zolarda murakkab mantiq, jumladan exception tashlaish, shartli expressionlar va metod chaqiruvlari bo'lishi mumkin."
    },
    {
        "id": 14,
        "type": "true_false",
        "metadata": {
            "category": "asosiy-til-xususiyatlari",
            "subcategory": "pattern-matching",
            "subcategory_uz": "pattern matching",
            "concepts": [
                "pattern-matching",
                "guard-clauses"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "7.0",
            "estimatedTimeSeconds": 90,
            "prerequisites": [
                "pattern-matching"
            ],
            "learningObjectives": [
                "Understand pattern guards (when clauses)",
                "Combine type patterns with additional conditions",
                "Apply when clauses in switch statements"
            ],
            "learningObjectives_uz": [
                "Pattern guardlar (when clauses) tushunish",
                "Tip patternlarni qo'shimcha shartlar bilan birlashtirish",
                "Switch statementlarda when clause-larni qo'llash"
            ],
            "commonMistakes": [
                "Not knowing when clauses can be combined with type patterns",
                "Misunderstanding pattern guard syntax"
            ],
            "commonMistakes_uz": [
                "when clause-larni tip patternlar bilan birlashtirish mumkinligini bilmaslik",
                "Pattern guard sintaksisini noto'g'ri tushunish"
            ],
            "relatedQuestions": [
                1,
                10,
                25
            ],
            "tags": [
                "type-patterns",
                "conditional-patterns"
            ],
            "tags_uz": [
                "tip-patternlar",
                "shartli-patternlar"
            ]
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "C# switch patternlari bir case ichida tip tekshirish va qo'shimcha shart birga yozilishi mumkin, masalan: `case string s when s.Length > 0:`.",
        "answer": "true",
        "explanation": "Pattern guards (when clauses) allow combining type patterns with additional boolean conditions in the same case.",
        "explanation_uz": "Pattern guardlar (when clause-lar) tip patternlarni qo'shimcha boolean shartlar bilan bitta case da birlashtirish imkonini beradi."
    },
    {
        "id": 15,
        "type": "true_false",
        "metadata": {
            "category": "tip-tizimi-oop",
            "subcategory": "structs",
            "subcategory_uz": "struct-lar",
            "concepts": [
                "structs"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "10.0",
            "estimatedTimeSeconds": 80,
            "prerequisites": [
                "structs"
            ],
            "learningObjectives": [
                "Know C# 10+ struct constructor enhancements",
                "Understand parameterless constructor capabilities",
                "Apply custom initialization in structs"
            ],
            "learningObjectives_uz": [
                "C# 10+ struct konstruktor yaxshilanishlarini bilish",
                "Parametrsiz konstruktor imkoniyatlarini tushunish",
                "Struct-larda maxsus initialization qo'llash"
            ],
            "commonMistakes": [
                "Thinking struct parameterless constructors are still forbidden",
                "Not knowing about C# 10 struct improvements"
            ],
            "commonMistakes_uz": [
                "Struct parametrsiz konstruktorlari hali ham taqiqlangan deb o'ylash",
                "C# 10 struct yaxshilanishlari haqida bilmaslik"
            ],
            "relatedQuestions": [
                9,
                12
            ],
            "tags": [
                "struct-constructors",
                "initialization"
            ],
            "tags_uz": [
                "struct-konstruktorlar",
                "initialization"
            ]
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "C# 10+ da struct uchun parametrsiz konstruktor e'lon qilish va default xatti-harakatni o'zgartirish mumkin.",
        "answer": "true",
        "explanation": "C# 10+ allows declaring parameterless constructors in structs, enabling custom initialization logic beyond the default behavior.",
        "explanation_uz": "C# 10+ da struct-larda parametrsiz konstruktor e'lon qilish mumkin, bu default xatti-harakatdan tashqari maxsus initialization mantiqini yoqish imkonini beradi."
    },
    {
        "id": 16,
        "type": "true_false",
        "metadata": {
            "category": "asosiy-til-xususiyatlari",
            "subcategory": "switch expressions",
            "concepts": [
                "switch-expressions",
                "pattern-matching"
            ],
            "difficulty": "murakkab",
            "csharpVersion": "8.0",
            "estimatedTimeSeconds": 100,
            "prerequisites": [
                "switch-expressions",
                "pattern-matching"
            ],
            "learningObjectives": [
                "Switch expression exhaustiveness qoidalarini tushunish",
                "Kompilyator pattern coverage tekshiruvini bilish",
                "Default case zarurligini anglash"
            ],
            "commonMistakes": [
                "Barcha input patternlar automatic ravishda qamrab olinadi deb o'ylash",
                "Exhaustiveness va completeness tushunchalarini chalkashtirib yuborish"
            ],
            "relatedQuestions": [
                1,
                10
            ],
            "tags": [
                "exhaustiveness",
                "kompilyator-tekshiruv",
                "default-case"
            ]
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "C# switch expressionlari barcha mumkin bo'lgan input patternlarni kompilyatsiya vaqtida qamrab olishi shart (default case bo'lmasa ham).",
        "answer": "false",
        "explanation": "Switch expressionlar exhaustive bo'lishi kerak, lekin kompilyator ba'zi hollarda barcha mumkin bo'lgan input patternlarni automatic aniqlayolmaydi va default case (_) talab qilishi mumkin."
    },
    {
        "id": 17,
        "type": "true_false",
        "metadata": {
            "category": "metod-xususiyatlari",
            "subcategory": "extension metodlar",
            "concepts": [
                "extension-methods",
                "static-classes"
            ],
            "difficulty": "boshlang'ich",
            "csharpVersion": "6.0",
            "estimatedTimeSeconds": 60,
            "prerequisites": [
                "static-classes"
            ],
            "learningObjectives": [
                "Extension method e'lon qilish talablarini bilish",
                "Static class va static method zarurligini tushunish",
                "Extension method sintaksisini to'g'ri qo'llash"
            ],
            "commonMistakes": [
                "Extension metodlarni oddiy klasslarda e'lon qilishga harakat qilish",
                "Static kalit so'zni unutish"
            ],
            "relatedQuestions": [
                7,
                34
            ],
            "tags": [
                "static-class",
                "metod-imzolar",
                "this-parametr"
            ]
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "Extension methodlar faqat static class ichida e'lon qilinadi va o'zi ham static bo'lishi kerak.",
        "answer": "true",
        "explanation": "Extension metodlar faqat static klasslarda e'lon qilinadi va o'zlari ham static bo'lishi kerak. Birinchi parametr 'this' kalit so'zi bilan belgilanadi."
    },
    {
        "id": 18,
        "type": "true_false",
        "metadata": {
            "category": "metod-xususiyatlari",
            "subcategory": "named arguments",
            "concepts": [
                "named-arguments",
                "optional-parameters"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "6.0",
            "estimatedTimeSeconds": 80,
            "prerequisites": [
                "optional-parameters"
            ],
            "learningObjectives": [
                "Named argument sintaksisini tushunish",
                "Parametr tartibining moslashuvchanligini bilish",
                "Optional va required parametrlar kombinatsiyasini qo'llash"
            ],
            "commonMistakes": [
                "Named argumentlar bilan parametr tartibini o'zgartirib bo'lmaydi deb o'ylash",
                "Required parametrlarni optional parametrlardan keyin yozish mumkin emasligini o'ylash"
            ],
            "relatedQuestions": [
                2,
                5
            ],
            "tags": [
                "metod-chaqiruv",
                "parametr-tartib",
                "moslashuvchanlik"
            ]
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "Named argumentlardan foydalanganda method chaqirishda optional parametrlarni required parametrlardan oldin yozish mumkin.",
        "answer": "true",
        "explanation": "Named argumentlar ishlatilganda parametrlarning tartibini o'zgartirish mumkin, shu jumladan optional parametrlarni required parametrlardan oldin yozish ham mumkin."
    },
    {
        "id": 19,
        "type": "true_false",
        "metadata": {
            "category": "asosiy-til-xususiyatlari",
            "subcategory": "record class",
            "concepts": [
                "records"
            ],
            "difficulty": "boshlang'ich",
            "csharpVersion": "9.0",
            "estimatedTimeSeconds": 60,
            "prerequisites": [
                "records"
            ],
            "learningObjectives": [
                "Record va record class farqini tushunish",
                "Record class default xatti-harakatini bilish",
                "Reference type va value type farqini recordlar kontekstida anglash"
            ],
            "commonMistakes": [
                "Record class value type deb o'ylash",
                "Record struct bilan record class ni chalkashtirib yuborish"
            ],
            "relatedQuestions": [
                3,
                12
            ],
            "tags": [
                "reference-type",
                "default-xatti-harakat",
                "record-class"
            ]
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "C# da `record` (record class) default bo'yicha reference type hisoblanadi.",
        "answer": "true",
        "explanation": "C# da 'record' kalit so'zi default bo'yicha record class yaratadi va u reference type hisoblanadi. Value type uchun aniq 'record struct' yozish kerak."
    },
    {
        "id": 20,
        "type": "true_false",
        "metadata": {
            "category": "tip-tizimi-oop",
            "subcategory": "inheritance",
            "concepts": [
                "virtual-override",
                "abstract-sealed"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "6.0",
            "estimatedTimeSeconds": 80,
            "prerequisites": [
                "inheritance",
                "virtual-override"
            ],
            "learningObjectives": [
                "Sealed virtual metod xatti-harakatini tushunish",
                "Override zanjirini to'xtatish mexanizmini bilish",
                "Inheritance hierarchy da virtual metod nazoratini qo'llash"
            ],
            "commonMistakes": [
                "Sealed metodlarni hali ham override qilish mumkin deb o'ylash",
                "Sealed va virtual bir vaqtda ishlatilmasligini o'ylash"
            ],
            "relatedQuestions": [
                31,
                38
            ],
            "tags": [
                "sealed-metodlar",
                "virtual-override",
                "inheritance-nazorat"
            ]
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "`sealed` bilan belgilangan virtual metodni boshqa derived klasslarda override qilib bo'lmaydi.",
        "answer": "true",
        "explanation": "Sealed virtual metod override zanjirini to'xtatadi. Bu metodni further derived klasslarda override qilib bo'lmaydi, lekin base class implementatsiyasidan foydalanish mumkin."
    },
    {
        "id": 21,
        "type": "fill",
        "metadata": {
            "category": "tip-tizimi-oop",
            "subcategory": "generic math",
            "concepts": [
                "generics",
                "constraints",
                "generic-math"
            ],
            "difficulty": "murakkab",
            "csharpVersion": "11.0",
            "estimatedTimeSeconds": 180,
            "prerequisites": [
                "generics",
                "interfaces"
            ],
            "learningObjectives": [
                ".NET 7+ generic math interfeyslari bilan ishlashni o'rganish",
                "INumber va IAdditionOperators interfeyslari qo'llash",
                "Generic constraints yordamida matematik operatorlarni ishlatish"
            ],
            "commonMistakes": [
                "Eski struct constraintlar ishlatish",
                "Generic math interfeyslari nomi va parametrlarini adashtirib yuborish"
            ],
            "relatedQuestions": [
                6,
                26
            ],
            "tags": [
                "generic-math",
                "net7",
                "matematik-operatorlar"
            ]
        },
        "codeWithBlank": "public static T AddAll<T>(T[] values)\n    where T : ________, ________\n{\n    T sum = default!;\n    foreach (var v in values)\n    {\n        sum += v;\n    }\n    return sum;\n}",
        "prompt": "`T` uchun `+` operatori va `default` literalini ishlatish imkonini beruvchi .NET 7+ generic math interfeyslarini ikki bo'sh joyga yozing.",
        "answer": "public static T AddAll<T>(T[] values)\n    where T : INumber<T>, IAdditionOperators<T, T, T>\n{\n    T sum = default!;\n    foreach (var v in values)\n    {\n        sum += v;\n    }\n    return sum;\n}",
        "explanation": "INumber<T> asosiy raqamli tip interfeysi bo'lib, IAdditionOperators<T, T, T> esa + operatorini ta'minlaydi. Ikkalasi ham .NET 7+ generic math sistemasi qismidir."
    },
    {
        "id": 22,
        "type": "fill",
        "metadata": {
            "category": "asosiy-til-xususiyatlari",
            "subcategory": "file-scoped types",
            "concepts": [
                "file-scoped-types",
                "positional-records",
                "deconstruction"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "11.0",
            "estimatedTimeSeconds": 100,
            "prerequisites": [
                "records",
                "deconstruction"
            ],
            "learningObjectives": [
                "File-scoped struct bilan ishlash",
                "Positional record syntax va Deconstruct metodini tushunish",
                "Primary constructor parametrlarini dekonstruktsiya qilish"
            ],
            "commonMistakes": [
                "Primary constructor parametrlarini lowercase bilan chaqirish",
                "Deconstruct metodida parametr nomlarini adashtirib yuborish"
            ],
            "relatedQuestions": [
                4,
                8
            ],
            "tags": [
                "deconstruct",
                "primary-constructor",
                "fayl-doirasidagi-turlar"
            ]
        },
        "codeWithBlank": "file struct Point(int X, int Y)\n{\n    public void Deconstruct(out int x, out int y) => (x, y) = (______, ______);\n}",
        "prompt": "File-scoped positional struct da Deconstruct metodi primary constructor parametrlarini qaytarishi uchun bo'sh joylarni to'ldiring.",
        "answer": "file struct Point(int X, int Y)\n{\n    public void Deconstruct(out int x, out int y) => (x, y) = (X, Y);\n}",
        "explanation": "Primary constructor parametrlari X va Y sifatida mavjud va ularni Deconstruct metodida to'g'ridan-to'g'ri ishlatish mumkin."
    },
    {
        "id": 23,
        "type": "fill",
        "metadata": {
            "category": "tip-tizimi-oop",
            "subcategory": "interfaces",
            "concepts": [
                "interfaces",
                "explicit-implementation"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "6.0",
            "estimatedTimeSeconds": 90,
            "prerequisites": [
                "interfaces"
            ],
            "learningObjectives": [
                "Explicit interface implementation sintaksisini o'rganish",
                "Interface inheritance va implementatsiya farqini tushunish",
                "Generic interface bilan ishlash"
            ],
            "commonMistakes": [
                "Explicit implementation da public modifier qo'yish",
                "Interface nomini to'liq yozmaslik"
            ],
            "relatedQuestions": [
                37
            ],
            "tags": [
                "explicit-implementation",
                "generic-interface",
                "inheritance"
            ]
        },
        "codeWithBlank": "public interface IRepository<T>\n{\n    void Add(T item);\n    T? Get(int id);\n}\n\npublic class Repo<T> : ______\n{\n    void IRepository<T>.Add(T item) { /*...*/ }\n    T? IRepository<T>.Get(int id) { /*...*/ }\n}",
        "prompt": "Explicit interface implementation qilish uchun inheritance qismini to'ldiring (metodlar public emas, faqat interface orqali accessible).",
        "answer": "public class Repo<T> : IRepository<T>\n{\n    void IRepository<T>.Add(T item) { /*...*/ }\n    T? IRepository<T>.Get(int id) { /*...*/ }\n}",
        "explanation": "Generic interface IRepository<T> ni implement qilish uchun class inheritance da to'liq nom ko'rsatilishi kerak."
    },
    {
        "id": 24,
        "type": "fill",
        "metadata": {
            "category": "tip-tizimi-oop",
            "subcategory": "default implementation",
            "concepts": [
                "interfaces",
                "default-implementation"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "8.0",
            "estimatedTimeSeconds": 80,
            "prerequisites": [
                "interfaces"
            ],
            "learningObjectives": [
                "Default interface implementation xususiyatini o'rganish",
                "Interface ichida metod implementatsiyasini yozish",
                "Boshqa interface metodlarini chaqirish"
            ],
            "commonMistakes": [
                "Default implementation sintaksisini noto'g'ri yozish",
                "Interface ichida instance metodlarini chaqirishga harakat qilish"
            ],
            "relatedQuestions": [
                37
            ],
            "tags": [
                "default-implementation",
                "interface-metodlar",
                "delegatsiya"
            ]
        },
        "codeWithBlank": "public interface ILogger\n{\n    void Log(string message);\n    void LogError(Exception ex) => ______;\n}",
        "prompt": "Default interface implementation: `LogError` metodi exception ni string formatda `Log` metodiga uzatsin.",
        "answer": "public interface ILogger\n{\n    void Log(string message);\n    void LogError(Exception ex) => Log(ex.ToString());\n}",
        "explanation": "Default implementation da Log metodini chaqirib, exception ni ToString() orqali string formatga aylantirib uzatish mumkin."
    },
    {
        "id": 25,
        "type": "fill",
        "metadata": {
            "category": "asosiy-til-xususiyatlari",
            "subcategory": "pattern matching",
            "concepts": [
                "pattern-matching",
                "guard-clauses",
                "type-patterns"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "7.0",
            "estimatedTimeSeconds": 100,
            "prerequisites": [
                "pattern-matching",
                "switch-expressions"
            ],
            "learningObjectives": [
                "Type pattern va when clause kombinatsiyasini qo'llash",
                "String property lari bilan ishlash",
                "Pattern guard konditsiyalarini yozish"
            ],
            "commonMistakes": [
                "String null check qilmaslik",
                "When clause sintaksisini noto'g'ri yozish"
            ],
            "relatedQuestions": [
                1,
                10,
                14
            ],
            "tags": [
                "when-clause",
                "string-properties",
                "pattern-guard"
            ]
        },
        "codeWithBlank": "int Classify(object o) => o switch\n{\n    string s when ______ => 1,\n    int i when i % 2 == 0 => 2,\n    null                  => 0,\n    _                     => 3\n};",
        "prompt": "Pattern matching da bo'sh bo'lmagan (non-empty) stringni tekshiruvchi shart yozing.",
        "answer": "int Classify(object o) => o switch\n{\n    string s when s.Length > 0 => 1,\n    int i when i % 2 == 0 => 2,\n    null                  => 0,\n    _                     => 3\n};",
        "explanation": "String type pattern da s.Length > 0 sharti bo'sh bo'lmagan stringlarni aniqlaydi. Null holatda already handled bo'lgani uchun null check kerak emas."
    },
    {
        "id": 26,
        "type": "error_spotting",
        "metadata": {
            "category": "tip-tizimi-oop",
            "subcategory": "generic math",
            "concepts": [
                "generics",
                "constraints",
                "generic-math"
            ],
            "difficulty": "murakkab",
            "csharpVersion": "11.0",
            "estimatedTimeSeconds": 120,
            "prerequisites": [
                "generics",
                "constraints"
            ],
            "learningObjectives": [
                "Generic math interfeyslari bilan matematik operatorlar uchun to'g'ri constraint qo'yish",
                "ISubtractionOperators interfeysi qo'llash",
                "Eski constraintlar va yangi generic math farqini tushunish"
            ],
            "commonMistakes": [
                "IComparable constraint matematik operatorlar uchun ishlatish",
                "Generic math interfeyslari haqida bilmaslik"
            ],
            "relatedQuestions": [
                6,
                21
            ],
            "tags": [
                "generic-math",
                "matematik-operatorlar",
                "constraint-xatolari"
            ]
        },
        "codeWithError": "public class Calculator\n{\n    public static T Subtract<T>(T a, T b) where T : IComparable<T>\n    {\n        return a - b;  // Bu yerda xato\n    }\n}",
        "prompt": "Generic subtraction operatori uchun noto'g'ri constraint ishlatilgan. To'g'ri generic math interface bilen tuzating.",
        "answer": "public class Calculator\n{\n    public static T Subtract<T>(T a, T b)\n        where T : ISubtractionOperators<T, T, T>\n    {\n        return a - b;\n    }\n}",
        "explanation": "IComparable<T> faqat taqqoslash uchun, matematik operatorlar uchun emas. Subtraction uchun ISubtractionOperators<T, T, T> interfeysi kerak."
    },
    {
        "id": 27,
        "type": "error_spotting",
        "metadata": {
            "category": "tip-tizimi-oop",
            "subcategory": "interfaces",
            "concepts": [
                "interfaces",
                "interface-implementation"
            ],
            "difficulty": "boshlang'ich",
            "csharpVersion": "6.0",
            "estimatedTimeSeconds": 60,
            "prerequisites": [
                "interfaces"
            ],
            "learningObjectives": [
                "Interface metod nomlarining case sensitivity ni tushunish",
                "Interface implementatsiya qoidalarini bilish",
                "Method signature mosligini ta'minlash"
            ],
            "commonMistakes": [
                "Interface metod nomlarini kichik harf bilan yozish",
                "Method signature farqini e'tiborsiz qoldirish"
            ],
            "relatedQuestions": [
                23,
                24
            ],
            "tags": [
                "case-sensitivity",
                "method-signature",
                "interface-contract"
            ]
        },
        "codeWithError": "interface IShape\n{\n    double Area();  // Capital A\n}\n\npublic class Circle : IShape\n{\n    private readonly double radius;\n    public Circle(double radius) => this.radius = radius;\n    public double area() => Math.PI * radius * radius;  // kichik a\n}",
        "prompt": "Interface implementationida method name case sensitivity xatosi bor. Tuzating.",
        "answer": "interface IShape\n{\n    double Area();\n}\n\npublic class Circle : IShape\n{\n    private readonly double radius;\n    public Circle(double radius) => this.radius = radius;\n    public double Area() => Math.PI * radius * radius;\n}",
        "explanation": "C# case-sensitive til. Interface da Area() deb e'lon qilingan metod aynan Area() nomli bo'lishi kerak, area() emas."
    },
    {
        "id": 28,
        "type": "error_spotting",
        "metadata": {
            "category": "tip-tizimi-oop",
            "subcategory": "structs",
            "concepts": [
                "structs",
                "struct-constructors"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "6.0",
            "estimatedTimeSeconds": 80,
            "prerequisites": [
                "structs"
            ],
            "learningObjectives": [
                "Struct konstruktor qoidalarini tushunish",
                "Barcha field/property larni initialize qilish zarurligini bilish",
                "Struct definite assignment qoidalarini qo'llash"
            ],
            "commonMistakes": [
                "Struct konstruktorida ba'zi fieldlarni initialize qilmaslik",
                "Struct va class konstruktor farqini bilmaslik"
            ],
            "relatedQuestions": [
                9,
                15
            ],
            "tags": [
                "struct-konstruktor",
                "definite-assignment",
                "initialization"
            ]
        },
        "codeWithError": "public struct Rectangle\n{\n    public int Width { get; set; }\n    public int Height { get; set; }\n    public Rectangle(int width, int height)\n    {\n        Width = width;\n        // Height initsializatsiya qilinmagan!\n    }\n}",
        "prompt": "Struct konstruktorida barcha fieldlar/propertylar initsializatsiya qilinishi kerak. Tuzating.",
        "answer": "public struct Rectangle\n{\n    public int Width { get; set; }\n    public int Height { get; set; }\n    public Rectangle(int width, int height)\n    {\n        Width = width;\n        Height = height;\n    }\n}",
        "explanation": "Struct konstruktorida barcha fieldlar va propertylar initialize qilinishi kerak. Height property ga qiymat berilmagan."
    },
    {
        "id": 29,
        "type": "error_spotting",
        "metadata": {
            "category": "asosiy-til-xususiyatlari",
            "subcategory": "records",
            "concepts": [
                "records",
                "positional-records"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "9.0",
            "estimatedTimeSeconds": 100,
            "prerequisites": [
                "records"
            ],
            "learningObjectives": [
                "Positional record da qo'shimcha konstruktor qoidalarini tushunish",
                "Primary constructor delegation zarurligini bilish",
                "Record konstruktor zanjirini to'g'ri tashkil qilish"
            ],
            "commonMistakes": [
                "Parametrsiz konstruktor da primary constructor ni chaqirmaslik",
                "Record konstruktor qoidalarini bilmaslik"
            ],
            "relatedQuestions": [
                3,
                35
            ],
            "tags": [
                "primary-constructor",
                "constructor-chaining",
                "record-qoidalar"
            ]
        },
        "codeWithError": "public record Person(string FirstName, string LastName)\n{\n    public string FullName => FirstName + \" \" + LastName;\n    public Person() {}  // Primary constructor chaqirilmagan\n}",
        "prompt": "Positional record uchun parametrsiz konstruktor primary constructor ni chaqirishi kerak. Tuzating.",
        "answer": "public record Person(string FirstName, string LastName)\n{\n    public string FullName => FirstName + \" \" + LastName;\n    public Person() : this(string.Empty, string.Empty) {}\n}",
        "explanation": "Positional record da qo'shimcha konstruktor primary constructor ni this() orqali chaqirishi kerak."
    },
    {
        "id": 30,
        "type": "error_spotting",
        "metadata": {
            "category": "asosiy-til-xususiyatlari",
            "subcategory": "nullable reference types",
            "concepts": [
                "nullable-reference-types",
                "null-annotations"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "8.0",
            "estimatedTimeSeconds": 70,
            "prerequisites": [
                "nullable-reference-types"
            ],
            "learningObjectives": [
                "Nullable annotation sintaksisini to'g'ri yozish",
                "? va ! operatorlari farqini tushunish",
                "Nullable reference type qoidalarini qo'llash"
            ],
            "commonMistakes": [
                "? va ! operatorlarini bir vaqtda ishlatish",
                "Nullable annotation sintaksisini chalkashtirib yuborish"
            ],
            "relatedQuestions": [],
            "tags": [
                "nullable-annotations",
                "sintaksis-xato",
                "null-operatorlar"
            ]
        },
        "codeWithError": "public class Utils\n{\n    public static void LogMessage(string? msg!)  // ? va ! birga ishlatilgan\n    {\n        Console.WriteLine(msg);\n    }\n}",
        "prompt": "Nullable annotation sintaksisida xato bor. Bir parametrda `?` va `!` birga ishlatilmaydi.",
        "answer": "public class Utils\n{\n    public static void LogMessage(string? msg)\n    {\n        Console.WriteLine(msg);\n    }\n}",
        "explanation": "Parametr deklaratsiyasida ? (nullable) va ! (null-forgiving) operatorlari birga ishlatilmaydi. Faqat string? yoki string ishlatish kerak."
    },
    {
        "id": 31,
        "type": "error_spotting",
        "metadata": {
            "category": "tip-tizimi-oop",
            "subcategory": "inheritance",
            "concepts": [
                "abstract-sealed",
                "virtual-override"
            ],
            "difficulty": "boshlang'ich",
            "csharpVersion": "6.0",
            "estimatedTimeSeconds": 70,
            "prerequisites": [
                "inheritance",
                "abstract-classes"
            ],
            "learningObjectives": [
                "Abstract metod implementation qoidalarini tushunish",
                "Override kalit so'zi zarurligini bilish",
                "Abstract class inheritance mexanizmini qo'llash"
            ],
            "commonMistakes": [
                "Abstract metodini override kalit so'zisiz implement qilish",
                "Abstract va virtual metod farqini bilmaslik"
            ],
            "relatedQuestions": [
                20,
                38
            ],
            "tags": [
                "abstract-implementation",
                "override-kerak",
                "inheritance-qoidalar"
            ]
        },
        "codeWithError": "public abstract class Base\n{\n    public abstract void Save(string data);\n}\n\npublic class FileSaver : Base\n{\n    public void Save(string data)  // override kalit so'zi yo'q\n    {\n        File.WriteAllText(\"out.txt\", data);\n    }\n}",
        "prompt": "Abstract metodini implement qilishda `override` kalit so'zi kerak. Tuzating.",
        "answer": "public abstract class Base\n{\n    public abstract void Save(string data);\n}\n\npublic class FileSaver : Base\n{\n    public override void Save(string data)\n    {\n        File.WriteAllText(\"out.txt\", data);\n    }\n}",
        "explanation": "Abstract metodini implement qilishda override kalit so'zi shart. Bu abstract contract ni bajarayotganingizni ko'rsatadi."
    },
    {
        "id": 32,
        "type": "error_spotting",
        "metadata": {
            "category": "asosiy-til-xususiyatlari",
            "subcategory": "init properties",
            "concepts": [
                "init-only-properties"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "9.0",
            "estimatedTimeSeconds": 90,
            "prerequisites": [
                "properties"
            ],
            "learningObjectives": [
                "Init-only property va konstruktor munosabatini tushunish",
                "Property initializer va konstruktor farqini bilish",
                "Struct da init property qo'llash best practicesini o'rganish"
            ],
            "commonMistakes": [
                "Init property ni konstruktor ichida set qilish",
                "Property initializer va konstruktor initialization aralashtirib yuborish"
            ],
            "relatedQuestions": [],
            "tags": [
                "init-properties",
                "property-initializer",
                "struct-initialization"
            ]
        },
        "codeWithError": "struct Configuration\n{\n    public string Url { get; init; }\n    public Configuration() { Url = \"\"; }  // C# 11+ da ruxsat etilgan, lekin init-only property bilan muammo\n}",
        "prompt": "Init-only property ni konstruktor ichida to'g'ridan-to'g'ri initialize qilish o'rniga, property initializer ishlatish yaxshiroq. Tuzating.",
        "answer": "struct Configuration\n{\n    public string Url { get; init; } = string.Empty;\n}",
        "explanation": "Init-only property uchun property initializer ishlatish yaxshiroq, chunki bu property ning immutable nature ni ta'kidlaydi."
    },
    {
        "id": 33,
        "type": "error_spotting",
        "metadata": {
            "category": "tip-tizimi-oop",
            "subcategory": "generic constraints",
            "concepts": [
                "generics",
                "constraints",
                "generic-math"
            ],
            "difficulty": "murakkab",
            "csharpVersion": "11.0",
            "estimatedTimeSeconds": 150,
            "prerequisites": [
                "generics",
                "interfaces"
            ],
            "learningObjectives": [
                "Generic interface ni generic class bilan implement qilish",
                "Generic math constraint qo'yish",
                "Concrete type cheklovlaridan qochish"
            ],
            "commonMistakes": [
                "Generic interface ni concrete type bilan implement qilish",
                "Matematik operatorlar uchun constraint qo'ymaslik"
            ],
            "relatedQuestions": [
                6,
                21,
                26
            ],
            "tags": [
                "generic-implementation",
                "type-flexibility",
                "constraint-optimization"
            ]
        },
        "codeWithError": "public interface ICalc<T>\n{\n    T Add(T a, T b);\n}\n\npublic class Calculator : ICalc<int>  // Konkret tip bilan cheklangan\n{\n    public int Add(int a, int b)\n    {\n        return a + b;\n    }\n}",
        "prompt": "Generic interface ni generic class bilan implement qiling va arifmetik operatorlar uchun constraint qo'shing.",
        "answer": "public interface ICalc<T>\n{\n    T Add(T a, T b);\n}\n\npublic class Calculator<T> : ICalc<T>\n    where T : IAdditionOperators<T, T, T>\n{\n    public T Add(T a, T b)\n    {\n        return a + b;\n    }\n}",
        "explanation": "Generic interface ni generic class bilan implement qilish type flexibility beradi. IAdditionOperators constraint matematik operatorni ta'minlaydi."
    },
    {
        "id": 34,
        "type": "error_spotting",
        "metadata": {
            "category": "metod-xususiyatlari",
            "subcategory": "extension methods",
            "concepts": [
                "extension-methods",
                "static-classes"
            ],
            "difficulty": "boshlang'ich",
            "csharpVersion": "6.0",
            "estimatedTimeSeconds": 60,
            "prerequisites": [
                "extension-methods"
            ],
            "learningObjectives": [
                "Extension metod emas static metod farqini tushunish",
                "Static class da barcha metodlar static bo'lishi kerakligini bilish",
                "Extension metod qoidalarini to'g'ri qo'llash"
            ],
            "commonMistakes": [
                "Extension metodini static qilmaslik",
                "Static class ichida non-static metod yozish"
            ],
            "relatedQuestions": [
                7,
                17
            ],
            "tags": [
                "static-requirement",
                "extension-syntax",
                "class-consistency"
            ]
        },
        "codeWithError": "public static class StringUtils\n{\n    public static bool IsPalindrome(string s)\n    {\n        return s == new string(s.Reverse().ToArray());\n    }\n\n    public bool IsAnagram(this string s, string t)  // static emas\n    {\n        return s.OrderBy(c => c).SequenceEqual(t.OrderBy(c => c));\n    }\n}",
        "prompt": "Extension method `static` bo'lishi kerak. Tuzating.",
        "answer": "public static class StringUtils\n{\n    public static bool IsPalindrome(string s)\n    {\n        return s == new string(s.Reverse().ToArray());\n    }\n\n    public static bool IsAnagram(this string s, string t)\n    {\n        return s.OrderBy(c => c).SequenceEqual(t.OrderBy(c => c));\n    }\n}",
        "explanation": "Static class ichidagi barcha metodlar static bo'lishi kerak. Extension metodlar ham static bo'lishi shart."
    },
    {
        "id": 35,
        "type": "error_spotting",
        "metadata": {
            "category": "asosiy-til-xususiyatlari",
            "subcategory": "records",
            "concepts": [
                "records",
                "positional-records"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "9.0",
            "estimatedTimeSeconds": 80,
            "prerequisites": [
                "records"
            ],
            "learningObjectives": [
                "Positional record konstruktor zanjiri qoidalarini tushunish",
                "Primary constructor delegation zarurligini bilish",
                "Constructor chaining syntax ni qo'llash"
            ],
            "commonMistakes": [
                "Parametrsiz konstruktor da primary constructor chaqirmaslik",
                "Record va class konstruktor farqini bilmaslik"
            ],
            "relatedQuestions": [
                3,
                29
            ],
            "tags": [
                "constructor-delegation",
                "this-chaining",
                "record-konstruktor"
            ]
        },
        "codeWithError": "public record Person(string FirstName, string LastName)\n{\n    public Person() { }  // Primary constructor chaqirilmagan\n}",
        "prompt": "Positional record da parametrsiz konstruktor primary constructor ni chaqirishi kerak.",
        "answer": "public record Person(string FirstName, string LastName)\n{\n    public Person() : this(string.Empty, string.Empty) { }\n}",
        "explanation": "Positional record da qo'shimcha konstruktor primary constructor ni : this() sintaksis orqali chaqirishi kerak."
    },
    {
        "id": 36,
        "type": "output_prediction",
        "metadata": {
            "category": "tip-tizimi-oop",
            "subcategory": "method hiding",
            "concepts": [
                "virtual-override",
                "method-hiding"
            ],
            "difficulty": "murakkab",
            "csharpVersion": "6.0",
            "estimatedTimeSeconds": 150,
            "prerequisites": [
                "inheritance",
                "virtual-override"
            ],
            "learningObjectives": [
                "Virtual dispatch va method hiding farqini tushunish",
                "new keyword ta'sirini bilish",
                "Inheritance hierarchy da method resolution qoidalarini qo'llash"
            ],
            "commonMistakes": [
                "new keyword virtual dispatch ni davom ettiradi deb o'ylash",
                "Reference type ga asoslanib method resolution qiladi deb bilmaslik"
            ],
            "relatedQuestions": [
                20,
                31,
                38
            ],
            "tags": [
                "method-hiding",
                "virtual-dispatch",
                "reference-type-resolution"
            ]
        },
        "snippet": "class A\n{\n    public virtual string F() => \"A\";\n}\nclass B : A\n{\n    public override string F() => base.F() + \"B\";  // \"AB\"\n}\nclass C : B\n{\n    public new string F() => base.F() + \"C\";  // \"ABC\" lekin virtual dispatch yo'q\n}\n\nA obj = new C();\nConsole.WriteLine(obj.F());  // A reference orqali chaqirilmoqda",
        "prompt": "`new` keyword virtual dispatch ni to'xtatadi. `obj.F()` natijasi?",
        "answer": "AB",
        "explanation": "C.F() metodi 'new' bilan hide qilingan, shuning uchun A reference orqali B.F() chaqiriladi, natija 'AB'."
    },
    {
        "id": 37,
        "type": "output_prediction",
        "metadata": {
            "category": "tip-tizimi-oop",
            "subcategory": "default interface implementation",
            "concepts": [
                "interfaces",
                "default-implementation"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "8.0",
            "estimatedTimeSeconds": 100,
            "prerequisites": [
                "interfaces"
            ],
            "learningObjectives": [
                "Default interface implementation mexanizmini tushunish",
                "Interface cast zarurligini bilish",
                "C# 8+ default implementation xususiyatlarini qo'llash"
            ],
            "commonMistakes": [
                "Class instance orqali default methodga kirish mumkin deb o'ylash",
                "Default implementation qachon ishlatilishini bilmaslik"
            ],
            "relatedQuestions": [
                24
            ],
            "tags": [
                "default-implementation",
                "interface-cast",
                "c8-xususiyat"
            ]
        },
        "snippet": "interface ILog\n{\n    void Log(string msg) => Console.Write(\"DefaultLog:\");  // Default implementation\n}\nclass Logger : ILog { }  // O'z implementatsiyasi yo'q\n\nvar logger = new Logger();\n((ILog)logger).Log(\"Hello\");",
        "prompt": "Logger class Log metodini override qilmagan. Default interface implementation ishlatiladi.",
        "answer": "DefaultLog:",
        "explanation": "Logger class Log metodini implement qilmagan, shuning uchun interface cast orqali default implementation chaqiriladi."
    },
    {
        "id": 38,
        "type": "output_prediction",
        "metadata": {
            "category": "tip-tizimi-oop",
            "subcategory": "method resolution",
            "concepts": [
                "virtual-override",
                "method-hiding"
            ],
            "difficulty": "murakkab",
            "csharpVersion": "6.0",
            "estimatedTimeSeconds": 140,
            "prerequisites": [
                "inheritance",
                "virtual-override"
            ],
            "learningObjectives": [
                "Virtual va non-virtual metod farqini amalda ko'rish",
                "Method hiding vs method overriding farqini tushunish",
                "Base reference orqali method resolution qoidalarini bilish"
            ],
            "commonMistakes": [
                "new va override bir xil ishlaydi deb o'ylash",
                "Runtime type metod resolution ni belgilaydi deb o'ylash"
            ],
            "relatedQuestions": [
                20,
                31,
                36
            ],
            "tags": [
                "method-resolution",
                "static-vs-dynamic-binding",
                "inheritance-semantika"
            ]
        },
        "snippet": "class Base\n{\n    public void Show() => Console.Write(\"Base\");  // Virtual emas\n    public virtual void Display() => Console.Write(\"BaseDisplay\");\n}\nclass Derived : Base\n{\n    public new void Show() => Console.Write(\"Derived\");  // Hiding\n    public override void Display() => Console.Write(\"DerivedDisplay\");  // Override\n}\n\nBase b = new Derived();\nb.Show();     // Base reference -> Base.Show()\nb.Display();  // Virtual dispatch -> Derived.Display()",
        "prompt": "`new` vs `override` farqi. Natija qanday?",
        "answer": "BaseDerivedDisplay",
        "explanation": "Show() non-virtual va 'new' bilan hide qilingan, shuning uchun Base.Show() chaqiriladi. Display() virtual va override qilingan, shuning uchun DerivedDisplay chaqiriladi."
    },
    {
        "id": 39,
        "type": "output_prediction",
        "metadata": {
            "category": "asosiy-til-xususiyatlari",
            "subcategory": "ref readonly",
            "concepts": [
                "ref-parameters",
                "readonly"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "7.2",
            "estimatedTimeSeconds": 80,
            "prerequisites": [
                "ref-parameters"
            ],
            "learningObjectives": [
                "ref readonly foreach ishlatish",
                "Performance optimization bilan logic farqini tushunish",
                "Reference semantics va value computing farqini bilish"
            ],
            "commonMistakes": [
                "ref readonly result ni o'zgartiradi deb o'ylash",
                "Performance optimization mantiqni o'zgartiradi deb fikrlash"
            ],
            "relatedQuestions": [],
            "tags": [
                "ref-readonly",
                "foreach-optimization",
                "performance-feature"
            ]
        },
        "snippet": "var numbers = new[] { 1, 2, 3 };\nint sum = 0;\nforeach (ref readonly var n in numbers)  // Reference by readonly\n{\n    sum += n;  // 1+2+3\n}\nConsole.WriteLine(sum);",
        "prompt": "`ref readonly` faqat performance uchun, hisoblash bir xil. Yig'indi nima?",
        "answer": "6",
        "explanation": "ref readonly faqat performance optimization, mantiq o'zgarmaydi. 1+2+3=6."
    },
    {
        "id": 40,
        "type": "output_prediction",
        "metadata": {
            "category": "asosiy-til-xususiyatlari",
            "subcategory": "records",
            "concepts": [
                "records",
                "with-expressions"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "9.0",
            "estimatedTimeSeconds": 90,
            "prerequisites": [
                "records"
            ],
            "learningObjectives": [
                "Record da custom ToString override qilish",
                "with expression immutable copy semantikasini tushunish",
                "Record equality va copying mexanizmini qo'llash"
            ],
            "commonMistakes": [
                "with expression original record ni o'zgartiradi deb o'ylash",
                "ToString override record xatti-harakatiga ta'sir qiladi deb fikrlash"
            ],
            "relatedQuestions": [
                3,
                19
            ],
            "tags": [
                "record-copying",
                "with-expression",
                "tostring-override"
            ]
        },
        "snippet": "record R(int X)\n{\n    public override string ToString() => $\"R:{X}\";  // Custom ToString\n}\n\nvar r1 = new R(5);\nvar r2 = r1 with { X = 7 };  // Copy with modification\nConsole.WriteLine(r1);\nConsole.WriteLine(r2);",
        "prompt": "Record da custom ToString va `with` expression. Ikki qator natija?",
        "answer": "R:5\nR:7",
        "explanation": "with expression yangi copy yaratadi. r1 o'zgarishsiz qoladi (R:5), r2 yangi qiymat bilan yaratiladi (R:7)."
    },
    {
        "id": 41,
        "type": "code_writing",
        "metadata": {
            "category": "asosiy-til-xususiyatlari",
            "subcategory": "konsol dasturlari",
            "concepts": [
                "records",
                "switch-expressions"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "9.0",
            "estimatedTimeSeconds": 600,
            "prerequisites": [
                "records",
                "collections",
                "console-io"
            ],
            "learningObjectives": [
                "Record type dan amaliy foydalanish",
                "Console I/O va user interaction tashkil qilish",
                "Switch expression bilan command processing",
                "List<T> collection bilan CRUD operatsiyalar"
            ],
            "commonMistakes": [
                "Record syntax da xato",
                "Switch expression da break ishlatish",
                "Input validation qilmaslik"
            ],
            "relatedQuestions": [],
            "tags": [
                "console-app",
                "record-usage",
                "user-interaction",
                "crud-operations"
            ]
        },
        "prompt": "### 1. Kontaktlar kitobi konsol dasturi\n\nFoydalanuvchi kontakt qo'shishi va ro'yxatini ko'rishi mumkin bo'lgan konsol dasturini yarating.\n\nHar bir kontaktning `Name`, `PhoneNumber` va `Email` maydonlari bo'ladi. Kontaktlar uchun `record` tipidan foydalaning.\n\nDastur quyidagilarni qo'llab-quvvatlashi kerak:\n- Yangi kontakt qo'shish (`add`)\n- Barcha kontaktlarni ko'rish (`list`)\n- Dasturdan chiqish (`exit`)\n\nKontaktlar ro'yxatini xotirada `List<Contact>` orqali saqlang. Buyruqlarni tanlash uchun sikl va `switch` expression ishlating.",
        "examples": [
            "Buyruq kiriting (add/list/exit): add\nIsm kiriting: Alice\nTelefon kiriting: 9981234567\nEmail kiriting: alice@mail.com\nBuyruq kiriting (add/list/exit): list\nAlice - 9981234567 - alice@mail.com\nBuyruq kiriting (add/list/exit): exit"
        ]
    },
    {
        "id": 42,
        "type": "code_writing",
        "metadata": {
            "category": "tip-tizimi-oop",
            "subcategory": "polimorfizm",
            "concepts": [
                "abstract-sealed",
                "virtual-override",
                "polymorphism"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "6.0",
            "estimatedTimeSeconds": 450,
            "prerequisites": [
                "inheritance",
                "abstract-classes",
                "virtual-override"
            ],
            "learningObjectives": [
                "Abstract class va metod yaratish",
                "Polimorfizm orqali turli implementation qo'llash",
                "Override metod yordamida subclass xatti-harakat belgilash",
                "Shape hierarchy design pattern qo'llash"
            ],
            "commonMistakes": [
                "Abstract metodini implement qilishda override unutish",
                "Math.PI ni static import qilmaslik",
                "Polimorfizm o'rniga type checking ishlatish"
            ],
            "relatedQuestions": [
                31
            ],
            "tags": [
                "abstract-class",
                "shape-hierarchy",
                "area-calculation",
                "polimorfizm-amaliy"
            ]
        },
        "prompt": "### 2. Polimorfizm yordamida shakllar yuzasini hisoblash\n\nTurli shakllarning yuzasini hisoblaydigan konsol dasturini yozing.\n\nTalablar:\n- `Shape` nomli abstract class yarating va unda abstract `double GetArea()` metodini e'lon qiling\n- `Circle` va `Rectangle` voris classlarini yarating\n- `GetArea()` metodini har bir classda `override` qiling\n- Foydalanuvchidan shakl turini tanlashni so'rang\n- `switch` expression va polimorfizmdan foydalaning",
        "examples": [
            "Shakl kiriting (circle/rectangle): circle\nRadius kiriting: 2.5\nYuza: 19.63",
            "Shakl kiriting (circle/rectangle): rectangle\nKenglik kiriting: 4\nBalandlik kiriting: 3\nYuza: 12"
        ]
    },
    {
        "id": 43,
        "type": "code_writing",
        "metadata": {
            "category": "metod-xususiyatlari",
            "subcategory": "extension methods",
            "concepts": [
                "extension-methods",
                "static-classes"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "6.0",
            "estimatedTimeSeconds": 300,
            "prerequisites": [
                "extension-methods",
                "string-processing"
            ],
            "learningObjectives": [
                "Extension method yaratish va qo'llash",
                "String validation mantiq yozish",
                "Static class da extension method tashkil qilish",
                "Uzbekiston telefon raqam formatini tekshirish"
            ],
            "commonMistakes": [
                "Extension metodini static qilmaslik",
                "this kalit so'zni birinchi parametrda unutish",
                "Raqam validation mantiqida xato"
            ],
            "relatedQuestions": [
                7,
                17,
                34
            ],
            "tags": [
                "telefon-validation",
                "uzbek-format",
                "string-extension",
                "validation-logic"
            ]
        },
        "prompt": "### 3. Extension method yordamida telefon raqamini tekshirish\n\n`IsValidUzPhone(this string phone)` extension metodini yarating:\n\nQoidalar:\n- Satr `998` bilan boshlanishi kerak\n- Aniq 12 ta raqamdan iborat bo'lishi kerak\n- Faqat raqamlar bo'lishi kerak\n\nKonsol dasturida foydalanuvchidan raqam kiritishni so'rab, natijani `Valid` yoki `Invalid` deb chiqaring.\n\nExtension metodni `static` classda joylashtiring.",
        "examples": [
            "Telefon raqamini kiriting: 998901234567\nValid",
            "Telefon raqamini kiriting: 9901234567\nInvalid",
            "Telefon raqamini kiriting: 998123\nInvalid"
        ]
    },
    {
        "id": 44,
        "type": "code_writing",
        "metadata": {
            "category": "asosiy-til-xususiyatlari",
            "subcategory": "record structs",
            "concepts": [
                "record-structs",
                "pattern-matching",
                "switch-expressions"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "10.0",
            "estimatedTimeSeconds": 350,
            "prerequisites": [
                "record-structs",
                "pattern-matching"
            ],
            "learningObjectives": [
                "Record struct yaratish va ishlatish",
                "Koordinata tizimi bilan ishlash",
                "Pattern matching yordamida classification logic",
                "Switch expression da tuple pattern qo'llash"
            ],
            "commonMistakes": [
                "Record struct o'rniga record class ishlatish",
                "Pattern matching o'rniga if-else chain ishlatish",
                "Coordinate classification mantiqida xato"
            ],
            "relatedQuestions": [
                12,
                22
            ],
            "tags": [
                "coordinate-system",
                "classification-logic",
                "tuple-pattern",
                "geometric-analysis"
            ]
        },
        "prompt": "### 4. `record struct` yordamida koordinata tahlili\n\n`Point` nomli `record struct` yarating, unda `X` va `Y` property bo'lsin.\n\n`Classify(Point p)` metodini yozing:\n- Agar X va Y ikkalasi ham 0: `\"Origin\"`\n- Agar faqat Y 0: `\"X-axis\"`\n- Agar faqat X 0: `\"Y-axis\"`\n- Boshqa holatlarda: `\"Quadrant\"`\n\nPattern matching va switch expressionlardan foydalaning.\n\nFoydalanuvchidan koordinatalarni kiritishni so'rang va natijani chiqaring.",
        "examples": [
            "X ni kiriting: 0\nY ni kiriting: 0\nJoylashuv: Origin",
            "X ni kiriting: 5\nY ni kiriting: 0\nJoylashuv: X-axis",
            "X ni kiriting: 3\nY ni kiriting: 4\nJoylashuv: Quadrant"
        ]
    },
    {
        "id": 45,
        "type": "code_writing",
        "metadata": {
            "category": "metod-xususiyatlari",
            "subcategory": "params arrays",
            "concepts": [
                "params-arrays",
                "switch-expressions"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "8.0",
            "estimatedTimeSeconds": 400,
            "prerequisites": [
                "params-arrays",
                "collections"
            ],
            "learningObjectives": [
                "Params array parameter bilan flexible metodlar yozish",
                "Mathematical operations va aggregation logic",
                "Switch expression da string pattern matching",
                "Edge case handling va error validation"
            ],
            "commonMistakes": [
                "Bo'sh array holatini handle qilmaslik",
                "Params array sintaksisida xato",
                "Noto'g'ri operatsiya holatini handle qilmaslik"
            ],
            "relatedQuestions": [
                2,
                5
            ],
            "tags": [
                "matematik-kalkulyator",
                "aggregation-logic",
                "error-handling",
                "flexible-parameters"
            ]
        },
        "prompt": "### 5. `params` va `switch` yordamida oddiy kalkulyator\n\n`Calculate(string operation, params double[] values)` metodini yarating:\n\nQo'llab-quvvatlanadigan operatsiyalar:\n- `\"sum\"` - barcha qiymatlarni qo'shish\n- `\"average\"` - o'rtacha qiymat\n- `\"max\"` - eng katta qiymat\n- `\"min\"` - eng kichik qiymat\n\n`switch` expressiondan foydalaning va edge caselarni handle qiling (bo'sh array, noto'g'ri operatsiya).\n\nKonsol dasturida foydalanuvchidan operatsiya va sonlarni kiritishni so'rang.",
        "examples": [
            "Operatsiyani kiriting: sum\nQiymatlarni probel bilan ajratib kiriting: 3 5 2\nNatija: 10",
            "Operatsiyani kiriting: average\nQiymatlarni probel bilan ajratib kiriting: 4 8\nNatija: 6"
        ]
    },
    {
        "id": 46,
        "type": "mcq",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "queue",
            "concepts": [
                "basic-collections",
                "queue"
            ],
            "difficulty": "boshlang'ich",
            "csharpVersion": "6.0",
            "estimatedTimeSeconds": 80,
            "prerequisites": [
                "collections"
            ],
            "learningObjectives": [
                "Queue<T> FIFO (First In, First Out) prinsipi tushunish",
                "Queue konstruktor va Dequeue metodi ishlash tartibi",
                "Collection initializer dan Queue yaratish"
            ],
            "commonMistakes": [
                "Queue ni Stack kabi LIFO deb o'ylash",
                "Dequeue oxirgi elementni chiqaradi deb fikrlash"
            ],
            "relatedQuestions": [
                51,
                95
            ],
            "tags": [
                "fifo",
                "queue-operatsiyalar",
                "collection-constructor"
            ]
        },
        "codeBefore": "```csharp\nvar list = new List<int> { 1, 2, 3, 4, 5 };\nvar queue = new Queue<int>(list);\nvar result = queue.Dequeue();\n```",
        "codeAfter": "",
        "prompt": "`Queue<T>` FIFO tartibda ishlaydi. Yuqoridagi kodda `result` ning qiymati nima bo'ladi?",
        "options": [
            {
                "id": "A",
                "option": "`1`",
                "explanation": "Queue FIFO bo'lgani uchun birinchi kiritilgan 1 birinchi chiqadi"
            },
            {
                "id": "B",
                "option": "`5`",
                "explanation": "Bu Stack (LIFO) uchun to'g'ri bo'lardi"
            },
            {
                "id": "C",
                "option": "`0`",
                "explanation": "Queue bo'sh emas, shuning uchun 0 emas"
            },
            {
                "id": "D",
                "option": "Exception",
                "explanation": "Queue da elementlar bor, exception bo'lmaydi"
            }
        ],
        "answer": [
            "A"
        ],
        "explanation": "Queue<T> FIFO (First In, First Out) kolleksiya. List dan yaratilganda elementlar tartib saqlanadi va Dequeue() birinchi element (1) ni qaytaradi."
    },
    {
        "id": 47,
        "type": "mcq",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "dictionary",
            "concepts": [
                "basic-collections",
                "dictionary"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "6.0",
            "estimatedTimeSeconds": 100,
            "prerequisites": [
                "collections",
                "key-value-pairs"
            ],
            "learningObjectives": [
                "Dictionary TryAdd metodi xatti-harakatini tushunish",
                "Key duplication va update farqini bilish",
                "Dictionary Add vs TryAdd farqini qo'llash"
            ],
            "commonMistakes": [
                "TryAdd mavjud key ni update qiladi deb o'ylash",
                "TryAdd va Add metodlari bir xil ishlaydi deb fikrlash"
            ],
            "relatedQuestions": [
                72,
                82,
                91
            ],
            "tags": [
                "dictionary-metodlar",
                "key-duplication",
                "safe-operations"
            ]
        },
        "codeBefore": "```csharp\nvar dict = new Dictionary<string, int>\n{\n    [\"apple\"] = 5,\n    [\"banana\"] = 3\n};\ndict.TryAdd(\"apple\", 10);\nConsole.WriteLine(dict[\"apple\"]);\n```",
        "codeAfter": "",
        "prompt": "`Dictionary<TKey, TValue>` da `TryAdd` metodining xususiyati nimada? Natija nima bo'ladi?",
        "options": [
            {
                "id": "A",
                "option": "`10` - chunki yangi qiymat qo'shiladi",
                "explanation": "TryAdd mavjud key ni update qilmaydi"
            },
            {
                "id": "B",
                "option": "`5` - chunki mavjud key ni update qilmaydi",
                "explanation": "To'g'ri. TryAdd mavjud key uchun false qaytaradi va qiymatni o'zgartirmaydi"
            },
            {
                "id": "C",
                "option": "Exception - chunki duplicate key",
                "explanation": "TryAdd exception bermasdan false qaytaradi"
            },
            {
                "id": "D",
                "option": "`15` - chunki qiymatlar qo'shiladi",
                "explanation": "TryAdd qiymatlarni qo'shmaydi, faqat yangi key qo'shadi"
            }
        ],
        "answer": [
            "B"
        ],
        "explanation": "TryAdd metodi mavjud key uchun hech narsa qilmaydi va false qaytaradi. 'apple' key allaqachon mavjud bo'lgani uchun qiymati 5 bo'lib qoladi."
    },
    {
        "id": 48,
        "type": "mcq",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "indexing slicing",
            "concepts": [
                "indexing-slicing",
                "index-operator",
                "range-operator"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "8.0",
            "estimatedTimeSeconds": 90,
            "prerequisites": [
                "arrays"
            ],
            "learningObjectives": [
                "Index operator (^) oxiridan hisoblash qoidasini tushunish",
                "Range operator (..) slice yaratish mexanizmini bilish",
                "^2.. kombinatsiyasi natijasini to'g'ri hisoblash"
            ],
            "commonMistakes": [
                "^2 oxirdan ikkinchi element degani deb o'ylash",
                "Range operator inclusive/exclusive chegaralarini adashtirib yuborish"
            ],
            "relatedQuestions": [
                52,
                83,
                92
            ],
            "tags": [
                "hat-operator",
                "range-slice",
                "oxirdan-indeks"
            ]
        },
        "codeBefore": "```csharp\nvar numbers = new int[] { 1, 2, 3, 4, 5 };\nvar lastTwo = numbers[^2..];\nConsole.WriteLine(string.Join(\", \", lastTwo));\n```",
        "codeAfter": "",
        "prompt": "Index (`^`) va Range (`..`) operatorlaridan foydalanilgan kodda natija qanday bo'ladi?",
        "options": [
            {
                "id": "A",
                "option": "`4, 5`",
                "explanation": "To'g'ri. ^2 oxirdan 2ta oldin (index 3), .. oxirigacha"
            },
            {
                "id": "B",
                "option": "`3, 4`",
                "explanation": "Bu ^3.. bo'lgan holat uchun to'g'ri bo'lardi"
            },
            {
                "id": "C",
                "option": "`2, 3, 4, 5`",
                "explanation": "Bu [1..] bo'lgan holat uchun to'g'ri bo'lardi"
            },
            {
                "id": "D",
                "option": "`5`",
                "explanation": "Bu [^1] bo'lgan holat uchun to'g'ri bo'lardi"
            }
        ],
        "answer": [
            "A"
        ],
        "explanation": "^2 degani oxirdan 2 ta oldin (index 3, qiymat 4), .. degani oxirigacha. Natijada oxirgi 2 ta element: 4, 5."
    },
    {
        "id": 49,
        "type": "mcq",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "memory types",
            "concepts": [
                "memory-types",
                "span",
                "memory",
                "readonly-span"
            ],
            "difficulty": "murakkab",
            "csharpVersion": "7.2",
            "estimatedTimeSeconds": 150,
            "prerequisites": [
                "ref-structs",
                "memory-management"
            ],
            "learningObjectives": [
                "Span<T> va Memory<T> farqini tushunish",
                "Memory<T> heap va stack flexibility",
                "ReadOnlySpan<T> immutability xususiyatlari",
                "Ref struct vs regular struct farqini bilish"
            ],
            "commonMistakes": [
                "Span<T> faqat stack bilan ishlaydi deb o'ylash",
                "Memory<T> ni ref struct deb bilish",
                "ReadOnlySpan dan Span ga cast mumkin deb fikrlash"
            ],
            "relatedQuestions": [
                60,
                61,
                84,
                94
            ],
            "tags": [
                "span-memory",
                "ref-struct",
                "memory-efficiency",
                "stack-heap"
            ]
        },
        "codeBefore": "```csharp\nspan<int> span = stackalloc int[3] { 1, 2, 3 };\nReadOnlySpan<int> readOnlySpan = span;\nvar memory = span.ToArray().AsMemory();\n```",
        "codeAfter": "",
        "prompt": "`Span<T>` va `Memory<T>` haqida qaysi fikr **to'g'ri**?",
        "options": [
            {
                "id": "A",
                "option": "`Span<T>` faqat stack da ishlaydi",
                "explanation": "Noto'g'ri. Span<T> heap arraylar bilan ham ishlaydi"
            },
            {
                "id": "B",
                "option": "`Memory<T>` heap va stack ikkalasida ham ishlaydi",
                "explanation": "To'g'ri. Memory<T> universal va async-safe"
            },
            {
                "id": "C",
                "option": "`ReadOnlySpan<T>` dan `Span<T>` ga implicit cast mumkin",
                "explanation": "Noto'g'ri. ReadOnlySpan immutable, Span mutable"
            },
            {
                "id": "D",
                "option": "`Memory<T>` ref struct hisoblanadi",
                "explanation": "Noto'g'ri. Memory<T> oddiy struct, Span<T> ref struct"
            }
        ],
        "answer": [
            "B"
        ],
        "explanation": "Memory<T> heap va stack ikkalasida ham ishlaydi va async metodlarda ishlatish mumkin, Span<T>dan farqli o'laroq u ref struct emas."
    },
    {
        "id": 50,
        "type": "mcq",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "set operations",
            "concepts": [
                "basic-collections",
                "hashset",
                "set-operations"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "6.0",
            "estimatedTimeSeconds": 100,
            "prerequisites": [
                "collections",
                "set-theory"
            ],
            "learningObjectives": [
                "HashSet<T> IntersectWith metodi matematik intersection",
                "Set operatsiyalarini amaliy qo'llash",
                "In-place collection modification mexanizmini tushunish"
            ],
            "commonMistakes": [
                "IntersectWith yangi HashSet yaratadi deb o'ylash",
                "Set intersection matematik ma'nosini bilmaslik",
                "Union bilan Intersection ni chalkashtirib yuborish"
            ],
            "relatedQuestions": [
                76,
                93
            ],
            "tags": [
                "set-intersection",
                "in-place-modification",
                "matematik-operatsiya"
            ]
        },
        "codeBefore": "```csharp\nvar hashSet = new HashSet<int> { 1, 2, 3 };\nvar list = new List<int> { 2, 3, 4, 5 };\nhashSet.IntersectWith(list);\n```",
        "codeAfter": "",
        "prompt": "`HashSet<T>.IntersectWith()` operatsiyasidan keyin `hashSet` da qanday elementlar qoladi?",
        "options": [
            {
                "id": "A",
                "option": "`{ 1, 2, 3, 4, 5 }`",
                "explanation": "Bu UnionWith natijasi bo'lardi"
            },
            {
                "id": "B",
                "option": "`{ 2, 3 }`",
                "explanation": "To'g'ri. Intersection - umumiy elementlar"
            },
            {
                "id": "C",
                "option": "`{ 1 }`",
                "explanation": "Bu ExceptWith natijasi bo'lardi"
            },
            {
                "id": "D",
                "option": "`{ 4, 5 }`",
                "explanation": "Bu list ning unique elementlari"
            }
        ],
        "answer": [
            "B"
        ],
        "explanation": "IntersectWith matematik intersection operatsiyasi - faqat ikkala to'plamda ham mavjud elementlar qoladi: 2 va 3."
    },
    {
        "id": 51,
        "type": "mcq",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "stack",
            "concepts": [
                "basic-collections",
                "stack"
            ],
            "difficulty": "boshlang'ich",
            "csharpVersion": "6.0",
            "estimatedTimeSeconds": 80,
            "prerequisites": [
                "collections"
            ],
            "learningObjectives": [
                "Stack<T> LIFO (Last In, First Out) prinsipi tushunish",
                "Peek vs Pop metod farqini bilish",
                "Stack operatsiyalari va Count property o'zgarishi"
            ],
            "commonMistakes": [
                "Stack ni Queue kabi FIFO deb o'ylash",
                "Peek metodining elementni olib tashlamasligini bilmaslik"
            ],
            "relatedQuestions": [
                46,
                95
            ],
            "tags": [
                "lifo",
                "stack-operatsiyalar",
                "peek-vs-pop"
            ]
        },
        "codeBefore": "```csharp\nvar stack = new Stack<string>();\nstack.Push(\"first\");\nstack.Push(\"second\");\nvar result = stack.Peek();\nstack.Pop();\nConsole.WriteLine($\"{result}, {stack.Count}\");\n```",
        "codeAfter": "",
        "prompt": "`Stack<T>` LIFO prinsipi bo'yicha ishlaydi. Yuqoridagi kodda natija nima?",
        "options": [
            {
                "id": "A",
                "option": "`first, 1`",
                "explanation": "Peek() 'second' ni qaytaradi, chunki LIFO"
            },
            {
                "id": "B",
                "option": "`second, 1`",
                "explanation": "To'g'ri. Peek() oxirgi elementni ko'rsatadi, Pop() uni olib tashlaydi"
            },
            {
                "id": "C",
                "option": "`second, 0`",
                "explanation": "Count 1 bo'ladi, chunki bitta element qoladi"
            },
            {
                "id": "D",
                "option": "`first, 0`",
                "explanation": "Peek() oxirgi element 'second' ni qaytaradi"
            }
        ],
        "answer": [
            "B"
        ],
        "explanation": "Stack LIFO: Peek() oxirgi qo'shilgan 'second' ni qaytaradi (olib tashlamaydi), keyin Pop() uni olib tashlaydi. Count = 1 qoladi."
    },
    {
        "id": 52,
        "type": "mcq",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "indexing slicing",
            "concepts": [
                "indexing-slicing",
                "range-operator"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "8.0",
            "estimatedTimeSeconds": 100,
            "prerequisites": [
                "arrays",
                "range-operator"
            ],
            "learningObjectives": [
                "Range operator (..) syntax va semantika",
                "Start..End exclusive end boundary tushunish",
                "Array slicing natijasini to'g'ri hisoblash"
            ],
            "commonMistakes": [
                "Range end boundary inclusive deb o'ylash",
                "^1 oxirgi elementni bildiradi deb fikrlash",
                "Range syntax bilan array indexing aralashtirib yuborish"
            ],
            "relatedQuestions": [
                48,
                83,
                92
            ],
            "tags": [
                "range-boundary",
                "exclusive-end",
                "array-slicing"
            ]
        },
        "codeBefore": "```csharp\nvar numbers = new int[] { 10, 20, 30, 40, 50 };\nvar range = 1..^1;\nvar slice = numbers[range];\n```",
        "codeAfter": "",
        "prompt": "Range operatori `1..^1` nimani anglatadi va `slice` da qanday qiymatlar bo'ladi?",
        "options": [
            {
                "id": "A",
                "option": "1-indexdan oxirgi elementgacha: `{ 20, 30, 40, 50 }`",
                "explanation": "Range end boundary exclusive, oxirgi element kiritilmaydi"
            },
            {
                "id": "B",
                "option": "1-indexdan oxirgi elementni hisobga olmaganda: `{ 20, 30, 40 }`",
                "explanation": "To'g'ri. 1..^1 = index 1 dan oxirgi element exclusive"
            },
            {
                "id": "C",
                "option": "Faqat 1-index: `{ 20 }`",
                "explanation": "Bu 1..2 bo'lgan holat uchun to'g'ri bo'lardi"
            },
            {
                "id": "D",
                "option": "Kompilyatsiya xatosi",
                "explanation": "Range syntax to'g'ri, xato yo'q"
            }
        ],
        "answer": [
            "B"
        ],
        "explanation": "1..^1 degani index 1 dan (20) boshlab, oxirgi elementgacha (exclusive). ^1 oxirgi element pozitsiyasi, lekin range da exclusive. Natija: {20, 30, 40}."
    },
    {
        "id": 53,
        "type": "mcq",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "lookup",
            "concepts": [
                "advanced-collections",
                "lookup",
                "grouping"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "6.0",
            "estimatedTimeSeconds": 120,
            "prerequisites": [
                "collections",
                "linq-grouping"
            ],
            "learningObjectives": [
                "ILookup<TKey, TElement> one-to-many mapping tushunish",
                "ToLookup metodi va Dictionary farqini bilish",
                "Lookup key orqali multiple value olish mexanizmi"
            ],
            "commonMistakes": [
                "Lookup ni Dictionary kabi one-to-one mapping deb o'ylash",
                "Duplicate value lar unique bo'ladi deb fikrlash"
            ],
            "relatedQuestions": [
                73,
                85
            ],
            "tags": [
                "one-to-many",
                "grouping-collection",
                "tolookup-metod"
            ]
        },
        "codeBefore": "```csharp\nvar lookup = new string[] { \"a\", \"bb\", \"ccc\", \"a\", \"bb\" }\n    .ToLookup(x => x.Length);\nvar result = lookup[2].Count();\n```",
        "codeAfter": "",
        "prompt": "`ILookup<TKey, TElement>` haqida qaysi fikr to'g'ri va yuqoridagi kodda `result` nima?",
        "options": [
            {
                "id": "A",
                "option": "Lookup bir key uchun bitta value saqlaydi, result = 1",
                "explanation": "Noto'g'ri. Lookup one-to-many mapping"
            },
            {
                "id": "B",
                "option": "Lookup bir key uchun ko'p value saqlaydi, result = 2",
                "explanation": "To'g'ri. Key=2 uchun 'bb' va 'bb' - 2 ta element"
            },
            {
                "id": "C",
                "option": "Lookup faqat unique valuelar saqlaydi, result = 1",
                "explanation": "Noto'g'ri. Lookup duplicate valuelarni saqlaydi"
            },
            {
                "id": "D",
                "option": "Exception - key topilmadi",
                "explanation": "Lookup mavjud bo'lmagan key uchun bo'sh collection qaytaradi"
            }
        ],
        "answer": [
            "B"
        ],
        "explanation": "ILookup one-to-many mapping. Length=2 uchun 'bb' 2 marta mavjud, shuning uchun Count()=2."
    },
    {
        "id": 54,
        "type": "mcq",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "memory types",
            "concepts": [
                "memory-types",
                "span",
                "memory",
                "slicing"
            ],
            "difficulty": "murakkab",
            "csharpVersion": "7.2",
            "estimatedTimeSeconds": 140,
            "prerequisites": [
                "span-memory",
                "memory-management"
            ],
            "learningObjectives": [
                "Span<T>.Slice() zero-copy slicing mexanizmi",
                "Memory<T>.Span property usage",
                "Stack vs heap backed Span farqi",
                "Memory allocation vs view creation farqi"
            ],
            "commonMistakes": [
                "Slice() yangi memory allocate qiladi deb o'ylash",
                "Span location va backing store aralashtirib yuborish"
            ],
            "relatedQuestions": [
                49,
                60,
                61,
                84,
                94
            ],
            "tags": [
                "zero-copy",
                "slice-operatsiya",
                "memory-view",
                "stack-vs-heap"
            ]
        },
        "codeBefore": "```csharp\nSpan<byte> buffer = stackalloc byte[1024];\nvar memory = new Memory<byte>(new byte[1024]);\nvar span1 = buffer.Slice(10, 100);\nvar span2 = memory.Span.Slice(10, 100);\n```",
        "codeAfter": "",
        "prompt": "`Span<T>.Slice()` va `Memory<T>.Span` haqida qaysi fikr **noto'g'ri**?",
        "options": [
            {
                "id": "A",
                "option": "`Slice()` yangi Span yaratadi, copy emas",
                "explanation": "To'g'ri. Slice() view yaratadi, data copy qilmaydi"
            },
            {
                "id": "B",
                "option": "`Memory<T>.Span` property orqali Span olish mumkin",
                "explanation": "To'g'ri. Memory dan Span ga conversion mumkin"
            },
            {
                "id": "C",
                "option": "`span1` stack da, `span2` heap da joylashgan",
                "explanation": "To'g'ri. stackalloc stack, new byte[] heap"
            },
            {
                "id": "D",
                "option": "`Slice()` operatsiyasi xotira allocate qiladi",
                "explanation": "Noto'g'ri! Slice() faqat view yaratadi, allocate qilmaydi"
            }
        ],
        "answer": [
            "D"
        ],
        "explanation": "Slice() operatsiyasi yangi xotira allocate qilmaydi - faqat mavjud memory ga yangi view (ko'rinish) yaratadi. Bu zero-copy operatsiya."
    },
    {
        "id": 55,
        "type": "mcq",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "priority queue",
            "concepts": [
                "advanced-collections",
                "priority-queue",
                "heap-structure"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "11.0",
            "estimatedTimeSeconds": 100,
            "prerequisites": [
                "collections"
            ],
            "learningObjectives": [
                "PriorityQueue<TElement, TPriority> min-heap xususiyati",
                "Priority-based dequeue tartibini tushunish",
                "Enqueue/Dequeue operatsiyalari va priority comparison"
            ],
            "commonMistakes": [
                "Eng katta priority birinchi chiqadi deb o'ylash",
                "FIFO tartibida chiqadi deb fikrlash",
                "Priority queue ni oddiy queue deb hisoblash"
            ],
            "relatedQuestions": [
                46,
                51
            ],
            "tags": [
                "min-heap",
                "priority-based",
                "heap-operatsiya",
                "net6-yangilik"
            ]
        },
        "codeBefore": "```csharp\nvar priorityQueue = new PriorityQueue<string, int>();\npriorityQueue.Enqueue(\"task1\", 3);\npriorityQueue.Enqueue(\"task2\", 1);\npriorityQueue.Enqueue(\"task3\", 2);\nvar result = priorityQueue.Dequeue();\n```",
        "codeAfter": "",
        "prompt": "`PriorityQueue<TElement, TPriority>` eng kichik priority ni birinchi chiqaradi. `result` nima bo'ladi?",
        "options": [
            {
                "id": "A",
                "option": "`task1`",
                "explanation": "task1 ning priority si 3 - eng katta"
            },
            {
                "id": "B",
                "option": "`task2`",
                "explanation": "To'g'ri. task2 ning priority si 1 - eng kichik"
            },
            {
                "id": "C",
                "option": "`task3`",
                "explanation": "task3 ning priority si 2 - o'rta"
            },
            {
                "id": "D",
                "option": "Exception",
                "explanation": "Queue bo'sh emas, exception bo'lmaydi"
            }
        ],
        "answer": [
            "B"
        ],
        "explanation": "PriorityQueue min-heap - eng kichik priority birinchi chiqadi. task2 ning priority si 1 (eng kichik), shuning uchun birinchi chiqadi."
    },
    {
        "id": 56,
        "type": "true_false",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "dictionary",
            "concepts": [
                "basic-collections",
                "dictionary",
                "nullable-types"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "8.0",
            "estimatedTimeSeconds": 70,
            "prerequisites": [
                "collections",
                "nullable-reference-types"
            ],
            "learningObjectives": [
                "Dictionary key constraints va nullable reference types",
                "Null key support nullable type bilan",
                "Collection generic constraints tushunish"
            ],
            "commonMistakes": [
                "Dictionary hech qachon null key qabul qilmaydi deb o'ylash",
                "Nullable reference type va nullable value type aralashtirib yuborish"
            ],
            "relatedQuestions": [
                47,
                72,
                82,
                91
            ],
            "tags": [
                "null-key",
                "nullable-constraint",
                "generic-constraint"
            ]
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "`Dictionary<TKey, TValue>` da key uchun `null` qiymat qo'yish mumkin, agar `TKey` nullable type bo'lsa.",
        "answer": "true",
        "explanation": "To'g'ri. Agar TKey nullable type bo'lsa (masalan, string? yoki int?), Dictionary null key qabul qiladi."
    },
    {
        "id": 57,
        "type": "true_false",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "set operations",
            "concepts": [
                "basic-collections",
                "hashset",
                "set-properties"
            ],
            "difficulty": "boshlang'ich",
            "csharpVersion": "6.0",
            "estimatedTimeSeconds": 60,
            "prerequisites": [
                "collections"
            ],
            "learningObjectives": [
                "HashSet<T> uniqueness kafolati",
                "Set collection ordering xususiyatlari",
                "HashSet vs SortedSet farqini bilish"
            ],
            "commonMistakes": [
                "HashSet tartibni saqlaydi deb o'ylash",
                "Hash-based va sorted collection aralashtirib yuborish"
            ],
            "relatedQuestions": [
                50,
                76,
                93
            ],
            "tags": [
                "uniqueness-only",
                "no-ordering",
                "hash-collection"
            ]
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "`HashSet<T>` collection elementlarning unique bo'lishini kafolatlaydi va tartibni saqlaydi.",
        "answer": "false",
        "explanation": "Yolg'on. HashSet uniqueness kafolatlaydi, lekin insertion tartibini saqlamaydi. Tartib uchun SortedSet ishlatiladi."
    },
    {
        "id": 58,
        "type": "true_false",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "indexing slicing",
            "concepts": [
                "indexing-slicing",
                "index-operator"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "8.0",
            "estimatedTimeSeconds": 70,
            "prerequisites": [
                "arrays",
                "index-operator"
            ],
            "learningObjectives": [
                "Index operator (^) semantikasini to'g'ri tushunish",
                "^0 vs ^1 farqini bilish",
                "From-end indexing qoidalarini qo'llash"
            ],
            "commonMistakes": [
                "^0 oxirgi element deb o'ylash",
                "^1 oxirdan birinchi element deb bilmaslik"
            ],
            "relatedQuestions": [
                48,
                52,
                64,
                83,
                92
            ],
            "tags": [
                "from-end-indexing",
                "hat-operator",
                "array-boundary"
            ]
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "Index operator `^0` massivning oxirgi elementini anglatadi.",
        "answer": "false",
        "explanation": "Yolg'on. ^0 massiv uzunligini bildiradi (bounds dan tashqarida). Oxirgi element ^1 bilan ko'rsatiladi."
    },
    {
        "id": 59,
        "type": "true_false",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "indexing slicing",
            "concepts": [
                "indexing-slicing",
                "range-operator"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "8.0",
            "estimatedTimeSeconds": 80,
            "prerequisites": [
                "collections",
                "range-operator"
            ],
            "learningObjectives": [
                "Range operator qo'llanish sohasini tushunish",
                "IEnumerable collections bilan range usage",
                "Indexable collection pattern recognition"
            ],
            "commonMistakes": [
                "Range operator faqat array uchun ishlaydi deb o'ylash",
                "Collection type restrictions mavjud deb fikrlash"
            ],
            "relatedQuestions": [
                48,
                52,
                64,
                83,
                92
            ],
            "tags": [
                "range-support",
                "collection-compatibility",
                "dotdot-operator"
            ]
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "Range operator `..` faqat array va string uchun ishlatiladi, boshqa collectionlar uchun emas.",
        "answer": "false",
        "explanation": "Yolg'on. Range operator (..) indexer qo'llab-quvvatlaydigan barcha collection lar uchun ishlatiladi (List<T>, Span<T> va h.k.)."
    },
    {
        "id": 60,
        "type": "true_false",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "memory types",
            "concepts": [
                "memory-types",
                "span",
                "ref-structs"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "7.2",
            "estimatedTimeSeconds": 80,
            "prerequisites": [
                "ref-structs",
                "memory-management"
            ],
            "learningObjectives": [
                "Ref struct heap allocation cheklovini tushunish",
                "Span<T> ning ref struct nature va limitations",
                "Stack-only reference types xususiyatlari"
            ],
            "commonMistakes": [
                "Ref struct larni heap da saqlash mumkin deb o'ylash",
                "Span<T> heap allocation qoidalarini bilmaslik"
            ],
            "relatedQuestions": [
                49,
                54,
                61,
                84,
                94
            ],
            "tags": [
                "ref-struct-constraint",
                "stack-only",
                "heap-restriction"
            ]
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "`Span<T>` ref struct bo'lgani uchun heap da saqlanishi mumkin emas.",
        "answer": "true",
        "explanation": "To'g'ri. Span<T> ref struct bo'lib, faqat stack da saqlanadi. Heap da saqlash uchun Memory<T> ishlatiladi."
    },
    {
        "id": 61,
        "type": "true_false",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "memory types",
            "concepts": [
                "memory-types",
                "span",
                "memory",
                "async-support"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "7.2",
            "estimatedTimeSeconds": 90,
            "prerequisites": [
                "span-memory",
                "async-await"
            ],
            "learningObjectives": [
                "Async metodlarda Memory<T> vs Span<T> farqi",
                "Ref struct async limitation tushunish",
                "Memory<T> async-safe xususiyatlari"
            ],
            "commonMistakes": [
                "Span<T> ni async metod parametri qilib berish",
                "Memory<T> va Span<T> async support farqini bilmaslik"
            ],
            "relatedQuestions": [
                49,
                54,
                60,
                84,
                94
            ],
            "tags": [
                "async-compatibility",
                "ref-struct-async",
                "memory-async-safe"
            ]
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "`Memory<T>` async metodlarda ishlatish mumkin, lekin `Span<T>` ishlatib bo'lmaydi.",
        "answer": "true",
        "explanation": "To'g'ri. Memory<T> async/await bilan ishlaydi, lekin Span<T> ref struct bo'lgani uchun async metodlarda ishlatib bo'lmaydi."
    },
    {
        "id": 62,
        "type": "true_false",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "thread safety",
            "concepts": [
                "basic-collections",
                "thread-safety",
                "concurrency"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "6.0",
            "estimatedTimeSeconds": 70,
            "prerequisites": [
                "collections",
                "threading"
            ],
            "learningObjectives": [
                "Generic collection thread-safety xususiyatlari",
                "Queue<T> va Stack<T> concurrency limitations",
                "Thread-safe collection alternatives bilish"
            ],
            "commonMistakes": [
                "Generic collection lar thread-safe deb o'ylash",
                "ConcurrentQueue va Queue farqini bilmaslik"
            ],
            "relatedQuestions": [
                46,
                51,
                75,
                86
            ],
            "tags": [
                "thread-unsafe",
                "concurrent-alternatives",
                "generic-collection-safety"
            ]
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "`Queue<T>` va `Stack<T>` ikkalasi ham generic collection bo'lib, thread-safe emas.",
        "answer": "true",
        "explanation": "To'g'ri. Queue<T> va Stack<T> thread-safe emas. Multi-threading uchun ConcurrentQueue<T> va ConcurrentStack<T> ishlatiladi."
    },
    {
        "id": 63,
        "type": "true_false",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "sorted collections",
            "concepts": [
                "advanced-collections",
                "sorted-dictionary",
                "ordered-collections"
            ],
            "difficulty": "boshlang'ich",
            "csharpVersion": "6.0",
            "estimatedTimeSeconds": 60,
            "prerequisites": [
                "collections",
                "key-value-pairs"
            ],
            "learningObjectives": [
                "SortedDictionary<TKey, TValue> ordering xususiyati",
                "Dictionary vs SortedDictionary farqi",
                "Automatic sorting mexanizmi tushunish"
            ],
            "commonMistakes": [
                "SortedDictionary manual sorting talab qiladi deb o'ylash",
                "Dictionary ham sorted deb fikrlash"
            ],
            "relatedQuestions": [
                47,
                74,
                89
            ],
            "tags": [
                "auto-sorting",
                "key-ordering",
                "sorted-collection"
            ]
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "`SortedDictionary<TKey, TValue>` elementlarni key bo'yicha tartiblab saqlaydi.",
        "answer": "true",
        "explanation": "To'g'ri. SortedDictionary elementlarni key bo'yicha avtomatik tartiblab saqlaydi, insertion order ga qaramay."
    },
    {
        "id": 64,
        "type": "true_false",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "indexing slicing",
            "concepts": [
                "indexing-slicing",
                "range-operator"
            ],
            "difficulty": "boshlang'ich",
            "csharpVersion": "8.0",
            "estimatedTimeSeconds": 60,
            "prerequisites": [
                "arrays",
                "range-operator"
            ],
            "learningObjectives": [
                "Range operator (..) basic syntax tushunish",
                "Start.. unbounded range usage",
                "Array slicing asosiy qoidalarini qo'llash"
            ],
            "commonMistakes": [
                "Range operator inclusive end boundary deb o'ylash",
                "Index calculation da xato qilish"
            ],
            "relatedQuestions": [
                48,
                52,
                58,
                59,
                83,
                92
            ],
            "tags": [
                "range-slicing",
                "unbounded-range",
                "array-subset"
            ]
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "Range operator `numbers[2..]` 2-indexdan boshlab oxirigacha bo'lgan elementlarni oladi.",
        "answer": "true",
        "explanation": "To'g'ri. [2..] degani 2-indexdan boshlab oxirigacha bo'lgan barcha elementlar (2-index ham kiritiladi)."
    },
    {
        "id": 65,
        "type": "true_false",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "list types",
            "concepts": [
                "basic-collections",
                "linkedlist",
                "indexing-slicing"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "6.0",
            "estimatedTimeSeconds": 80,
            "prerequisites": [
                "collections",
                "data-structures"
            ],
            "learningObjectives": [
                "LinkedList<T> sequential access nature",
                "Random access vs sequential access farqi",
                "Collection indexer support requirements"
            ],
            "commonMistakes": [
                "LinkedList da indexer operator [] bor deb o'ylash",
                "Barcha collection lar random access qo'llab-quvvatlaydi deb fikrlash"
            ],
            "relatedQuestions": [
                77,
                88
            ],
            "tags": [
                "sequential-access",
                "no-indexer",
                "linked-structure"
            ]
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "`LinkedList<T>` collection random access ni qo'llab-quvvatlaydi va indexer operator `[]` ga ega.",
        "answer": "false",
        "explanation": "Yolg'on. LinkedList<T> sequential access collection bo'lib, indexer operator [] ga ega emas. Random access uchun List<T> ishlatiladi."
    },
    {
        "id": 66,
        "type": "true_false",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "memory types",
            "concepts": [
                "memory-types",
                "span",
                "readonly-span"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "7.2",
            "estimatedTimeSeconds": 80,
            "prerequisites": [
                "span-memory",
                "readonly-types"
            ],
            "learningObjectives": [
                "ReadOnlySpan<T> immutability xususiyatlari",
                "Span<T> va ReadOnlySpan<T> conversion rules",
                "Readonly types implicit conversion cheklovlari"
            ],
            "commonMistakes": [
                "ReadOnlySpan dan Span ga cast mumkin deb o'ylash",
                "Readonly types conversion qoidalarini bilmaslik"
            ],
            "relatedQuestions": [
                49,
                54,
                60,
                61,
                84,
                94
            ],
            "tags": [
                "readonly-immutable",
                "conversion-restriction",
                "span-readonly"
            ]
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "`ReadOnlySpan<T>` dan `Span<T>` ga implicit conversion mumkin.",
        "answer": "false",
        "explanation": "Yolg'on. ReadOnlySpan<T> immutable, Span<T> mutable. Readonly dan writable ga implicit conversion mumkin emas."
    },
    {
        "id": 67,
        "type": "true_false",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "memory types",
            "concepts": [
                "memory-types",
                "span",
                "collections-marshal"
            ],
            "difficulty": "murakkab",
            "csharpVersion": "7.2",
            "estimatedTimeSeconds": 100,
            "prerequisites": [
                "span-memory",
                "collections-marshal"
            ],
            "learningObjectives": [
                "CollectionsMarshal.AsSpan() interop metodi",
                "List<T> dan Span<T> ga xavfsiz conversion",
                "Advanced memory interop techniques"
            ],
            "commonMistakes": [
                "CollectionsMarshal unsafe deb o'ylash",
                "Manual conversion kerak deb fikrlash"
            ],
            "relatedQuestions": [
                49,
                54,
                60,
                61,
                84,
                94
            ],
            "tags": [
                "collections-marshal",
                "list-to-span",
                "safe-interop",
                "net5-yangilik"
            ]
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "`CollectionsMarshal.AsSpan()` metodi `List<T>` ni `Span<T>` ga xavfsiz tarzda convert qiladi.",
        "answer": "true",
        "explanation": "To'g'ri. CollectionsMarshal.AsSpan() List<T> ning ichki array ga xavfsiz access beradi va Span<T> sifatida qaytaradi."
    },
    {
        "id": 68,
        "type": "true_false",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "collection expressions",
            "concepts": [
                "collection-expressions",
                "spread-operator"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "12.0",
            "estimatedTimeSeconds": 70,
            "prerequisites": [
                "collections"
            ],
            "learningObjectives": [
                "C# 12 collection expression syntax",
                "Spread operator (..) ishlatish",
                "Modern collection initialization techniques"
            ],
            "commonMistakes": [
                "Spread operator bilan range operator aralashtirib yuborish",
                "C# 12 yangilik ekanligini bilmaslik"
            ],
            "relatedQuestions": [
                77,
                99
            ],
            "tags": [
                "spread-operator",
                "collection-expressions",
                "c12-yangilik",
                "modern-syntax"
            ]
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "Spread operator `..` C# 12 da collection expressions uchun ishlatiladi.",
        "answer": "true",
        "explanation": "To'g'ri. C# 12 da spread operator (..) collection expressions ichida existing collections ni spread qilish uchun ishlatiladi."
    },
    {
        "id": 69,
        "type": "true_false",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "thread safety",
            "concepts": [
                "advanced-collections",
                "concurrent-dictionary",
                "thread-safety"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "6.0",
            "estimatedTimeSeconds": 80,
            "prerequisites": [
                "collections",
                "threading",
                "concurrency"
            ],
            "learningObjectives": [
                "ConcurrentDictionary thread-safety xususiyatlari",
                "Lock-free programming concepts",
                "Concurrent collection advantages"
            ],
            "commonMistakes": [
                "ConcurrentDictionary lock ishlatadi deb o'ylash",
                "Thread-safe va lock-free farqini bilmaslik"
            ],
            "relatedQuestions": [
                47,
                56,
                62,
                86
            ],
            "tags": [
                "lock-free",
                "concurrent-collection",
                "thread-safe",
                "atomic-operations"
            ]
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "`ConcurrentDictionary<TKey, TValue>` thread-safe bo'lib, lock-free operatsiyalarni qo'llab-quvvatlaydi.",
        "answer": "true",
        "explanation": "To'g'ri. ConcurrentDictionary internal lock-free algorithm ishlatib, thread-safe operatsiyalarni ta'minlaydi."
    },
    {
        "id": 70,
        "type": "true_false",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "memory types",
            "concepts": [
                "memory-types",
                "memory",
                "readonly-memory",
                "ref-structs"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "7.2",
            "estimatedTimeSeconds": 80,
            "prerequisites": [
                "span-memory",
                "ref-structs"
            ],
            "learningObjectives": [
                "Memory<T> va ReadOnlyMemory<T> type nature",
                "Ref struct va regular struct farqi",
                "Memory types heap-storability"
            ],
            "commonMistakes": [
                "Memory<T> ni Span<T> kabi ref struct deb o'ylash",
                "Memory types heap restriction bor deb fikrlash"
            ],
            "relatedQuestions": [
                49,
                54,
                60,
                61,
                66,
                84,
                94
            ],
            "tags": [
                "memory-vs-span",
                "heap-storable",
                "not-ref-struct",
                "async-safe"
            ]
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "`Memory<T>` va `ReadOnlyMemory<T>` ikkalasi ham ref struct hisoblanadi.",
        "answer": "false",
        "explanation": "Yolg'on. Memory<T> va ReadOnlyMemory<T> oddiy struct lar. Faqat Span<T> va ReadOnlySpan<T> ref struct hisoblanadi."
    },
    {
        "id": 71,
        "type": "fill",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "list operations",
            "concepts": [
                "basic-collections",
                "list",
                "slicing"
            ],
            "difficulty": "boshlang'ich",
            "csharpVersion": "6.0",
            "estimatedTimeSeconds": 80,
            "prerequisites": [
                "collections"
            ],
            "learningObjectives": [
                "List<T>.GetRange() method parameters",
                "Index va count based slicing",
                "List substring extraction technique"
            ],
            "commonMistakes": [
                "GetRange parametr tartibini adashtirib yuborish",
                "Index calculation da xato qilish"
            ],
            "relatedQuestions": [
                78,
                88
            ],
            "tags": [
                "list-slicing",
                "getrange-method",
                "index-count",
                "sublist"
            ]
        },
        "codeWithBlank": "var numbers = new List<int> { 1, 2, 3, 4, 5 };\nvar result = numbers.GetRange(______, ______);\n// result should be { 2, 3, 4 }",
        "prompt": "`List<T>.GetRange(int index, int count)` metodida bo'sh joylarni to'ldiring, shunda natija `{ 2, 3, 4 }` bo'lsin.",
        "answer": "var numbers = new List<int> { 1, 2, 3, 4, 5 };\nvar result = numbers.GetRange(1, 3);\n// result should be { 2, 3, 4 }",
        "explanation": "Elements 2, 3, 4 index 1 dan boshlanadi va 3 ta element kerak: GetRange(1, 3)."
    },
    {
        "id": 72,
        "type": "fill",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "dictionary",
            "concepts": [
                "basic-collections",
                "dictionary",
                "safe-operations"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "6.0",
            "estimatedTimeSeconds": 90,
            "prerequisites": [
                "collections",
                "out-parameters"
            ],
            "learningObjectives": [
                "Dictionary.TryGetValue() safe access pattern",
                "Out parameter usage bilan exception avoidance",
                "Safe dictionary key lookup techniques"
            ],
            "commonMistakes": [
                "TryGetValue o'rniga indexer [] ishlatish",
                "Out parameter syntax da xato"
            ],
            "relatedQuestions": [
                47,
                56,
                82,
                91
            ],
            "tags": [
                "safe-access",
                "trygetvalue",
                "out-parameter",
                "exception-free"
            ]
        },
        "codeWithBlank": "var dict = new Dictionary<string, int> { [\"a\"] = 1, [\"b\"] = 2 };\nvar success = dict.________(\"c\", ______);\n// Agar key mavjud bo'lmasa, default qiymat qaytarsin",
        "prompt": "`Dictionary<TKey, TValue>` da key mavjud bo'lmasa default qiymat qaytaradigan metod va qiymatni yozing.",
        "answer": "var dict = new Dictionary<string, int> { [\"a\"] = 1, [\"b\"] = 2 };\nvar success = dict.TryGetValue(\"c\", out var value);\n// Agar key mavjud bo'lmasa, default qiymat qaytarsin",
        "explanation": "TryGetValue metodі safe access ta'minlaydi: success false, value default qiymat bo'ladi."
    },
    {
        "id": 73,
        "type": "fill",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "indexing slicing",
            "concepts": [
                "indexing-slicing",
                "range-operator",
                "string-slicing"
            ],
            "difficulty": "boshlang'ich",
            "csharpVersion": "8.0",
            "estimatedTimeSeconds": 70,
            "prerequisites": [
                "arrays",
                "strings",
                "range-operator"
            ],
            "learningObjectives": [
                "String slicing bilan range operator",
                "Substring extraction via ranges",
                "Range start position calculation"
            ],
            "commonMistakes": [
                "Range start position noto'g'ri hisoblash",
                "Substring() metod bilan aralashtirib yuborish"
            ],
            "relatedQuestions": [
                48,
                52,
                58,
                59,
                64,
                83,
                92
            ],
            "tags": [
                "string-slicing",
                "range-extraction",
                "substring-via-range"
            ]
        },
        "codeWithBlank": "var text = \"Hello World\";\nvar slice = text[______];\n// slice should be \"World\"",
        "prompt": "String dan \"World\" so'zini olish uchun Range operatorini yozing.",
        "answer": "var text = \"Hello World\";\nvar slice = text[6..];\n// slice should be \"World\"",
        "explanation": "'World' index 6 dan boshlanadi: text[6..] = 'World'."
    },
    {
        "id": 74,
        "type": "fill",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "memory types",
            "concepts": [
                "memory-types",
                "span",
                "span-operations"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "7.2",
            "estimatedTimeSeconds": 100,
            "prerequisites": [
                "span-memory",
                "stackalloc"
            ],
            "learningObjectives": [
                "Span<T>.Fill() method usage",
                "Span.Slice() parameters va indexing",
                "Stack allocated memory manipulation"
            ],
            "commonMistakes": [
                "Slice parameters noto'g'ri hisoblash",
                "Fill method parameter tipini bilmaslik"
            ],
            "relatedQuestions": [
                49,
                54,
                60,
                61,
                78,
                84,
                94
            ],
            "tags": [
                "span-fill",
                "span-slice",
                "stackalloc",
                "memory-manipulation"
            ]
        },
        "codeWithBlank": "Span<int> span = stackalloc int[5];\nspan.Fill(________);\nvar slice = span.Slice(______, ______);\n// Fill with 42, then get middle 3 elements",
        "prompt": "`Span<T>` ni 42 bilan to'ldiring va o'rtadagi 3 ta elementni oling.",
        "answer": "Span<int> span = stackalloc int[5];\nspan.Fill(42);\nvar slice = span.Slice(1, 3);\n// Fill with 42, then get middle 3 elements",
        "explanation": "Fill(42) barcha elementlarni 42 ga o'rnatadi. O'rtadagi 3 element: index 1 dan 3 ta - Slice(1, 3)."
    },
    {
        "id": 75,
        "type": "fill",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "priority queue",
            "concepts": [
                "advanced-collections",
                "priority-queue",
                "min-heap"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "11.0",
            "estimatedTimeSeconds": 90,
            "prerequisites": [
                "collections",
                "priority-concepts"
            ],
            "learningObjectives": [
                "PriorityQueue min-heap priority understanding",
                "Lower priority value = higher priority execution",
                "Priority-based ordering concepts"
            ],
            "commonMistakes": [
                "Katta raqam yuqori priority deb o'ylash",
                "FIFO tartibida ishlaydi deb fikrlash"
            ],
            "relatedQuestions": [
                55,
                46,
                51
            ],
            "tags": [
                "min-heap-priority",
                "low-number-high-priority",
                "queue-ordering"
            ]
        },
        "codeWithBlank": "var queue = new PriorityQueue<string, int>();\nqueue.Enqueue(\"low\", ______);\nqueue.Enqueue(\"high\", ______);\n// \"high\" should be dequeued first",
        "prompt": "`PriorityQueue` da \"high\" birinchi chiqishi uchun priority qiymatlarini yozing.",
        "answer": "var queue = new PriorityQueue<string, int>();\nqueue.Enqueue(\"low\", 10);\nqueue.Enqueue(\"high\", 1);\n// \"high\" should be dequeued first",
        "explanation": "PriorityQueue min-heap: kichik raqam yuqori priority. 'high' birinchi chiqishi uchun 1 (kichik), 'low' uchun 10 (katta)."
    },
    {
        "id": 76,
        "type": "fill",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "set operations",
            "concepts": [
                "basic-collections",
                "hashset",
                "set-operations"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "6.0",
            "estimatedTimeSeconds": 80,
            "prerequisites": [
                "collections",
                "set-theory"
            ],
            "learningObjectives": [
                "HashSet UnionWith metodi matematik union",
                "Set operatsiyalarini amaliy qo'llash",
                "In-place set modification mexanizmini tushunish"
            ],
            "commonMistakes": [
                "UnionWith yangi HashSet yaratadi deb o'ylash",
                "Set union matematik ma'nosini bilmaslik"
            ],
            "relatedQuestions": [
                50,
                93
            ],
            "tags": [
                "set-union",
                "in-place-modification",
                "hashset-operatsiya"
            ]
        },
        "codeWithBlank": "var hashSet1 = new HashSet<int> { 1, 2, 3 };\nvar hashSet2 = new HashSet<int> { 3, 4, 5 };\nhashSet1.________(hashSet2);\n// Result: { 1, 2, 3, 4, 5 }",
        "prompt": "Ikki `HashSet` ni birlashtirib, barcha unique elementlarni olish uchun metod nomini yozing.",
        "answer": "var hashSet1 = new HashSet<int> { 1, 2, 3 };\nvar hashSet2 = new HashSet<int> { 3, 4, 5 };\nhashSet1.UnionWith(hashSet2);\n// Result: { 1, 2, 3, 4, 5 }",
        "explanation": "UnionWith matematik union operatsiyasi - ikkala to'plamning barcha unique elementlarini birlashtirib, hashSet1 ni o'zgartiradi."
    },
    {
        "id": 77,
        "type": "fill",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "collection expressions",
            "concepts": [
                "collection-expressions",
                "spread-operator"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "12.0",
            "estimatedTimeSeconds": 90,
            "prerequisites": [
                "collections"
            ],
            "learningObjectives": [
                "C# 12 collection expression advanced syntax",
                "Multiple spread operators ishlatish",
                "Modern collection composition techniques"
            ],
            "commonMistakes": [
                "Spread operator sintaksisini bilmaslik",
                "Collection expression da faqat literal qo'yish mumkin deb o'ylash"
            ],
            "relatedQuestions": [
                68,
                86,
                97,
                99
            ],
            "tags": [
                "spread-multiple",
                "collection-composition",
                "c12-feature",
                "modern-concat"
            ]
        },
        "codeWithBlank": "var list1 = new List<int> { 1, 2 };\nvar list2 = new List<int> { 3, 4 };\nvar combined = [______];\n// Use collection expression with spread",
        "prompt": "C# 12 collection expression da spread operator yordamida ikki listni birlashtiring.",
        "answer": "var list1 = new List<int> { 1, 2 };\nvar list2 = new List<int> { 3, 4 };\nvar combined = [..list1, ..list2];\n// Use collection expression with spread",
        "explanation": "Collection expression da .. spread operator existing collection larni expand qiladi: [..list1, ..list2] = [1, 2, 3, 4]."
    },
    {
        "id": 78,
        "type": "fill",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "memory types",
            "concepts": [
                "memory-types",
                "memory",
                "slicing"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "7.2",
            "estimatedTimeSeconds": 90,
            "prerequisites": [
                "span-memory",
                "arrays"
            ],
            "learningObjectives": [
                "Memory<T>.Slice() method parameters",
                "Array to Memory conversion va slicing",
                "Memory vs Span slicing operations farqi"
            ],
            "commonMistakes": [
                "Memory.Slice parameters bilan Span.Slice aralashtirib yuborish",
                "Index calculation da xato qilish"
            ],
            "relatedQuestions": [
                49,
                54,
                60,
                61,
                66,
                70,
                74,
                84,
                94
            ],
            "tags": [
                "memory-slicing",
                "array-to-memory",
                "memory-operations"
            ]
        },
        "codeWithBlank": "var numbers = new int[] { 1, 2, 3, 4, 5 };\nvar memory = numbers.AsMemory();\nvar slice = memory.Slice(______, ______);\n// Get elements 2, 3, 4",
        "prompt": "`Memory<T>` dan elementlar 2, 3, 4 ni olish uchun `Slice` parametrlarini yozing.",
        "answer": "var numbers = new int[] { 1, 2, 3, 4, 5 };\nvar memory = numbers.AsMemory();\nvar slice = memory.Slice(1, 3);\n// Get elements 2, 3, 4",
        "explanation": "Elements 2, 3, 4 index 1 dan boshlanadi va 3 ta element: Memory.Slice(1, 3)."
    },
    {
        "id": 79,
        "type": "fill",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "sorted collections",
            "concepts": [
                "advanced-collections",
                "sorted-dictionary",
                "linq"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "6.0",
            "estimatedTimeSeconds": 80,
            "prerequisites": [
                "collections",
                "linq",
                "key-value-pairs"
            ],
            "learningObjectives": [
                "SortedDictionary Keys property usage",
                "LINQ First() method qo'llash",
                "Sorted collection key access patterns"
            ],
            "commonMistakes": [
                "SortedDictionary da direct indexing ishlatish",
                "Keys property orqali LINQ access bilmaslik"
            ],
            "relatedQuestions": [
                63,
                74,
                89
            ],
            "tags": [
                "sorted-access",
                "keys-property",
                "linq-first",
                "ordered-retrieval"
            ]
        },
        "codeWithBlank": "var sortedDict = new SortedDictionary<int, string>();\nsortedDict.Add(3, \"three\");\nsortedDict.Add(1, \"one\");\nsortedDict.Add(2, \"two\");\nvar firstKey = sortedDict.________.________;\n// Get the first key",
        "prompt": "`SortedDictionary` da birinchi key ni olish uchun property chain ni yozing.",
        "answer": "var sortedDict = new SortedDictionary<int, string>();\nsortedDict.Add(3, \"three\");\nsortedDict.Add(1, \"one\");\nsortedDict.Add(2, \"two\");\nvar firstKey = sortedDict.Keys.First();\n// Get the first key",
        "explanation": "SortedDictionary avtomatik tartiblab saqlaydi. Keys property sorted keys collection, First() birinchi key (1) ni qaytaradi."
    },
    {
        "id": 80,
        "type": "fill",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "memory types",
            "concepts": [
                "memory-types",
                "readonly-span",
                "search-operations"
            ],
            "difficulty": "boshlang'ich",
            "csharpVersion": "7.2",
            "estimatedTimeSeconds": 70,
            "prerequisites": [
                "span-memory",
                "char-operations"
            ],
            "learningObjectives": [
                "ReadOnlySpan<char> search operations",
                "IndexOf method character search",
                "Span search patterns va result handling"
            ],
            "commonMistakes": [
                "Character literal o'rniga string ishlatish",
                "IndexOf result negative bo'lishi mumkinligini bilmaslik"
            ],
            "relatedQuestions": [
                49,
                54,
                60,
                61,
                66,
                67,
                70,
                74,
                78,
                84,
                94
            ],
            "tags": [
                "char-search",
                "indexof-method",
                "span-search",
                "character-literal"
            ]
        },
        "codeWithBlank": "ReadOnlySpan<char> text = \"Hello\";\nvar index = text.IndexOf(________);\nif (index >= 0)\n{\n    var found = text[index];\n}",
        "prompt": "`ReadOnlySpan<char>` da 'l' harfini qidirish uchun parametrni yozing.",
        "answer": "ReadOnlySpan<char> text = \"Hello\";\nvar index = text.IndexOf('l');\nif (index >= 0)\n{\n    var found = text[index];\n}",
        "explanation": "IndexOf() metodi char parameter qabul qiladi. Single quotes bilan character literal 'l' ishlatiladi."
    },
    {
        "id": 81,
        "type": "error_spotting",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "memory types",
            "concepts": [
                "memory-types",
                "span",
                "list-operations",
                "memory-safety"
            ],
            "difficulty": "murakkab",
            "csharpVersion": "7.2",
            "estimatedTimeSeconds": 120,
            "prerequisites": [
                "span-memory",
                "collections",
                "memory-safety"
            ],
            "learningObjectives": [
                "List<T> internal array invalidation risks",
                "Span<T> lifetime vs collection modification",
                "CollectionsMarshal safe usage patterns"
            ],
            "commonMistakes": [
                "List modification after span creation xavfli ekanligini bilmaslik",
                "List.AsSpan() mavjud deb o'ylash"
            ],
            "relatedQuestions": [
                49,
                54,
                60,
                61,
                67,
                70,
                78,
                84,
                90,
                94
            ],
            "tags": [
                "memory-safety",
                "span-invalidation",
                "list-modification",
                "dangerous-pattern"
            ]
        },
        "codeWithError": "var list = new List<int> { 1, 2, 3, 4, 5 };\nvar span = list.AsSpan();\nlist.Add(6);\nConsole.WriteLine(span.Length);",
        "prompt": "`List<T>` ga element qo'shgandan so'ng `Span<T>` ishlatishda xatolik bor. Xatoni toping va tushuntiring.",
        "answer": "var list = new List<int> { 1, 2, 3, 4, 5 };\nvar span = CollectionsMarshal.AsSpan(list);\n// list.Add(6); // Bu dangerous - span invalid bo'ladi\nConsole.WriteLine(span.Length);",
        "explanation": "List ga element qo'shish internal array ni reallocate qilishi mumkin, span invalid bo'ladi. CollectionsMarshal ishlatib, list ni modify qilmaslik kerak."
    },
    {
        "id": 82,
        "type": "error_spotting",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "dictionary",
            "concepts": [
                "basic-collections",
                "dictionary",
                "nullable-types",
                "duplicate-keys"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "8.0",
            "estimatedTimeSeconds": 100,
            "prerequisites": [
                "collections",
                "nullable-reference-types"
            ],
            "learningObjectives": [
                "Dictionary duplicate key exception handling",
                "Null key support va constraints",
                "Add vs indexer assignment farqi"
            ],
            "commonMistakes": [
                "Duplicate null key Add() qilsa exception bo'lmasligini o'ylash",
                "Add() va indexer[] assignment farqini bilmaslik"
            ],
            "relatedQuestions": [
                47,
                56,
                72,
                91
            ],
            "tags": [
                "null-key",
                "duplicate-key-exception",
                "add-vs-indexer",
                "nullable-dictionary"
            ]
        },
        "codeWithError": "var dict = new Dictionary<string?, int>();\ndict.Add(null, 1);\ndict.Add(null, 2);\nConsole.WriteLine(dict.Count);",
        "prompt": "`Dictionary` da `null` key bilan bog'liq xatolikni toping va to'g'rilang.",
        "answer": "var dict = new Dictionary<string?, int>();\ndict.Add(null, 1);\n// dict.Add(null, 2); // Exception - duplicate key\ndict[null] = 2; // Bu to'g'ri - key ni update qiladi\nConsole.WriteLine(dict.Count);",
        "explanation": "Add() metodi duplicate key uchun exception beradi, null ham key hisoblanadi. Update uchun indexer [] ishlatiladi."
    },
    {
        "id": 83,
        "type": "error_spotting",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "indexing slicing",
            "concepts": [
                "indexing-slicing",
                "range-operator",
                "index-operator"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "8.0",
            "estimatedTimeSeconds": 90,
            "prerequisites": [
                "arrays",
                "range-operator",
                "index-operator"
            ],
            "learningObjectives": [
                "Index operator ^0 vs ^1 semantikasini tushunish",
                "Range boundary check qoidalarini bilish",
                "From-end indexing edge case larni handle qilish"
            ],
            "commonMistakes": [
                "^0 oxirgi element deb o'ylash",
                "Range boundary da off-by-one error qilish"
            ],
            "relatedQuestions": [
                48,
                52,
                58,
                59,
                64,
                73,
                89,
                92
            ],
            "tags": [
                "range-boundary-error",
                "hat-operator-confusion",
                "off-by-one",
                "index-out-of-bounds"
            ]
        },
        "codeWithError": "var numbers = new int[] { 1, 2, 3, 4, 5 };\nvar range = 2..^0;\nvar slice = numbers[range];\nConsole.WriteLine(slice.Length);",
        "prompt": "Range operatorida xatolik bor. `^0` nima anglatadi va qanday to'g'rilash kerak?",
        "answer": "var numbers = new int[] { 1, 2, 3, 4, 5 };\nvar range = 2..^1; // ^0 is beyond end, ^1 is last element\nvar slice = numbers[range];\nConsole.WriteLine(slice.Length);",
        "explanation": "^0 array length pozitsiyasi (bounds dan tashqari). Range uchun ^1 ishlatiladi (oxirgi element, exclusive boundary)."
    },
    {
        "id": 84,
        "type": "error_spotting",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "memory types",
            "concepts": [
                "memory-types",
                "span",
                "async-support"
            ],
            "difficulty": "murakkab",
            "csharpVersion": "7.2",
            "estimatedTimeSeconds": 100,
            "prerequisites": [
                "span-memory",
                "async-await",
                "ref-structs"
            ],
            "learningObjectives": [
                "Span<T> async method limitation va ref struct constraint",
                "Memory<T> async-safe alternative usage",
                "Async method parameter type selection criteria"
            ],
            "commonMistakes": [
                "Span<T> ni async method parameter qilib ishlatish",
                "Stackalloc buffer ni async da ishlatish"
            ],
            "relatedQuestions": [
                49,
                54,
                60,
                61,
                66,
                67,
                70,
                74,
                78,
                81,
                90,
                94
            ],
            "tags": [
                "async-span-error",
                "ref-struct-limitation",
                "memory-async-safe",
                "stackalloc-async"
            ]
        },
        "codeWithError": "async Task ProcessAsync()\n{\n    Span<byte> buffer = stackalloc byte[1024];\n    await SomeAsyncMethod(buffer);\n}",
        "prompt": "`Span<T>` ni async metod ichida ishlatishdagi xatolikni toping va to'g'rilang.",
        "answer": "async Task ProcessAsync()\n{\n    Memory<byte> buffer = new byte[1024];\n    await SomeAsyncMethod(buffer);\n    // Yoki: var buffer = new byte[1024].AsMemory();\n}",
        "explanation": "Span<T> ref struct bo'lib, async metodlarda ishlatib bo'lmaydi. Memory<T> async-safe alternative hisoblanadi."
    },
    {
        "id": 85,
        "type": "error_spotting",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "queue",
            "concepts": [
                "basic-collections",
                "queue",
                "exception-handling"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "6.0",
            "estimatedTimeSeconds": 80,
            "prerequisites": [
                "collections",
                "exception-handling"
            ],
            "learningObjectives": [
                "Queue empty state exception handling",
                "Safe collection access patterns",
                "Count property validation before operations"
            ],
            "commonMistakes": [
                "Bo'sh queue dan Peek() qilsa exception bo'lishini bilmaslik",
                "Collection operation lar exception xavfsiz emasligini unutish"
            ],
            "relatedQuestions": [
                46,
                51,
                95
            ],
            "tags": [
                "empty-queue-exception",
                "safe-access-pattern",
                "count-validation",
                "peek-exception"
            ]
        },
        "codeWithError": "var queue = new Queue<int>();\nqueue.Enqueue(1);\nqueue.Enqueue(2);\nvar result = queue.Peek();\nqueue.Clear();\nvar next = queue.Peek();",
        "prompt": "Bo'sh `Queue` dan element olishdagi xatolikni toping va to'g'rilang.",
        "answer": "var queue = new Queue<int>();\nqueue.Enqueue(1);\nqueue.Enqueue(2);\nvar result = queue.Peek();\nqueue.Clear();\nvar next = queue.Count > 0 ? queue.Peek() : 0; // Check before peek",
        "explanation": "Bo'sh Queue dan Peek() InvalidOperationException beradi. Count > 0 check qilib, safe access ta'minlash kerak."
    },
    {
        "id": 86,
        "type": "error_spotting",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "collection expressions",
            "concepts": [
                "collection-expressions",
                "spread-operator"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "12.0",
            "estimatedTimeSeconds": 90,
            "prerequisites": [
                "collections"
            ],
            "learningObjectives": [
                "Collection expression da collection embedding rules",
                "Spread operator (..) zaruriyati",
                "Collection literal vs collection spread farqi"
            ],
            "commonMistakes": [
                "Collection ni literal kabi embed qilish mumkin deb o'ylash",
                "Spread operator syntax ni bilmaslik"
            ],
            "relatedQuestions": [
                68,
                77,
                97,
                99
            ],
            "tags": [
                "collection-expression-error",
                "spread-required",
                "nested-collection",
                "c12-syntax"
            ]
        },
        "codeWithError": "var numbers = new List<int> { 1, 2, 3 };\nvar combined = [numbers, 4, 5];\nConsole.WriteLine(combined.Count);",
        "prompt": "Collection expression da spread operatorisiz ishlatishdagi xatolikni toping.",
        "answer": "var numbers = new List<int> { 1, 2, 3 };\nvar combined = [..numbers, 4, 5]; // Need spread operator\nConsole.WriteLine(combined.Count);",
        "explanation": "Collection expression da existing collection ni spread qilmasdan embed qilib bo'lmaydi. [..numbers, 4, 5] syntax kerak."
    },
    {
        "id": 87,
        "type": "error_spotting",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "memory types",
            "concepts": [
                "memory-types",
                "readonly-span",
                "immutability"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "7.2",
            "estimatedTimeSeconds": 80,
            "prerequisites": [
                "span-memory",
                "readonly-types"
            ],
            "learningObjectives": [
                "ReadOnlySpan<T> immutability constraints",
                "Readonly vs mutable type selection",
                "Span type usage patterns"
            ],
            "commonMistakes": [
                "ReadOnlySpan element larni o'zgartirish mumkin deb o'ylash",
                "Readonly types modification attempt"
            ],
            "relatedQuestions": [
                49,
                54,
                60,
                61,
                66,
                67,
                70,
                74,
                78,
                80,
                84,
                94
            ],
            "tags": [
                "readonly-violation",
                "immutable-span",
                "type-mismatch",
                "const-correctness"
            ]
        },
        "codeWithError": "ReadOnlySpan<int> span = new int[] { 1, 2, 3 };\nspan[0] = 10;\nConsole.WriteLine(span[0]);",
        "prompt": "`ReadOnlySpan<T>` da elementni o'zgartirishdagi xatolikni toping.",
        "answer": "Span<int> span = new int[] { 1, 2, 3 }; // Use Span<T> instead\nspan[0] = 10;\nConsole.WriteLine(span[0]);",
        "explanation": "ReadOnlySpan<T> immutable - elementlarni o'zgartirib bo'lmaydi. Mutable operation uchun Span<T> ishlatiladi."
    },
    {
        "id": 88,
        "type": "error_spotting",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "stack",
            "concepts": [
                "basic-collections",
                "stack",
                "lifo-ordering"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "6.0",
            "estimatedTimeSeconds": 90,
            "prerequisites": [
                "collections",
                "data-structures"
            ],
            "learningObjectives": [
                "Stack<T>.ToArray() LIFO ordering preservation",
                "Stack internal structure va enumeration",
                "Collection conversion behaviors"
            ],
            "commonMistakes": [
                "ToArray() stack order ni teskari qiladi deb o'ylash",
                "LIFO ordering ni FIFO deb fikrlash"
            ],
            "relatedQuestions": [
                46,
                51,
                96
            ],
            "tags": [
                "stack-ordering",
                "toarray-behavior",
                "lifo-preservation",
                "element-order"
            ]
        },
        "codeWithError": "var stack = new Stack<string>();\nstack.Push(\"first\");\nstack.Push(\"second\");\nvar items = stack.ToArray();\nConsole.WriteLine(items[0]);",
        "prompt": "`Stack<T>.ToArray()` metodining natijasida elementlar tartibini to'g'ri tushuntiring.",
        "answer": "var stack = new Stack<string>();\nstack.Push(\"first\");\nstack.Push(\"second\");\nvar items = stack.ToArray();\n// items[0] is \"second\" (LIFO order)\nConsole.WriteLine(items[0]); // Prints \"second\"",
        "explanation": "ToArray() LIFO tartibni saqlaydi: oxirgi push qilingan element array ning birinchi elementi bo'ladi."
    },
    {
        "id": 89,
        "type": "error_spotting",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "indexing slicing",
            "concepts": [
                "indexing-slicing",
                "range-operator",
                "string-slicing"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "8.0",
            "estimatedTimeSeconds": 100,
            "prerequisites": [
                "arrays",
                "strings",
                "range-operator"
            ],
            "learningObjectives": [
                "String length va range boundary calculation",
                "Range end boundary behavior",
                "String slicing edge cases"
            ],
            "commonMistakes": [
                "Range boundary calculation da xato",
                "String uzunligi va index relationship ni bilmaslik"
            ],
            "relatedQuestions": [
                48,
                52,
                58,
                59,
                64,
                73,
                83,
                92
            ],
            "tags": [
                "string-range-error",
                "boundary-calculation",
                "slice-bounds",
                "range-semantics"
            ]
        },
        "codeWithError": "var text = \"Hello World\";\nvar slice = text[5..^5];\nConsole.WriteLine(slice);",
        "prompt": "String slicing da index va range xatoligini toping va to'g'rilang.",
        "answer": "var text = \"Hello World\";\nvar slice = text[6..^0]; // Start from 6 (space after Hello), go to end\n// Or: var slice = text[6..]; for \"World\"\nConsole.WriteLine(slice);",
        "explanation": "\"Hello World\" uzunligi 11. [5..^5] = [5..6] = \" \" (faqat space). \"World\" uchun [6..] kerak."
    },
    {
        "id": 90,
        "type": "error_spotting",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "memory types",
            "concepts": [
                "memory-types",
                "memory",
                "initialization"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "7.2",
            "estimatedTimeSeconds": 90,
            "prerequisites": [
                "span-memory",
                "constructors"
            ],
            "learningObjectives": [
                "Memory<T> default constructor behavior",
                "Empty Memory<T> vs initialized Memory<T>",
                "Memory initialization patterns"
            ],
            "commonMistakes": [
                "Default Memory<T> constructor bilan memory allocate bo'ladi deb o'ylash",
                "Bo'sh Memory dan Span olish xavfsiz deb fikrlash"
            ],
            "relatedQuestions": [
                49,
                54,
                60,
                61,
                66,
                67,
                70,
                74,
                78,
                81,
                84,
                94
            ],
            "tags": [
                "memory-initialization",
                "default-constructor",
                "empty-memory",
                "memory-allocation"
            ]
        },
        "codeWithError": "var memory = new Memory<int>();\nvar span = memory.Span;\nspan[0] = 42;\nConsole.WriteLine(span[0]);",
        "prompt": "Bo'sh `Memory<T>` dan `Span<T>` olish va ishlatishdagi xatolikni toping.",
        "answer": "var memory = new Memory<int>(new int[10]); // Initialize with array\nvar span = memory.Span;\nspan[0] = 42;\nConsole.WriteLine(span[0]);",
        "explanation": "Default Memory<T>() constructor bo'sh memory yaratadi. Array bilan initialize qilish kerak: new Memory<int>(new int[10])."
    },
    {
        "id": 91,
        "type": "output_prediction",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "dictionary",
            "concepts": [
                "basic-collections",
                "dictionary",
                "safe-operations"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "6.0",
            "estimatedTimeSeconds": 80,
            "prerequisites": [
                "collections"
            ],
            "learningObjectives": [
                "Dictionary.TryAdd() conditional addition behavior",
                "Existing key handling bilan TryAdd semantics",
                "Safe dictionary modification patterns"
            ],
            "commonMistakes": [
                "TryAdd mavjud key ni update qiladi deb o'ylash",
                "TryAdd return value ni ignore qilish"
            ],
            "relatedQuestions": [
                47,
                56,
                72,
                82
            ],
            "tags": [
                "tryadd-behavior",
                "conditional-addition",
                "existing-key-skip",
                "safe-modification"
            ]
        },
        "snippet": "var dict = new Dictionary<int, string> { [1] = \"one\", [2] = \"two\" };\ndict.TryAdd(1, \"ONE\");\ndict.TryAdd(3, \"three\");\nConsole.WriteLine($\"{dict[1]}, {dict.Count}\");",
        "prompt": "`Dictionary.TryAdd()` metodi mavjud key uchun qanday ishlaydi?",
        "answer": "one, 3",
        "explanation": "TryAdd mavjud key (1) ni update qilmaydi, faqat yangi key (3) ni qo'shadi. dict[1] = \"one\" qoladi, Count = 3."
    },
    {
        "id": 92,
        "type": "output_prediction",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "indexing slicing",
            "concepts": [
                "indexing-slicing",
                "range-operator"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "8.0",
            "estimatedTimeSeconds": 90,
            "prerequisites": [
                "arrays",
                "range-operator"
            ],
            "learningObjectives": [
                "Range operator length calculation",
                "Multiple range operations comparison",
                "Array slicing mathematics"
            ],
            "commonMistakes": [
                "Range length calculation da xato",
                "From-end indexing boundary confusion"
            ],
            "relatedQuestions": [
                48,
                52,
                58,
                59,
                64,
                73,
                83,
                89
            ],
            "tags": [
                "range-length",
                "slice-comparison",
                "multiple-ranges",
                "boundary-math"
            ]
        },
        "snippet": "var numbers = new int[] { 10, 20, 30, 40, 50 };\nvar slice1 = numbers[1..4];\nvar slice2 = numbers[^3..^1];\nConsole.WriteLine($\"{slice1.Length}, {slice2.Length}\");",
        "prompt": "Range operatorlari bilan slice olishda uzunliklar qanday bo'ladi?",
        "answer": "3, 2",
        "explanation": "slice1[1..4] = {20,30,40} (length=3), slice2[^3..^1] = {30,40} (index 2..4, length=2)."
    },
    {
        "id": 93,
        "type": "output_prediction",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "set operations",
            "concepts": [
                "basic-collections",
                "hashset",
                "list"
            ],
            "difficulty": "boshlang'ich",
            "csharpVersion": "6.0",
            "estimatedTimeSeconds": 70,
            "prerequisites": [
                "collections"
            ],
            "learningObjectives": [
                "HashSet vs List duplicate handling",
                "Set uniqueness constraint vs list allowDuplicates",
                "Collection type behavior comparison"
            ],
            "commonMistakes": [
                "HashSet duplicate qabul qiladi deb o'ylash",
                "List uniqueness kafolatlaydi deb fikrlash"
            ],
            "relatedQuestions": [
                50,
                76
            ],
            "tags": [
                "hashset-unique",
                "list-duplicates",
                "collection-comparison",
                "uniqueness-behavior"
            ]
        },
        "snippet": "var hashSet = new HashSet<int> { 1, 2, 3, 1, 2 };\nConsole.WriteLine(hashSet.Count);\nvar list = new List<int> { 1, 2, 3, 1, 2 };\nConsole.WriteLine(list.Count);",
        "prompt": "`HashSet` va `List` da duplicate elementlar qanday ishlanadi?",
        "answer": "3\n5",
        "explanation": "HashSet faqat unique elementlarni saqlaydi (Count=3), List barcha elementlarni saqlaydi including duplicates (Count=5)."
    },
    {
        "id": 94,
        "type": "output_prediction",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "memory types",
            "concepts": [
                "memory-types",
                "span",
                "span-operations"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "7.2",
            "estimatedTimeSeconds": 80,
            "prerequisites": [
                "span-memory",
                "stackalloc"
            ],
            "learningObjectives": [
                "Span<T>.Reverse() in-place modification",
                "Stack allocated array manipulation",
                "Span operation results va array conversion"
            ],
            "commonMistakes": [
                "Reverse() yangi array yaratadi deb o'ylash",
                "In-place modification ni tushunmaslik"
            ],
            "relatedQuestions": [
                49,
                54,
                60,
                61,
                66,
                67,
                70,
                74,
                78,
                81,
                84,
                87,
                90
            ],
            "tags": [
                "span-reverse",
                "in-place-modification",
                "stackalloc-manipulation",
                "span-to-array"
            ]
        },
        "snippet": "Span<int> span = stackalloc int[3] { 1, 2, 3 };\nspan.Reverse();\nvar array = span.ToArray();\nConsole.WriteLine(string.Join(\", \", array));",
        "prompt": "`Span<T>.Reverse()` metodining natijasi qanday bo'ladi?",
        "answer": "3, 2, 1",
        "explanation": "Reverse() span ni in-place reverse qiladi: {1,2,3} → {3,2,1}. ToArray() reversed contentni array ga convert qiladi."
    },
    {
        "id": 95,
        "type": "output_prediction",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "queue",
            "concepts": [
                "basic-collections",
                "queue",
                "fifo-ordering"
            ],
            "difficulty": "boshlang'ich",
            "csharpVersion": "6.0",
            "estimatedTimeSeconds": 70,
            "prerequisites": [
                "collections"
            ],
            "learningObjectives": [
                "Queue<T> FIFO (First In, First Out) principle",
                "Enqueue/Dequeue operation ordering",
                "Queue vs Stack ordering difference"
            ],
            "commonMistakes": [
                "Queue LIFO tartibida ishlaydi deb o'ylash",
                "Enqueue/Dequeue ordering ni bilmaslik"
            ],
            "relatedQuestions": [
                46,
                51,
                85,
                96
            ],
            "tags": [
                "fifo-ordering",
                "queue-sequence",
                "enqueue-dequeue",
                "first-in-first-out"
            ]
        },
        "snippet": "var queue = new Queue<char>();\nforeach (char c in \"ABC\")\n    queue.Enqueue(c);\nwhile (queue.Count > 0)\n    Console.Write(queue.Dequeue());",
        "prompt": "`Queue<T>` FIFO tartibda elementlarni qanday chiqaradi?",
        "answer": "ABC",
        "explanation": "Queue FIFO: birinchi kiritilgan (A) birinchi chiqadi. Enqueue order: A→B→C, Dequeue order: A→B→C."
    },
    {
        "id": 96,
        "type": "output_prediction",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "stack",
            "concepts": [
                "basic-collections",
                "stack",
                "lifo-ordering"
            ],
            "difficulty": "boshlang'ich",
            "csharpVersion": "6.0",
            "estimatedTimeSeconds": 70,
            "prerequisites": [
                "collections"
            ],
            "learningObjectives": [
                "Stack<T> LIFO (Last In, First Out) principle",
                "Push/Pop operation ordering",
                "Stack vs Queue ordering difference"
            ],
            "commonMistakes": [
                "Stack FIFO tartibida ishlaydi deb o'ylash",
                "Push/Pop ordering ni Queue bilan aralashtirib yuborish"
            ],
            "relatedQuestions": [
                46,
                51,
                88,
                95
            ],
            "tags": [
                "lifo-ordering",
                "stack-sequence",
                "push-pop",
                "last-in-first-out"
            ]
        },
        "snippet": "var stack = new Stack<char>();\nforeach (char c in \"ABC\")\n    stack.Push(c);\nwhile (stack.Count > 0)\n    Console.Write(stack.Pop());",
        "prompt": "`Stack<T>` LIFO tartibda elementlarni qanday chiqaradi?",
        "answer": "CBA",
        "explanation": "Stack LIFO: oxirgi kiritilgan (C) birinchi chiqadi. Push order: A→B→C, Pop order: C→B→A."
    },
    {
        "id": 97,
        "type": "output_prediction",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "collection expressions",
            "concepts": [
                "collection-expressions",
                "spread-operator"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "12.0",
            "estimatedTimeSeconds": 80,
            "prerequisites": [
                "collections"
            ],
            "learningObjectives": [
                "Collection expression complex spread combinations",
                "Multiple spread operators va literal mixing",
                "Collection concatenation order preservation"
            ],
            "commonMistakes": [
                "Spread order ni noto'g'ri tushunish",
                "Collection expression evaluation order confusion"
            ],
            "relatedQuestions": [
                68,
                77,
                86,
                99
            ],
            "tags": [
                "complex-spread",
                "mixed-literal-spread",
                "concatenation-order",
                "c12-advanced"
            ]
        },
        "snippet": "var list1 = new List<int> { 1, 2 };\nvar list2 = new List<int> { 3, 4 };\nvar combined = [..list1, 5, ..list2];\nConsole.WriteLine(string.Join(\", \", combined));",
        "prompt": "Collection expression da spread operator qanday ishlaydi?",
        "answer": "1, 2, 5, 3, 4",
        "explanation": "Collection expression left-to-right evaluate: ..list1 (1,2), then 5, then ..list2 (3,4) = [1,2,5,3,4]."
    },
    {
        "id": 98,
        "type": "output_prediction",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "priority queue",
            "concepts": [
                "advanced-collections",
                "priority-queue",
                "min-heap"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "11.0",
            "estimatedTimeSeconds": 80,
            "prerequisites": [
                "collections",
                "priority-concepts"
            ],
            "learningObjectives": [
                "PriorityQueue min-heap dequeue behavior",
                "Priority comparison va element selection",
                "Min-heap property va element extraction"
            ],
            "commonMistakes": [
                "Max-heap deb o'ylash (katta priority birinchi)",
                "String comparison priority bilan aralashtirib yuborish"
            ],
            "relatedQuestions": [
                55,
                75
            ],
            "tags": [
                "min-heap-dequeue",
                "priority-comparison",
                "lowest-priority-first",
                "heap-extraction"
            ]
        },
        "snippet": "var priorityQueue = new PriorityQueue<string, int>();\npriorityQueue.Enqueue(\"C\", 3);\npriorityQueue.Enqueue(\"A\", 1);\npriorityQueue.Enqueue(\"B\", 2);\nConsole.WriteLine(priorityQueue.Dequeue());",
        "prompt": "`PriorityQueue` eng kichik priority ni birinchi chiqaradi. Natija nima?",
        "answer": "A",
        "explanation": "PriorityQueue min-heap: eng kichik priority (1) birinchi chiqadi. \"A\" ning priority si 1 - eng kichik."
    },
    {
        "id": 99,
        "type": "output_prediction",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "memory types",
            "concepts": [
                "memory-types",
                "readonly-span",
                "search-operations"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "7.2",
            "estimatedTimeSeconds": 80,
            "prerequisites": [
                "span-memory",
                "char-operations"
            ],
            "learningObjectives": [
                "ReadOnlySpan<char> LastIndexOf search method",
                "String search va character indexing",
                "Span search result formatting"
            ],
            "commonMistakes": [
                "LastIndexOf birinchi occurrence qaytaradi deb o'ylash",
                "Index calculation da xato"
            ],
            "relatedQuestions": [
                49,
                54,
                60,
                61,
                66,
                67,
                70,
                74,
                78,
                80,
                84,
                87,
                90,
                94
            ],
            "tags": [
                "lastindexof-search",
                "char-search",
                "span-indexing",
                "search-result"
            ]
        },
        "snippet": "ReadOnlySpan<char> text = \"Hello World\";\nvar index = text.LastIndexOf('l');\nConsole.WriteLine($\"{index}, {text[index]}\");",
        "prompt": "`ReadOnlySpan<char>` da oxirgi 'l' harfining indexi va qiymati?",
        "answer": "9, l",
        "explanation": "\"Hello World\" da 'l' lar: index 2, 3, 9. LastIndexOf() oxirgi occurrence (index 9) ni qaytaradi."
    },
    {
        "id": 100,
        "type": "output_prediction",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "memory types",
            "concepts": [
                "memory-types",
                "memory",
                "span",
                "string-slicing"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "7.2",
            "estimatedTimeSeconds": 90,
            "prerequisites": [
                "span-memory",
                "strings"
            ],
            "learningObjectives": [
                "String to Memory<char> conversion",
                "Memory to Span conversion va slicing",
                "Span string operations va result formatting"
            ],
            "commonMistakes": [
                "Memory va Span conversion sequence ni bilmaslik",
                "String slicing range calculation xatosi"
            ],
            "relatedQuestions": [
                49,
                54,
                60,
                61,
                66,
                67,
                70,
                74,
                78,
                80,
                84,
                87,
                90,
                94,
                99
            ],
            "tags": [
                "string-to-memory",
                "memory-to-span",
                "span-slicing",
                "string-operations"
            ]
        },
        "snippet": "var memory = \"Hello\".AsMemory();\nvar span = memory.Span;\nvar slice = span[1..^1];\nConsole.WriteLine(slice.ToString());",
        "prompt": "String dan `Memory<T>` va `Span<T>` orqali slice olishda natija?",
        "answer": "ell",
        "explanation": "\"Hello\" → Memory → Span → slice[1..^1] = [1..4] = \"ell\" (index 1 dan 4 gacha, oxirgi char ni exclude qilib)."
    },
    {
        "id": 101,
        "type": "code_writing",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "system design",
            "concepts": [
                "generic-programming",
                "multi-collection-management",
                "constraints"
            ],
            "difficulty": "murakkab",
            "csharpVersion": "6.0",
            "estimatedTimeSeconds": 600,
            "prerequisites": [
                "generics",
                "collections",
                "interfaces",
                "constraints"
            ],
            "learningObjectives": [
                "Generic class design va constraint usage",
                "Multiple collection type coordination",
                "IEquatable<T> constraint practical application",
                "Collection synchronization patterns"
            ],
            "commonMistakes": [
                "Collection lar orasida sinxronizatsiya yo'qligi",
                "Generic constraint larni noto'g'ri qo'llash",
                "Collection type specific behavior ni bilmaslik"
            ],
            "relatedQuestions": [
                46,
                47,
                50,
                51,
                104
            ],
            "tags": [
                "multi-collection",
                "generic-constraints",
                "collection-coordinator",
                "system-architecture"
            ]
        },
        "prompt": "### Generic Collection Manager\n\n`CollectionManager<T>` generic klassi yarating. Bu klass quyidagi collectionlarni boshqarsin:\n- `List<T>` - asosiy saqlash uchun\n- `HashSet<T>` - unique elementlar uchun\n- `Queue<T>` - FIFO operatsiyalar uchun\n\nMetodlar:\n- `AddItem(T item)` - barcha collectionlarga qo'shadi\n- `RemoveItem(T item)` - barcha collectionlardan olib tashlaydi\n- `GetUniqueCount()` - unique elementlar sonini qaytaradi\n- `GetNextInQueue()` - queue dan keyingi elementni oladi\n\n`where T : IEquatable<T>` constraint ishlating.",
        "examples": [
            "var manager = new CollectionManager<int>();\nmanager.AddItem(1);\nmanager.AddItem(1); // duplicate\nConsole.WriteLine(manager.GetUniqueCount()); // 1"
        ]
    },
    {
        "id": 102,
        "type": "code_writing",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "array operations",
            "concepts": [
                "indexing-slicing",
                "range-operator",
                "index-operator",
                "array-processing"
            ],
            "difficulty": "murakkab",
            "csharpVersion": "8.0",
            "estimatedTimeSeconds": 480,
            "prerequisites": [
                "arrays",
                "generics",
                "range-operator",
                "index-operator"
            ],
            "learningObjectives": [
                "Range va Index operator advanced usage",
                "Generic array processing methods",
                "Array slicing algorithms implementation",
                "Static utility class design patterns"
            ],
            "commonMistakes": [
                "Range boundary calculation xatolari",
                "Array bounds checking ni unutish",
                "Generic array method signature xatolari"
            ],
            "relatedQuestions": [
                48,
                52,
                58,
                59,
                64,
                73,
                83,
                89,
                92
            ],
            "tags": [
                "array-slicing",
                "range-index-operations",
                "generic-algorithms",
                "utility-class"
            ]
        },
        "prompt": "### Array Slicer with Range/Index\n\n`ArraySlicer` static klassi yarating. Quyidagi metodlarni implement qiling:\n- `GetSlice<T>(T[] array, Range range)` - Range operatori bilan slice oladi\n- `GetFromEnd<T>(T[] array, Index index)` - Oxiridan sanab index oladi\n- `GetMiddle<T>(T[] array)` - O'rtadagi elementlar (1/4 dan 3/4 gacha)\n- `SplitArray<T>(T[] array, int parts)` - Arrayni teng qismlarga bo'ladi\n\nHar bir metod appropriate range/index operatorlarini ishlating.",
        "examples": [
            "var numbers = new[] { 1, 2, 3, 4, 5, 6, 7, 8 };\nvar middle = ArraySlicer.GetMiddle(numbers); // { 3, 4, 5, 6 }\nvar fromEnd = ArraySlicer.GetFromEnd(numbers, ^2); // 7"
        ]
    },
    {
        "id": 103,
        "type": "code_writing",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "memory management",
            "concepts": [
                "memory-types",
                "span",
                "memory",
                "performance-optimization"
            ],
            "difficulty": "murakkab",
            "csharpVersion": "7.2",
            "estimatedTimeSeconds": 720,
            "prerequisites": [
                "span-memory",
                "generics",
                "delegates",
                "performance"
            ],
            "learningObjectives": [
                "Memory<T> va Span<T> advanced patterns",
                "High-performance buffer processing",
                "Memory-efficient algorithm design",
                "Zero-allocation programming techniques"
            ],
            "commonMistakes": [
                "Memory va Span lifetime management xatolari",
                "Performance optimization da premature optimization",
                "Async va Span compatibility muammolari"
            ],
            "relatedQuestions": [
                49,
                54,
                60,
                61,
                66,
                67,
                70,
                74,
                78,
                81,
                84,
                87,
                90,
                94
            ],
            "tags": [
                "buffer-processing",
                "memory-optimization",
                "zero-allocation",
                "high-performance"
            ]
        },
        "prompt": "### Memory-Efficient Buffer Processor\n\n`BufferProcessor` klassi yarating. Katta massivlar bilan ishlash uchun `Memory<T>` va `Span<T>` dan foydalaning:\n\n- `ProcessChunks<T>(Memory<T> memory, int chunkSize, Action<Span<T>> processor)`\n- `FindPattern<T>(ReadOnlyMemory<T> memory, ReadOnlySpan<T> pattern) where T : IEquatable<T>`\n- `ReverseInPlace<T>(Memory<T> memory)`\n- `CopyWithTransform<T>(ReadOnlyMemory<T> source, Memory<T> destination, Func<T, T> transform)`\n\nStackalloc va heap allocation ni optimal tarzda ishlating.",
        "examples": [
            "var data = new int[1000].AsMemory();\nprocessor.ProcessChunks(data, 100, chunk => {\n    // Process each 100-element chunk\n});"
        ]
    },
    {
        "id": 104,
        "type": "code_writing",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "data storage systems",
            "concepts": [
                "advanced-collections",
                "multi-storage",
                "temporal-data",
                "priority-processing"
            ],
            "difficulty": "juda-murakkab",
            "csharpVersion": "11.0",
            "estimatedTimeSeconds": 900,
            "prerequisites": [
                "collections",
                "generics",
                "datetime",
                "priority-queue",
                "dictionary"
            ],
            "learningObjectives": [
                "Complex data storage architecture design",
                "Multiple collection type integration",
                "Temporal data management patterns",
                "Priority-based processing systems"
            ],
            "commonMistakes": [
                "Collection lar orasida data inconsistency",
                "DateTime range query optimization yo'qligi",
                "Priority queue semantics noto'g'ri implementatsiya"
            ],
            "relatedQuestions": [
                47,
                55,
                63,
                69,
                75,
                79,
                91,
                98,
                101
            ],
            "tags": [
                "data-architecture",
                "temporal-storage",
                "priority-system",
                "multi-index"
            ]
        },
        "prompt": "### Multi-Collection Data Store\n\n`DataStore<T>` klassi yarating, quyidagilarni implement qiling:\n- `Dictionary<string, T>` - key-value storage\n- `SortedDictionary<DateTime, T>` - chronological storage\n- `PriorityQueue<T, int>` - priority-based processing\n\nMetodlar:\n- `Store(string key, T value, int priority = 0)`\n- `GetByKey(string key)` - dictionary dan\n- `GetByTimeRange(DateTime start, DateTime end)` - time range bo'yicha\n- `ProcessNext()` - priority queue dan\n- `GetStatistics()` - har bir collection bo'yicha ma'lumot\n\nTurli collection typelarining xususiyatlarini to'g'ri ishlating.",
        "examples": [
            "var store = new DataStore<string>();\nstore.Store(\"task1\", \"Important task\", priority: 1);\nstore.Store(\"task2\", \"Urgent task\", priority: 10);\nvar next = store.ProcessNext(); // \"Important task\" (lower priority first)"
        ]
    },
    {
        "id": 105,
        "type": "code_writing",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "modern collection features",
            "concepts": [
                "collection-expressions",
                "spread-operator",
                "performance-optimization"
            ],
            "difficulty": "murakkab",
            "csharpVersion": "12.0",
            "estimatedTimeSeconds": 540,
            "prerequisites": [
                "collections",
                "generics",
                "delegates",
                "c12-features"
            ],
            "learningObjectives": [
                "C# 12 collection expressions mastery",
                "Advanced spread operator techniques",
                "Modern collection composition patterns",
                "Performance-optimized collection operations"
            ],
            "commonMistakes": [
                "Collection expression syntax xatolari",
                "Performance optimization da unnecessary allocations",
                "IEnumerable lazy evaluation issues"
            ],
            "relatedQuestions": [
                68,
                77,
                86,
                97,
                99
            ],
            "tags": [
                "c12-features",
                "collection-builder",
                "spread-advanced",
                "modern-syntax",
                "performance"
            ]
        },
        "prompt": "### Collection Expression Builder\n\nC# 12 collection expressions va spread operator ishlatib `CollectionBuilder` static klassi yarating:\n\n- `Combine<T>(params IEnumerable<T>[] collections)` - spread bilan birlashtirishc\n- `Interleave<T>(IEnumerable<T> first, IEnumerable<T> second)` - elementlarni navbatma-navbat\n- `CreateRange(int start, int count, int step = 1)` - arithmetic progression\n- `FilterAndCombine<T>(Func<T, bool> predicate, params IEnumerable<T>[] collections)`\n\nCollection expressions `[..]` sintaksisini ishlatib, performance optimized bo'lsin.",
        "examples": [
            "var list1 = [1, 2, 3];\nvar list2 = [4, 5, 6];\nvar combined = CollectionBuilder.Combine(list1, list2); // [1, 2, 3, 4, 5, 6]\nvar range = CollectionBuilder.CreateRange(0, 5, 2); // [0, 2, 4, 6, 8]"
        ]
    },
    {
        "id": 106,
        "type": "mcq",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "basic linq operations",
            "concepts": [
                "linq-chains",
                "where",
                "select",
                "sum"
            ],
            "difficulty": "boshlang'ich",
            "csharpVersion": "6.0",
            "estimatedTimeSeconds": 90,
            "prerequisites": [
                "collections",
                "linq-basics"
            ],
            "learningObjectives": [
                "LINQ method chaining basic patterns",
                "Where() filtering operations",
                "Select() transformation operations",
                "Aggregate functions (Sum) usage"
            ],
            "commonMistakes": [
                "LINQ chain tartibini adashtirib yuborish",
                "Math calculation da xatolik qilish",
                "Filtering va transformation aralashtirib yuborish"
            ],
            "relatedQuestions": [
                116,
                126,
                131
            ],
            "tags": [
                "method-chaining",
                "filtering",
                "transformation",
                "aggregation"
            ]
        },
        "codeBefore": "```csharp\nvar numbers = new[] { 1, 2, 3, 4, 5, 6 };\nvar result = numbers\n    .Where(x => x % 2 == 0)\n    .Select(x => x * x)\n    .Sum();\n```",
        "codeAfter": "",
        "prompt": "LINQ chain operatsiyalari: juft sonlarni tanlab, kvadratga ko'tarib, yig'indisini hisoblamoqda. `result` nima bo'ladi?",
        "options": [
            {
                "id": "A",
                "option": "`56` - (2² + 4² + 6² = 4 + 16 + 36)",
                "explanation": "To'g'ri! Even numbers: 2,4,6 → squares: 4,16,36 → sum: 56"
            },
            {
                "id": "B",
                "option": "`36` - faqat 6²",
                "explanation": "Noto'g'ri! Faqat bitta element emas, barcha juft sonlar"
            },
            {
                "id": "C",
                "option": "`91` - barcha sonlarning kvadrati yig'indisi",
                "explanation": "Noto'g'ri! Where() filtering qo'llangan, faqat juft sonlar"
            },
            {
                "id": "D",
                "option": "`12` - juft sonlar yig'indisi",
                "explanation": "Noto'g'ri! Select() kvadratga ko'tarib, keyin Sum()"
            }
        ],
        "answer": [
            "A"
        ],
        "explanation": "Where(x => x % 2 == 0): [2,4,6] → Select(x => x * x): [4,16,36] → Sum(): 56"
    },
    {
        "id": 107,
        "type": "mcq",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "grouping operations",
            "concepts": [
                "groupby",
                "todictionary",
                "anonymous-types"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "6.0",
            "estimatedTimeSeconds": 120,
            "prerequisites": [
                "linq-basics",
                "anonymous-types",
                "grouping"
            ],
            "learningObjectives": [
                "GroupBy() operations va key selector functions",
                "ToDictionary() conversion patterns",
                "Anonymous type property access",
                "Group aggregation methods (Count)"
            ],
            "commonMistakes": [
                "GroupBy key selector logic xatosi",
                "Anonymous type field access sintaksi",
                "Dictionary key-value mapping confusion"
            ],
            "relatedQuestions": [
                117,
                131,
                132
            ],
            "tags": [
                "grouping",
                "conditional-grouping",
                "aggregation",
                "dictionary-conversion"
            ]
        },
        "codeBefore": "```csharp\nvar students = new[]\n{\n    new { Name = \"Ali\", Grade = 85 },\n    new { Name = \"Bobur\", Grade = 92 },\n    new { Name = \"Zara\", Grade = 78 }\n};\nvar result = students\n    .GroupBy(s => s.Grade >= 80 ? \"High\" : \"Low\")\n    .ToDictionary(g => g.Key, g => g.Count());\n```",
        "codeAfter": "",
        "prompt": "Students ni grade bo'yicha grouping qilib, har guruhda nechta student borligini hisoblamoqda. `result` nima?",
        "options": [
            {
                "id": "A",
                "option": "`{ \"High\": 2, \"Low\": 1 }` - 80+ va 80- bo'yicha guruhlash",
                "explanation": "To'g'ri! Ali(85)≥80, Bobur(92)≥80 → High:2, Zara(78)<80 → Low:1"
            },
            {
                "id": "B",
                "option": "`{ \"High\": 1, \"Low\": 2 }` - teskari hisoblash",
                "explanation": "Noto'g'ri! Grade calculation yoki counting logic xatosi"
            },
            {
                "id": "C",
                "option": "`{ \"85\": 1, \"92\": 1, \"78\": 1 }` - har grade bo'yicha",
                "explanation": "Noto'g'ri! Grouping key \"High\"/\"Low\" string, grade value emas"
            },
            {
                "id": "D",
                "option": "Exception - anonymous type bilan muammo",
                "explanation": "Noto'g'ri! Anonymous type va LINQ to'g'ri ishlaydi"
            }
        ],
        "answer": [
            "A"
        ],
        "explanation": "GroupBy key: Grade≥80 ? \"High\" : \"Low\" → Ali,Bobur: High(2), Zara: Low(1)"
    },
    {
        "id": 108,
        "type": "mcq",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "set operations",
            "concepts": [
                "union",
                "intersect",
                "set-theory",
                "orderby"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "6.0",
            "estimatedTimeSeconds": 100,
            "prerequisites": [
                "linq-basics",
                "set-operations"
            ],
            "learningObjectives": [
                "Union() set operation semantics",
                "Intersect() common elements identification",
                "Set operation uniqueness properties",
                "OrderBy() impact on result counting"
            ],
            "commonMistakes": [
                "Union duplicate counting qiladi deb o'ylash",
                "Intersect operation logikasini bilmaslik",
                "OrderBy result ni collection size ni o'zgartiradi deb fikrlash"
            ],
            "relatedQuestions": [
                126,
                130,
                133
            ],
            "tags": [
                "set-operations",
                "union-intersect",
                "uniqueness",
                "collection-math"
            ]
        },
        "codeBefore": "```csharp\nvar list1 = new[] { 1, 2, 3, 4 };\nvar list2 = new[] { 3, 4, 5, 6 };\nvar union = list1.Union(list2).OrderBy(x => x);\nvar intersect = list1.Intersect(list2);\nConsole.WriteLine($\"{union.Count()}, {intersect.Count()}\");\n```",
        "codeAfter": "",
        "prompt": "Set operatsiyalari: `Union` barcha unique elementlar, `Intersect` umumiy elementlar. Natija?",
        "options": [
            {
                "id": "A",
                "option": "`6, 2` - union: {1,2,3,4,5,6}, intersect: {3,4}",
                "explanation": "To'g'ri! Union unique: 6 ta, Intersect common: 2 ta (3,4)"
            },
            {
                "id": "B",
                "option": "`8, 4` - barcha elementlar va duplicate",
                "explanation": "Noto'g'ri! Union duplicate larni olib tashlaydi"
            },
            {
                "id": "C",
                "option": "`4, 2` - faqat birinchi array",
                "explanation": "Noto'g'ri! Union ikkala array dan elementlar oladi"
            },
            {
                "id": "D",
                "option": "`6, 0` - intersection yo'q",
                "explanation": "Noto'g'ri! 3 va 4 umumiy elementlar"
            }
        ],
        "answer": [
            "A"
        ],
        "explanation": "Union: {1,2,3,4,5,6} unique = 6 elements, Intersect: {3,4} common = 2 elements"
    },
    {
        "id": 109,
        "type": "mcq",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "sorting operations",
            "concepts": [
                "multi-level-sorting",
                "orderbydescending",
                "thenby",
                "first"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "6.0",
            "estimatedTimeSeconds": 120,
            "prerequisites": [
                "linq-basics",
                "sorting",
                "string-operations"
            ],
            "learningObjectives": [
                "Multi-level sorting with OrderBy/ThenBy",
                "OrderByDescending primary sort criteria",
                "ThenBy secondary sort criteria",
                "First() element selection after sorting"
            ],
            "commonMistakes": [
                "Sorting priority tartibini adashtirib yuborish",
                "String length vs alphabetical sorting aralashtirib yuborish",
                "Where() filtering natijasini hisobga olmaslik"
            ],
            "relatedQuestions": [
                119,
                132,
                134
            ],
            "tags": [
                "multi-sort",
                "string-sorting",
                "length-sorting",
                "alphabetical-sort"
            ]
        },
        "codeBefore": "```csharp\nvar data = new[] { \"apple\", \"banana\", \"apricot\", \"cherry\" };\nvar result = data\n    .Where(x => x.StartsWith(\"a\"))\n    .OrderByDescending(x => x.Length)\n    .ThenBy(x => x)\n    .First();\n```",
        "codeAfter": "",
        "prompt": "Multi-level sorting: avval uzunlik bo'yicha kamayish, keyin alfavit bo'yicha o'sish. Birinchi element?",
        "options": [
            {
                "id": "A",
                "option": "`\"apricot\"` - eng uzun 'a' bilan boshlanuvchi",
                "explanation": "To'g'ri! 'a' words: apple(5), apricot(7) → by length desc: apricot first"
            },
            {
                "id": "B",
                "option": "`\"apple\"` - alfabetik jihatdan birinchi",
                "explanation": "Noto'g'ri! Primary sort - length desc, apricot(7) > apple(5)"
            },
            {
                "id": "C",
                "option": "`\"banana\"` - eng uzun",
                "explanation": "Noto'g'ri! banana 'a' bilan boshlanmaydi, Where() da filter"
            },
            {
                "id": "D",
                "option": "Exception - 'a' bilan boshlanuvchi yo'q",
                "explanation": "Noto'g'ri! apple va apricot 'a' bilan boshlanadi"
            }
        ],
        "answer": [
            "A"
        ],
        "explanation": "Where('a'): [apple,apricot] → OrderByDescending(length): apricot(7), apple(5) → First(): apricot"
    },
    {
        "id": 110,
        "type": "mcq",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "query syntax",
            "concepts": [
                "query-syntax",
                "let-keyword",
                "deferred-execution",
                "take"
            ],
            "difficulty": "murakkab",
            "csharpVersion": "6.0",
            "estimatedTimeSeconds": 150,
            "prerequisites": [
                "linq-basics",
                "query-syntax",
                "enumerable-range"
            ],
            "learningObjectives": [
                "LINQ query syntax vs method syntax",
                "Let keyword intermediate calculations",
                "Deferred execution behavior understanding",
                "Take() limiting results before aggregation"
            ],
            "commonMistakes": [
                "Let variable scope va usage",
                "Query execution order confusion",
                "Take() position in pipeline ta'sirini bilmaslik"
            ],
            "relatedQuestions": [
                121,
                126,
                134
            ],
            "tags": [
                "query-syntax",
                "let-clause",
                "deferred-execution",
                "enumerable-range"
            ]
        },
        "codeBefore": "```csharp\nvar query = from n in Enumerable.Range(1, 10)\n            let square = n * n\n            where square % 2 == 0\n            select new { Number = n, Square = square };\nvar result = query.Take(3).Sum(x => x.Square);\n```",
        "codeAfter": "",
        "prompt": "Query syntax: `let` keyword va deferred execution. Birinchi 3 ta juft kvadratning yig'indisi?",
        "options": [
            {
                "id": "A",
                "option": "`56` - (4 + 16 + 36 from 2², 4², 6²)",
                "explanation": "To'g'ri! Even squares: 4(2²), 16(4²), 36(6²) → Take(3) → Sum: 56"
            },
            {
                "id": "B",
                "option": "`30` - (1² + 2² + 3² ning jufti)",
                "explanation": "Noto'g'ri! Birinchi 3 ta raqam emas, birinchi 3 ta juft kvadrat"
            },
            {
                "id": "C",
                "option": "`20` - (2 + 4 + 6)²",
                "explanation": "Noto'g'ri! Square sum emas, sum of squares"
            },
            {
                "id": "D",
                "option": "`84` - barcha juft kvadratlar",
                "explanation": "Noto'g'ri! Take(3) faqat birinchi 3 ta elementni oladi"
            }
        ],
        "answer": [
            "A"
        ],
        "explanation": "Range(1,10) → let square → where even squares: [4,16,36,64,100] → Take(3): [4,16,36] → Sum: 56"
    },
    {
        "id": 111,
        "type": "true_false",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "operation semantics",
            "concepts": [
                "operation-order",
                "where",
                "select",
                "performance"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "6.0",
            "estimatedTimeSeconds": 80,
            "prerequisites": [
                "linq-basics",
                "performance-concepts"
            ],
            "learningObjectives": [
                "LINQ operation order semantics",
                "Where() filtering impact on subsequent operations",
                "Select() transformation timing",
                "Performance implications of operation ordering"
            ],
            "commonMistakes": [
                "Operation order result ga ta'sir qilmaydi deb o'ylash",
                "Where va Select commutative deb fikrlash",
                "Performance impact ni hisobga olmaslik"
            ],
            "relatedQuestions": [
                116,
                134,
                125
            ],
            "tags": [
                "operation-order",
                "non-commutative",
                "performance-impact",
                "pipeline-semantics"
            ]
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "LINQ da `Where().Select()` chain `Select().Where()` bilan bir xil natija beradi, faqat performance farq qilishi mumkin.",
        "answer": "false",
        "explanation": "Yolg'on. Where() va Select() commutative emas. Where(condition).Select(transform) ≠ Select(transform).Where(condition) chunki condition original value lar uchun, transform uchun emas."
    },
    {
        "id": 112,
        "type": "true_false",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "execution behavior",
            "concepts": [
                "deferred-execution",
                "ienumerable",
                "lazy-evaluation"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "6.0",
            "estimatedTimeSeconds": 90,
            "prerequisites": [
                "linq-basics",
                "ienumerable"
            ],
            "learningObjectives": [
                "Deferred execution concept va benefits",
                "IEnumerable<T> lazy evaluation behavior",
                "When LINQ queries actually execute",
                "Materialization methods (ToList, ToArray, etc.)"
            ],
            "commonMistakes": [
                "LINQ query yaratilganda darhol execute bo'ladi deb o'ylash",
                "Deferred execution side effects ni bilmaslik",
                "Multiple enumeration issues"
            ],
            "relatedQuestions": [
                121,
                123,
                134
            ],
            "tags": [
                "deferred-execution",
                "lazy-evaluation",
                "query-materialization",
                "execution-timing"
            ]
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "`IEnumerable<T>` da LINQ operatsiyalari deferred execution qo'llaydi, ya'ni `ToList()` chaqirilgunga qadar execute bo'lmaydi.",
        "answer": "true",
        "explanation": "To'g'ri. LINQ operatsiyalari deferred (lazy) execution ishlatadi. Query definition vaqtida execute bo'lmaydi, balki enumeration (ToList, foreach, Count) paytida execute bo'ladi."
    },
    {
        "id": 113,
        "type": "true_false",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "grouping operations",
            "concepts": [
                "groupby",
                "igrouping",
                "return-types"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "6.0",
            "estimatedTimeSeconds": 80,
            "prerequisites": [
                "linq-basics",
                "grouping",
                "interfaces"
            ],
            "learningObjectives": [
                "GroupBy() return type understanding",
                "IGrouping<TKey, TElement> interface structure",
                "Group key va element access patterns",
                "Nested enumerable result handling"
            ],
            "commonMistakes": [
                "GroupBy natija structure ni bilmaslik",
                "IGrouping interface usage",
                "Key access va element enumeration aralashtirib yuborish"
            ],
            "relatedQuestions": [
                107,
                117,
                131
            ],
            "tags": [
                "groupby-return-type",
                "igrouping-interface",
                "nested-enumerable",
                "group-structure"
            ]
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "`GroupBy()` metodi natijasi `IGrouping<TKey, TElement>` tipidagi elementlardan iborat `IEnumerable` qaytaradi.",
        "answer": "true",
        "explanation": "To'g'ri. GroupBy() natijasi IEnumerable<IGrouping<TKey, TElement>> qaytaradi. Har bir IGrouping bir group ni represents qiladi va Key property va elements ga access beradi."
    },
    {
        "id": 114,
        "type": "true_false",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "element selection",
            "concepts": [
                "first",
                "firstordefault",
                "exception-handling"
            ],
            "difficulty": "boshlang'ich",
            "csharpVersion": "6.0",
            "estimatedTimeSeconds": 70,
            "prerequisites": [
                "linq-basics",
                "exception-handling"
            ],
            "learningObjectives": [
                "First() vs FirstOrDefault() behavior difference",
                "Exception handling vs default value patterns",
                "Safe collection access methods",
                "When to use each method appropriately"
            ],
            "commonMistakes": [
                "Bo'sh collection da First() exception bermasligini o'ylash",
                "Default value behavior ni bilmaslik",
                "Predicate overload lar farqini bilmaslik"
            ],
            "relatedQuestions": [
                119,
                122,
                125
            ],
            "tags": [
                "first-methods",
                "exception-vs-default",
                "safe-access",
                "element-selection"
            ]
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "`First()` va `FirstOrDefault()` farqi shundaki, birinchisi exception beradi, ikkinchisi default qiymat qaytaradi.",
        "answer": "true",
        "explanation": "To'g'ri. First() bo'sh collection yoki condition match qilmaydigan holda InvalidOperationException beradi. FirstOrDefault() default(T) qaytaradi."
    },
    {
        "id": 115,
        "type": "true_false",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "provider support",
            "concepts": [
                "query-syntax",
                "ienumerable",
                "iqueryable",
                "provider-support"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "6.0",
            "estimatedTimeSeconds": 90,
            "prerequisites": [
                "linq-basics",
                "iqueryable",
                "entity-framework"
            ],
            "learningObjectives": [
                "LINQ query syntax provider independence",
                "IEnumerable vs IQueryable compatibility",
                "LINQ to Objects vs LINQ to SQL/EF",
                "Query translation capabilities"
            ],
            "commonMistakes": [
                "Query syntax faqat IEnumerable uchun deb o'ylash",
                "IQueryable provider support ni bilmaslik",
                "LINQ to SQL/EF query syntax restriction lar"
            ],
            "relatedQuestions": [
                133,
                134
            ],
            "tags": [
                "query-syntax-support",
                "provider-independence",
                "iqueryable-compatibility",
                "linq-providers"
            ]
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "LINQ query syntax faqat `IEnumerable<T>` bilan ishlaydi, `IQueryable<T>` bilan ishlatib bo'lmaydi.",
        "answer": "false",
        "explanation": "Yolg'on. LINQ query syntax IQueryable<T> bilan ham ishlaydi. Bu LINQ to SQL, Entity Framework va boshqa query provider lar uchun juda muhim."
    },
    {
        "id": 116,
        "type": "fill",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "basic linq chain",
            "concepts": [
                "where",
                "select",
                "toarray",
                "method-chain"
            ],
            "difficulty": "boshlang'ich",
            "csharpVersion": "6.0",
            "estimatedTimeSeconds": 80,
            "prerequisites": [
                "linq-basics",
                "lambda-expressions"
            ],
            "learningObjectives": [
                "Basic LINQ method chaining pattern",
                "Where() filtering method usage",
                "Select() transformation method usage",
                "ToArray() materialization method"
            ],
            "commonMistakes": [
                "Method nomini to'g'ri yozmaslik",
                "Lambda expression syntax xatosi",
                "Materialization method ni unutish"
            ],
            "relatedQuestions": [
                106,
                121,
                126
            ],
            "tags": [
                "basic-chain",
                "filter-transform",
                "materialization",
                "lambda-syntax"
            ]
        },
        "codeWithBlank": "var numbers = new[] { 1, 2, 3, 4, 5 };\nvar result = numbers\n    .________(x => x > 2)\n    .________(x => x * 2)\n    .________();\n// Result should be [6, 8, 10]",
        "prompt": "LINQ chain: 2 dan katta sonlarni filterlash, 2 ga ko'paytirish, array ga aylantirish.",
        "answer": "var numbers = new[] { 1, 2, 3, 4, 5 };\nvar result = numbers\n    .Where(x => x > 2)\n    .Select(x => x * 2)\n    .ToArray();\n// Result should be [6, 8, 10]",
        "explanation": "Where(filtering) → Select(transformation) → ToArray(materialization) chain pattern."
    },
    {
        "id": 117,
        "type": "fill",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "grouping and aggregation",
            "concepts": [
                "groupby",
                "todictionary",
                "count",
                "aggregation"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "6.0",
            "estimatedTimeSeconds": 120,
            "prerequisites": [
                "linq-basics",
                "grouping",
                "dictionary"
            ],
            "learningObjectives": [
                "GroupBy() method with key selector",
                "ToDictionary() method with value selector",
                "Count() aggregation method usage",
                "Group key va value transformation"
            ],
            "commonMistakes": [
                "GroupBy key selector sintaksisi",
                "ToDictionary parameter order xatosi",
                "Count vs Count() method aralashtirib yuborish"
            ],
            "relatedQuestions": [
                107,
                113,
                131
            ],
            "tags": [
                "grouping",
                "aggregation",
                "dictionary-creation",
                "count-operation"
            ]
        },
        "codeWithBlank": "var words = new[] { \"hello\", \"world\", \"linq\", \"query\" };\nvar grouped = words\n    .________(w => w.Length)\n    .________(g => g.Key, g => g.______());\n// Group by length, then create dictionary with counts",
        "prompt": "So'zlarni uzunlik bo'yicha guruhlab, har guruhda nechta element borligini dictionary sifatida qaytaring.",
        "answer": "var words = new[] { \"hello\", \"world\", \"linq\", \"query\" };\nvar grouped = words\n    .GroupBy(w => w.Length)\n    .ToDictionary(g => g.Key, g => g.Count());\n// Group by length, then create dictionary with counts",
        "explanation": "GroupBy(length) creates groups → ToDictionary(key, count) creates Dictionary<int, int>."
    },
    {
        "id": 118,
        "type": "fill",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "pagination and filtering",
            "concepts": [
                "skip",
                "take",
                "where",
                "sum",
                "pagination"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "6.0",
            "estimatedTimeSeconds": 100,
            "prerequisites": [
                "linq-basics",
                "enumerable-range",
                "pagination"
            ],
            "learningObjectives": [
                "Skip() method for pagination",
                "Take() method for limiting results",
                "Where() filtering after pagination",
                "Sum() aggregation method"
            ],
            "commonMistakes": [
                "Skip/Take order ni adashtirib yuborish",
                "Pagination va filtering order importance",
                "Sum() vs Count() aralashtirib yuborish"
            ],
            "relatedQuestions": [
                110,
                129,
                134
            ],
            "tags": [
                "pagination",
                "skip-take",
                "filtering",
                "aggregation"
            ]
        },
        "codeWithBlank": "var source = Enumerable.Range(1, 100);\nvar result = source\n    .________(10)        // Skip first 10\n    .________(5)         // Take next 5\n    .________(x => x % 2 == 1)  // Only odd numbers\n    .Sum();",
        "prompt": "Pagination va filtering: birinchi 10 tani o'tkazib yuborish, keyingi 5 tani olish, faqat toqlarini yig'ish.",
        "answer": "var source = Enumerable.Range(1, 100);\nvar result = source\n    .Skip(10)        // Skip first 10\n    .Take(5)         // Take next 5\n    .Where(x => x % 2 == 1)  // Only odd numbers\n    .Sum();",
        "explanation": "Skip(10) → Take(5) → Where(odd) → Sum(): pagination keyin filtering, oxirida aggregation."
    },
    {
        "id": 119,
        "type": "fill",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "quantifier methods",
            "concepts": [
                "any",
                "all",
                "quantifiers",
                "boolean-logic"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "6.0",
            "estimatedTimeSeconds": 100,
            "prerequisites": [
                "linq-basics",
                "boolean-logic",
                "quantifiers"
            ],
            "learningObjectives": [
                "Any() quantifier method usage",
                "All() quantifier method usage",
                "Boolean logic in LINQ queries",
                "Predicate expressions with quantifiers"
            ],
            "commonMistakes": [
                "Any vs All semantics aralashtirib yuborish",
                "Quantifier method variable assignment",
                "Boolean result handling"
            ],
            "relatedQuestions": [
                114,
                125,
                133
            ],
            "tags": [
                "quantifiers",
                "any-all",
                "boolean-logic",
                "predicate-evaluation"
            ]
        },
        "codeWithBlank": "var people = new[]\n{\n    new { Name = \"Ali\", Age = 25 },\n    new { Name = \"Sara\", Age = 30 }\n};\nvar result = people\n    .________(p => p.Age > 20)\n    .________(p => ________);\n// Check if any person older than 20, then check if all are older than 18",
        "prompt": "Quantifier methods: biror kishi 20 yoshdan katta bo'lsa, barcha kishilar 18 dan katta ekanligini tekshiring.",
        "answer": "var people = new[]\n{\n    new { Name = \"Ali\", Age = 25 },\n    new { Name = \"Sara\", Age = 30 }\n};\nvar hasOlder = people.Any(p => p.Age > 20);\nvar allAdults = people.All(p => p.Age > 18);\n// Check if any person older than 20, then check if all are older than 18",
        "explanation": "Any(condition) checks existence, All(condition) checks universal truth. Separate variables for clarity."
    },
    {
        "id": 120,
        "type": "fill",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "join operations",
            "concepts": [
                "groupjoin",
                "left-join",
                "count",
                "anonymous-types"
            ],
            "difficulty": "murakkab",
            "csharpVersion": "6.0",
            "estimatedTimeSeconds": 180,
            "prerequisites": [
                "linq-basics",
                "joins",
                "anonymous-types"
            ],
            "learningObjectives": [
                "GroupJoin() method advanced usage",
                "Left join semantics in LINQ",
                "Key selector functions in joins",
                "Result selector with anonymous types"
            ],
            "commonMistakes": [
                "GroupJoin vs Join farqini bilmaslik",
                "Key selector parameter order",
                "Result selector lambda syntax",
                "Count() method grouping da"
            ],
            "relatedQuestions": [
                133,
                134
            ],
            "tags": [
                "group-join",
                "left-join",
                "key-selectors",
                "result-projection"
            ]
        },
        "codeWithBlank": "var customers = new[] { \"Alice\", \"Bob\", \"Charlie\" };\nvar orders = new[] { \"Alice\", \"Alice\", \"Bob\", \"David\" };\nvar result = customers\n    .________(orders, c => c, o => o, (c, orderGroup) => \n        new { Customer = c, OrderCount = orderGroup.________ });\n// Group join to count orders per customer",
        "prompt": "Group join: har bir customer uchun order sonini hisoblash. Ba'zi customerlarning orderi yo'q bo'lishi mumkin.",
        "answer": "var customers = new[] { \"Alice\", \"Bob\", \"Charlie\" };\nvar orders = new[] { \"Alice\", \"Alice\", \"Bob\", \"David\" };\nvar result = customers\n    .GroupJoin(orders, c => c, o => o, (c, orderGroup) => \n        new { Customer = c, OrderCount = orderGroup.Count() });\n// Group join to count orders per customer",
        "explanation": "GroupJoin() creates left join with grouped results. Count() calculates orders per customer, including zero."
    },
    {
        "id": 121,
        "type": "error_spotting",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "deferred execution",
            "concepts": [
                "deferred-execution",
                "lazy-evaluation",
                "query-semantics"
            ],
            "difficulty": "murakkab",
            "csharpVersion": "6.0",
            "estimatedTimeSeconds": 150,
            "prerequisites": [
                "linq-basics",
                "deferred-execution",
                "enumeration"
            ],
            "learningObjectives": [
                "Deferred execution timing understanding",
                "Query definition vs execution timing",
                "Source data modification effects",
                "When materialization occurs"
            ],
            "commonMistakes": [
                "Query yaratilganda darhol execute bo'ladi deb o'ylash",
                "Source data changes timing ni bilmaslik",
                "Materialization moment ni noto'g'ri tushunish"
            ],
            "relatedQuestions": [
                112,
                123,
                134
            ],
            "tags": [
                "deferred-execution",
                "lazy-evaluation",
                "source-modification",
                "timing-issues"
            ]
        },
        "codeWithError": "var numbers = new[] { 1, 2, 3, 4, 5 };\nvar query = numbers.Where(x => x > 2);\nnumbers[0] = 10;\nvar result = query.ToList();\nConsole.WriteLine(result.Count);",
        "prompt": "Deferred execution muammosi: query yaratilgandan keyin source data o'zgardi. Natija qanday bo'ladi?",
        "answer": "var numbers = new[] { 1, 2, 3, 4, 5 };\nvar query = numbers.Where(x => x > 2);\n// query hali execute bo'lmagan (deferred)\nnumbers[0] = 10;  // source data o'zgardi\nvar result = query.ToList();  // endi execute bo'ladi: [10, 3, 4, 5]\nConsole.WriteLine(result.Count);  // 4",
        "explanation": "Deferred execution: query creation vaqtida execute bo'lmaydi, ToList() chaqirilganda execute bo'ladi va o'zgartrilgan source data ishlatiladi."
    },
    {
        "id": 122,
        "type": "error_spotting",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "pipeline correctness",
            "concepts": [
                "select",
                "where",
                "first",
                "pipeline-validation"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "6.0",
            "estimatedTimeSeconds": 100,
            "prerequisites": [
                "linq-basics",
                "method-chaining",
                "logical-reasoning"
            ],
            "learningObjectives": [
                "LINQ pipeline logical validation",
                "Select() transformation result verification",
                "Where() condition result analysis",
                "First() method result prediction"
            ],
            "commonMistakes": [
                "Pipeline natijasini mental calculation qilishda xato",
                "Transformation va filtering order ta'sirini bilmaslik",
                "Expected result vs actual result difference"
            ],
            "relatedQuestions": [
                106,
                111,
                116
            ],
            "tags": [
                "pipeline-validation",
                "logical-correctness",
                "result-verification",
                "no-error"
            ]
        },
        "codeWithError": "var data = new[] { 1, 2, 3 };\nvar result = data\n    .Select(x => x * 2)\n    .Where(x => x > 3)\n    .First();\n// Should get first element > 3 after doubling",
        "prompt": "LINQ chain mantiqan to'g'ri, lekin qiymatlarni tekshirib ko'ring. 4 dan katta birinchi element topiladi?",
        "answer": "var data = new[] { 1, 2, 3 };\nvar result = data\n    .Select(x => x * 2)    // [2, 4, 6]\n    .Where(x => x > 3)     // [4, 6]\n    .First();              // 4\n// Natija: 4 (to'g'ri ishlaydi)",
        "explanation": "Bu 'trick question' - kod aslida to'g'ri ishlaydi. Select(x2): [2,4,6] → Where(>3): [4,6] → First(): 4."
    },
    {
        "id": 123,
        "type": "error_spotting",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "enumeration safety",
            "concepts": [
                "collection-modification",
                "enumeration",
                "concurrency-issues"
            ],
            "difficulty": "murakkab",
            "csharpVersion": "6.0",
            "estimatedTimeSeconds": 140,
            "prerequisites": [
                "linq-basics",
                "collections",
                "enumeration-safety"
            ],
            "learningObjectives": [
                "Collection modification during enumeration risks",
                "Safe collection modification patterns",
                "Materialization for safe operations",
                "foreach enumeration behavior understanding"
            ],
            "commonMistakes": [
                "Source collection ni enumeration paytida o'zgartirish",
                "InvalidOperationException ni kutmaslik",
                "Materialization necessity ni bilmaslik"
            ],
            "relatedQuestions": [
                112,
                121,
                134
            ],
            "tags": [
                "enumeration-safety",
                "collection-modification",
                "materialization",
                "concurrent-modification"
            ]
        },
        "codeWithError": "var items = new List<int> { 1, 2, 3, 4, 5 };\nforeach (var item in items.Where(x => x % 2 == 0))\n{\n    items.Remove(item);\n}\nConsole.WriteLine(items.Count);",
        "prompt": "Collection modification during enumeration xatosi. LINQ query execute bo'layotganda source collection o'zgartirilmoqda.",
        "answer": "var items = new List<int> { 1, 2, 3, 4, 5 };\n// To'g'ri yondashuv: avval natijani materialize qiling\nvar toRemove = items.Where(x => x % 2 == 0).ToList();\nforeach (var item in toRemove)\n{\n    items.Remove(item);\n}\nConsole.WriteLine(items.Count);",
        "explanation": "Collection modification during enumeration InvalidOperationException beradi. Avval ToList() qilib materialize qilish kerak."
    },
    {
        "id": 124,
        "type": "error_spotting",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "element selection",
            "concepts": [
                "single",
                "groupby",
                "cardinality",
                "exception-handling"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "6.0",
            "estimatedTimeSeconds": 120,
            "prerequisites": [
                "linq-basics",
                "grouping",
                "element-selection"
            ],
            "learningObjectives": [
                "Single() method preconditions",
                "GroupBy() result cardinality analysis",
                "Element selection method appropriate usage",
                "Exception scenarios in LINQ"
            ],
            "commonMistakes": [
                "Single() exactly one element requirement",
                "GroupBy result count ni noto'g'ri baholash",
                "Element selection method choice xatosi"
            ],
            "relatedQuestions": [
                107,
                113,
                114
            ],
            "tags": [
                "single-method",
                "cardinality-error",
                "groupby-count",
                "exception-prone"
            ]
        },
        "codeWithError": "var numbers = new[] { 1, 2, 3 };\nvar result = numbers\n    .GroupBy(x => x % 2)\n    .Select(g => g.Sum())\n    .Single();",
        "prompt": "`Single()` method faqat bitta element bo'lgan collection uchun ishlatiladi. Bu yerda nechta group bor?",
        "answer": "var numbers = new[] { 1, 2, 3 };\nvar result = numbers\n    .GroupBy(x => x % 2)    // 2 ta group: {0: [2], 1: [1,3]}\n    .Select(g => g.Sum())   // [2, 4]\n    .ToArray();             // Single() o'rniga ToArray() yoki First()/Last()\n// Single() exception beradi chunki 2 ta element bor",
        "explanation": "GroupBy(x % 2) 2 ta group yaratadi (even va odd). Single() faqat 1 ta element kutadi, 2 ta bo'lgani uchun exception beradi."
    },
    {
        "id": 125,
        "type": "error_spotting",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "null safety",
            "concepts": [
                "null-safety",
                "null-reference",
                "where",
                "safe-navigation"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "6.0",
            "estimatedTimeSeconds": 100,
            "prerequisites": [
                "linq-basics",
                "null-handling",
                "exception-handling"
            ],
            "learningObjectives": [
                "Null reference exception prevention",
                "Safe null checking patterns",
                "Null-conditional operator usage",
                "Where() predicate null safety"
            ],
            "commonMistakes": [
                "Null values bilan property access",
                "Null checking ni unutish",
                "Safe navigation operator ni bilmaslik"
            ],
            "relatedQuestions": [
                114,
                119,
                133
            ],
            "tags": [
                "null-safety",
                "null-reference-exception",
                "safe-navigation",
                "defensive-programming"
            ]
        },
        "codeWithError": "var words = new[] { \"apple\", \"banana\", null, \"cherry\" };\nvar result = words\n    .Where(w => w.Length > 5)\n    .Count();",
        "prompt": "Null reference exception: array da `null` element bor va `Length` property access qilinmoqda.",
        "answer": "var words = new[] { \"apple\", \"banana\", null, \"cherry\" };\nvar result = words\n    .Where(w => w != null && w.Length > 5)  // Null check kerak\n    .Count();\n// Yoki: .Where(w => w?.Length > 5)",
        "explanation": "Null element da Length property access NullReferenceException beradi. Null check yoki safe navigation operator kerak."
    },
    {
        "id": 126,
        "type": "output_prediction",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "selectmany operations",
            "concepts": [
                "selectmany",
                "enumerable-repeat",
                "flattening",
                "sum"
            ],
            "difficulty": "murakkab",
            "csharpVersion": "6.0",
            "estimatedTimeSeconds": 150,
            "prerequisites": [
                "linq-basics",
                "selectmany",
                "enumerable-methods"
            ],
            "learningObjectives": [
                "SelectMany() flattening behavior",
                "Enumerable.Repeat() usage patterns",
                "Complex LINQ chain calculation",
                "Aggregation after flattening"
            ],
            "commonMistakes": [
                "SelectMany flattening logic ni bilmaslik",
                "Enumerable.Repeat behavior confusion",
                "Manual calculation xatolari"
            ],
            "relatedQuestions": [
                106,
                130,
                135
            ],
            "tags": [
                "selectmany",
                "flattening",
                "enumerable-repeat",
                "complex-calculation"
            ]
        },
        "snippet": "var numbers = new[] { 1, 2, 3, 4, 5 };\nvar result = numbers\n    .SelectMany(x => Enumerable.Repeat(x, x))\n    .Sum();\nConsole.WriteLine(result);",
        "prompt": "`SelectMany` har raqamni o'sha raqam marta takrorlaydi. Masalan, 3 ni 3 marta: [3,3,3]. Yig'indi?",
        "answer": "30",
        "explanation": "1→[1], 2→[2,2], 3→[3,3,3], 4→[4,4,4,4], 5→[5,5,5,5,5] flatten→[1,2,2,3,3,3,4,4,4,4,5,5,5,5,5] Sum=30"
    },
    {
        "id": 127,
        "type": "output_prediction",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "character analysis",
            "concepts": [
                "where",
                "groupby",
                "orderbydescending",
                "first",
                "char-operations"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "6.0",
            "estimatedTimeSeconds": 120,
            "prerequisites": [
                "linq-basics",
                "grouping",
                "char-methods"
            ],
            "learningObjectives": [
                "String LINQ operations",
                "Character classification methods",
                "GroupBy() with character analysis",
                "Most frequent element finding"
            ],
            "commonMistakes": [
                "Character frequency counting xatosi",
                "Space lar va punctuation ni hisobga olish",
                "GroupBy key access syntax"
            ],
            "relatedQuestions": [
                107,
                132,
                135
            ],
            "tags": [
                "string-analysis",
                "character-frequency",
                "most-common",
                "grouping"
            ]
        },
        "snippet": "var data = \"hello world\";\nvar result = data\n    .Where(c => char.IsLetter(c))\n    .GroupBy(c => c)\n    .OrderByDescending(g => g.Count())\n    .First()\n    .Key;\nConsole.WriteLine(result);",
        "prompt": "String dagi eng ko'p uchraydigan harfni topish. `hello world` da qaysi harf eng ko'p?",
        "answer": "l",
        "explanation": "\"hello world\" letters: h,e,l,l,o,w,o,r,l,d → 'l' appears 3 times (most frequent) → Key='l'"
    },
    {
        "id": 128,
        "type": "output_prediction",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "zip operations",
            "concepts": [
                "zip",
                "element-pairing",
                "lambda-operations",
                "string-join"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "6.0",
            "estimatedTimeSeconds": 100,
            "prerequisites": [
                "linq-basics",
                "zip-method",
                "lambda-expressions"
            ],
            "learningObjectives": [
                "Zip() method element pairing",
                "Binary operation lambda expressions",
                "ToArray() materialization",
                "String.Join() output formatting"
            ],
            "commonMistakes": [
                "Zip pairing logic ni bilmaslik",
                "Lambda expression syntax",
                "Result formatting confusion"
            ],
            "relatedQuestions": [
                108,
                116,
                135
            ],
            "tags": [
                "zip-operation",
                "element-pairing",
                "binary-lambda",
                "result-formatting"
            ]
        },
        "snippet": "var list1 = new[] { 1, 2, 3 };\nvar list2 = new[] { 2, 3, 4 };\nvar result = list1.Zip(list2, (a, b) => a + b).ToArray();\nConsole.WriteLine(string.Join(\", \", result));",
        "prompt": "`Zip` method ikki collection elementlarini juftlab birlashtiradi. Har juftikning yig'indisi?",
        "answer": "3, 5, 7",
        "explanation": "Zip pairs: (1,2)→3, (2,3)→5, (3,4)→7 → string.Join(\", \") → \"3, 5, 7\""
    },
    {
        "id": 129,
        "type": "output_prediction",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "conditional operations",
            "concepts": [
                "takewhile",
                "skipwhile",
                "skip",
                "concat"
            ],
            "difficulty": "murakkab",
            "csharpVersion": "6.0",
            "estimatedTimeSeconds": 180,
            "prerequisites": [
                "linq-basics",
                "conditional-methods",
                "sequence-operations"
            ],
            "learningObjectives": [
                "TakeWhile() conditional taking",
                "SkipWhile() conditional skipping",
                "Skip() fixed skipping",
                "Concat() sequence combination"
            ],
            "commonMistakes": [
                "TakeWhile vs SkipWhile semantics",
                "Skip(1) additional element skipping",
                "Complex chain logic understanding"
            ],
            "relatedQuestions": [
                118,
                134,
                135
            ],
            "tags": [
                "takewhile",
                "skipwhile",
                "element-removal",
                "sequence-manipulation"
            ]
        },
        "snippet": "var numbers = new[] { 5, 2, 8, 1, 9 };\nvar result = numbers\n    .TakeWhile(x => x != 8)\n    .Concat(numbers.SkipWhile(x => x != 8).Skip(1))\n    .ToArray();\nConsole.WriteLine(string.Join(\", \", result));",
        "prompt": "8 raqamini olib tashlash: 8 gacha olib, 8 dan keyingilarni olib, birlashtirish. Natija?",
        "answer": "5, 2, 1, 9",
        "explanation": "TakeWhile(≠8): [5,2] + SkipWhile(≠8).Skip(1): skip [5,2,8], then skip 1 more → [1,9] = [5,2,1,9]"
    },
    {
        "id": 130,
        "type": "output_prediction",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "nested flattening",
            "concepts": [
                "selectmany",
                "enumerable-range",
                "flattening",
                "sum"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "6.0",
            "estimatedTimeSeconds": 120,
            "prerequisites": [
                "linq-basics",
                "selectmany",
                "enumerable-range"
            ],
            "learningObjectives": [
                "SelectMany() nested collection flattening",
                "Enumerable.Range() understanding",
                "Nested IEnumerable processing",
                "Sum() aggregation after flattening"
            ],
            "commonMistakes": [
                "Enumerable.Range parameters confusion",
                "SelectMany flattening behavior",
                "Nested structure ni bilmaslik"
            ],
            "relatedQuestions": [
                110,
                126,
                135
            ],
            "tags": [
                "nested-flattening",
                "enumerable-range",
                "selectmany",
                "aggregation"
            ]
        },
        "snippet": "var ranges = new[] { \n    Enumerable.Range(1, 3), \n    Enumerable.Range(4, 2) \n};\nvar flattened = ranges.SelectMany(r => r).Sum();\nConsole.WriteLine(flattened);",
        "prompt": "`SelectMany` nested IEnumerable larni flatten qiladi. Range(1,3)=[1,2,3], Range(4,2)=[4,5]. Yig'indi?",
        "answer": "15",
        "explanation": "Range(1,3)→[1,2,3], Range(4,2)→[4,5] → SelectMany flatten→[1,2,3,4,5] → Sum=15"
    },
    {
        "id": 131,
        "type": "code_writing",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "data analysis projects",
            "concepts": [
                "records",
                "grouping",
                "aggregation",
                "sorting",
                "data-analysis"
            ],
            "difficulty": "juda-murakkab",
            "csharpVersion": "9.0",
            "estimatedTimeSeconds": 1200,
            "prerequisites": [
                "linq-basics",
                "records",
                "grouping",
                "aggregation",
                "console-applications"
            ],
            "learningObjectives": [
                "Real-world data analysis with LINQ",
                "Record types in data modeling",
                "Complex grouping and aggregation",
                "Deferred vs immediate execution demonstration",
                "Console application development"
            ],
            "commonMistakes": [
                "Record syntax noto'g'ri ishlatish",
                "Grouping key selector xatolari",
                "Deferred execution ni ko'rsatishda xatolik",
                "Console output formatting issues"
            ],
            "relatedQuestions": [
                106,
                107,
                117,
                132,
                133
            ],
            "tags": [
                "data-analysis",
                "student-records",
                "educational-data",
                "console-app",
                "deferred-demo"
            ]
        },
        "prompt": "### LINQ ma'lumotlar tahlili dasturi\n\nStudent ma'lumotlari bilan ishlaydigan konsol dasturini yozing.\n\n`Student` record yarating: `Name`, `Age`, `Grade`, `Subject` maydonlari bilan.\n\nQuyidagi LINQ operatsiyalarini implement qiling:\n- Barcha studentlarni grade bo'yicha guruhlab, har guruhda nechta student borligini chiqarish\n- Eng yosh va eng katta yoshdagi studentlarni topib chiqarish\n- Ma'lum subject bo'yicha o'rtacha grade ni hisoblash\n- Grade 80+ bo'lgan studentlarni name bo'yicha tartiblash\n\nDeferred execution va immediate execution farqini ko'rsating.",
        "examples": [
            "Students by grade groups:\nA: 3 students\nB: 5 students\n\nAge range: Min=18, Max=25\nMath average grade: 87.5"
        ]
    },
    {
        "id": 132,
        "type": "code_writing",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "text analysis projects",
            "concepts": [
                "string-processing",
                "selectmany",
                "groupby",
                "palindromes",
                "text-analysis"
            ],
            "difficulty": "juda-murakkab",
            "csharpVersion": "6.0",
            "estimatedTimeSeconds": 1400,
            "prerequisites": [
                "linq-basics",
                "string-operations",
                "char-methods",
                "query-syntax"
            ],
            "learningObjectives": [
                "Advanced string processing with LINQ",
                "Query syntax vs method syntax mastery",
                "Complex text analysis algorithms",
                "Palindrome detection logic",
                "Character frequency analysis"
            ],
            "commonMistakes": [
                "String splitting va word extraction",
                "Palindrome logic implementation",
                "Query syntax va method syntax mixing",
                "Character vs string operations"
            ],
            "relatedQuestions": [
                127,
                131,
                135
            ],
            "tags": [
                "text-processing",
                "palindrome-detection",
                "character-analysis",
                "dual-syntax",
                "string-algorithms"
            ]
        },
        "prompt": "### LINQ bilan matn tahlili\n\nMatn faylini tahlil qiladigan dastur yozing (yoki hardcoded string ishlating).\n\nQuyidagi funksiyalarni LINQ bilan implement qiling:\n- Eng uzun so'zni topish\n- Har harfning necha marta uchrashini hisoblash\n- Palindrom so'zlarni topish  \n- So'zlarni uzunlik bo'yicha guruhlab, har guruhdan eng kichik alfabetik tartibdagisini olish\n\nQuery syntax va method syntax ikkalasidan ham foydalaning.\n\n`SelectMany`, `GroupBy`, `OrderBy`, `Where` metodlarini ishlating.",
        "examples": [
            "Text: \"hello world level deed\"\nLongest word: world (5 letters)\nPalindromes: level, deed\nLetter 'l' appears 3 times"
        ]
    },
    {
        "id": 133,
        "type": "code_writing",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "business logic projects",
            "concepts": [
                "joins",
                "groupjoin",
                "aggregate",
                "business-logic",
                "e-commerce"
            ],
            "difficulty": "juda-murakkab",
            "csharpVersion": "9.0",
            "estimatedTimeSeconds": 1600,
            "prerequisites": [
                "linq-basics",
                "joins",
                "records",
                "null-safety",
                "business-logic"
            ],
            "learningObjectives": [
                "Complex business logic with LINQ",
                "Join operations in real scenarios",
                "GroupJoin for left joins",
                "Aggregate functions usage",
                "Null safety in data processing"
            ],
            "commonMistakes": [
                "Join key selector consistency",
                "Null value handling",
                "Date/time grouping logic",
                "Business logic validation"
            ],
            "relatedQuestions": [
                108,
                120,
                131,
                134
            ],
            "tags": [
                "e-commerce",
                "business-logic",
                "joins",
                "sales-analysis",
                "null-safety"
            ]
        },
        "prompt": "### LINQ bilan e-commerce ma'lumotlari\n\n`Product`, `Order`, `Customer` recordlarini yarating.\n\nQuyidagi business logikani LINQ bilan yozing:\n- Eng ko'p sotilgan 5 ta mahsulot\n- Har bir customer ning jami xarid summasi\n- Oylik sotuvlar statistikasi (group by month)\n- Hech narsa sotib olmagan customerlar ro'yxati\n\n`Join`, `GroupJoin`, `Aggregate`, `Sum` metodlaridan foydalaning.\n\nNull safety va edge caselarni handle qiling (bo'sh collections, null values).",
        "examples": [
            "Top products:\n1. Laptop - 15 orders\n2. Phone - 12 orders\n\nCustomer spending:\nAli: $1,250\nSara: $890"
        ]
    },
    {
        "id": 134,
        "type": "code_writing",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "performance optimization",
            "concepts": [
                "performance",
                "benchmarking",
                "stopwatch",
                "optimization",
                "deferred-execution"
            ],
            "difficulty": "juda-murakkab",
            "csharpVersion": "6.0",
            "estimatedTimeSeconds": 1800,
            "prerequisites": [
                "linq-basics",
                "performance-concepts",
                "benchmarking",
                "stopwatch"
            ],
            "learningObjectives": [
                "LINQ performance optimization techniques",
                "Benchmarking methodologies",
                "Deferred vs immediate execution impact",
                "Method selection for performance",
                "Large collection handling"
            ],
            "commonMistakes": [
                "Benchmarking setup errors",
                "Warm-up phase ni unutish",
                "Memory allocation ta'sirini bilmaslik",
                "Statistical significance issues"
            ],
            "relatedQuestions": [
                111,
                112,
                121,
                123
            ],
            "tags": [
                "performance-testing",
                "benchmarking",
                "optimization",
                "large-datasets",
                "execution-timing"
            ]
        },
        "prompt": "### LINQ Performance Comparison\n\nKatta collection lar bilan ishlash uchun performance test dasturini yozing.\n\nQuyidagilarni taqqoslang:\n- `Where().Count()` vs `Count(predicate)`\n- `Where().First()` vs `First(predicate)`  \n- `ToList().Where()` vs `Where().ToList()`\n- Deferred vs Immediate execution\n\n`Stopwatch` ishlatib, execution time ni o'lchang.\n\n1 million elementli `List<int>` yarating va turli LINQ operatsiyalarini test qiling.\n\nNatijalarni console ga formatted holda chiqaring.",
        "examples": [
            "Performance Test Results:\nWhere().Count(): 145ms\nCount(predicate): 98ms\n\nDeferred query creation: 0ms\nImmediate execution: 234ms"
        ]
    },
    {
        "id": 135,
        "type": "code_writing",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "extension methods",
            "concepts": [
                "extension-methods",
                "yield-return",
                "generic-programming",
                "deferred-execution"
            ],
            "difficulty": "juda-murakkab",
            "csharpVersion": "6.0",
            "estimatedTimeSeconds": 2000,
            "prerequisites": [
                "linq-basics",
                "extension-methods",
                "generics",
                "yield-return",
                "null-safety"
            ],
            "learningObjectives": [
                "Custom LINQ extension method creation",
                "Yield return and deferred execution",
                "Generic programming advanced patterns",
                "Null safety in extension methods",
                "Iterator pattern implementation"
            ],
            "commonMistakes": [
                "Extension method syntax xatolari",
                "Yield return vs direct return",
                "Null parameter validation",
                "Generic constraint usage"
            ],
            "relatedQuestions": [
                126,
                127,
                128,
                129,
                130
            ],
            "tags": [
                "extension-methods",
                "custom-linq",
                "yield-return",
                "iterator-pattern",
                "generic-extensions"
            ]
        },
        "prompt": "### Custom LINQ Extension Methods\n\nO'zingizning LINQ extension methodlarini yarating:\n\n- `Batch<T>(this IEnumerable<T> source, int size)` - elementlarni chunk larga bo'lish\n- `DistinctBy<T, TKey>(this IEnumerable<T> source, Func<T, TKey> keySelector)` - key bo'yicha unique\n- `ForEach<T>(this IEnumerable<T> source, Action<T> action)` - har elementga action apply qilish\n- `IsEmpty<T>(this IEnumerable<T> source)` - collection bo'sh ekanligini tekshirish\n\nHar bir extension method uchun:\n- Null checking\n- Deferred execution (kerak bo'lsa)\n- `yield return` ishlatish\n- Generic constraints (kerak bo'lsa)\n\nTest kodini ham yozing.",
        "examples": [
            "var numbers = Enumerable.Range(1, 10);\nvar batches = numbers.Batch(3).ToList();\n// Result: [[1,2,3], [4,5,6], [7,8,9], [10]]\n\nvar people = GetPeople();\nvar unique = people.DistinctBy(p => p.Email);"
        ]
    },
    {
        "id": 136,
        "type": "mcq",
        "metadata": {
            "category": "exception-handling",
            "subcategory": "try-catch basics",
            "concepts": [
                "try-catch",
                "exception-types"
            ],
            "difficulty": "boshlang'ich",
            "csharpVersion": "6.0",
            "estimatedTimeSeconds": 90,
            "prerequisites": [
                "basic-programming"
            ],
            "learningObjectives": [
                "Try-catch block strukturasini tushunish",
                "Exception turlarini farqlash",
                "Multiple catch block ishlash tartibini bilish"
            ],
            "commonMistakes": [
                "Generic exception catch qilish",
                "Catch blocklar tartibini noto'g'ri joylashtirish"
            ],
            "relatedQuestions": [
                137,
                138
            ],
            "tags": [
                "try-catch",
                "exception-hierarchy",
                "basic-exception-handling"
            ]
        },
        "codeBefore": "```csharp\ntry\n{\n    int result = int.Parse(\"abc\");\n    Console.WriteLine(result);\n}\ncatch (FormatException ex)\n{\n    Console.WriteLine(\"Format error\");\n}\ncatch (Exception ex)\n{\n    Console.WriteLine(\"General error\");\n}\n```",
        "codeAfter": "",
        "prompt": "Yuqoridagi kodda qaysi catch block ishlaydi?",
        "options": [
            {
                "id": "A",
                "option": "FormatException catch block",
                "explanation": "int.Parse(\"abc\") FormatException tashlay, bu aniq catch qilinadi"
            },
            {
                "id": "B",
                "option": "Exception catch block",
                "explanation": "FormatException aniqroq catch qilingani uchun bu ishlamaydi"
            },
            {
                "id": "C",
                "option": "Ikkala catch block ham",
                "explanation": "Faqat birinchi mos kelgan catch block ishlaydi"
            },
            {
                "id": "D",
                "option": "Hech qaysi catch block",
                "explanation": "FormatException aniq handle qilinadi"
            }
        ],
        "answer": [
            "A"
        ],
        "explanation": "int.Parse(\"abc\") FormatException tashlay, va FormatException uchun aniq catch block mavjud bo'lgani uchun u ishlatiladi."
    },
    {
        "id": 137,
        "type": "true_false",
        "metadata": {
            "category": "exception-handling",
            "subcategory": "exception best practices",
            "concepts": [
                "exception-best-practices",
                "performance"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "6.0",
            "estimatedTimeSeconds": 70,
            "prerequisites": [
                "try-catch"
            ],
            "learningObjectives": [
                "Exception handling performance ta'sirini tushunish",
                "Exception lar control flow uchun ishlatmaslik",
                "Performance best practices"
            ],
            "commonMistakes": [
                "Exception larni control flow uchun ishlatish",
                "Performance impact ni e'tiborsiz qoldirish"
            ],
            "relatedQuestions": [
                136,
                140
            ],
            "tags": [
                "performance",
                "best-practices",
                "control-flow"
            ]
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "Exception handling performance overhead yaratadi va ularni oddiy control flow uchun ishlatmaslik kerak.",
        "answer": "true",
        "explanation": "Exception lar expensive operatsiya hisoblanadi va faqat haqiqiy error holatlar uchun ishlatilishi kerak, oddiy control flow uchun emas."
    },
    {
        "id": 138,
        "type": "fill",
        "metadata": {
            "category": "exception-handling",
            "subcategory": "try-catch syntax",
            "concepts": [
                "try-catch",
                "exception-types"
            ],
            "difficulty": "boshlang'ich",
            "csharpVersion": "6.0",
            "estimatedTimeSeconds": 90,
            "prerequisites": [
                "basic-syntax"
            ],
            "learningObjectives": [
                "Try-catch syntax to'g'ri yozish",
                "Exception variable declaration",
                "Multiple catch blocks"
            ],
            "commonMistakes": [
                "Exception variable nomi unutish",
                "Catch block syntax xatolari"
            ],
            "relatedQuestions": [
                136,
                139
            ],
            "tags": [
                "try-catch-syntax",
                "exception-variable",
                "basic-structure"
            ]
        },
        "codeWithBlank": "try\n{\n    int.Parse(\"invalid\");\n}\n______ (FormatException ex)\n{\n    Console.WriteLine(\"Format error: \" + ex.Message);\n}\n______ (Exception ex)\n{\n    Console.WriteLine(\"General error: \" + ex.Message);\n}",
        "prompt": "Try-catch strukturasini to'ldiring. Exception larni catch qilish uchun kerakli kalit so'zni yozing.",
        "answer": "try\n{\n    int.Parse(\"invalid\");\n}\ncatch (FormatException ex)\n{\n    Console.WriteLine(\"Format error: \" + ex.Message);\n}\ncatch (Exception ex)\n{\n    Console.WriteLine(\"General error: \" + ex.Message);\n}",
        "explanation": "Catch kalit so'zi exception larni ushlash uchun ishlatiladi. Har bir catch block ma'lum exception turini handle qiladi."
    },
    {
        "id": 139,
        "type": "error_spotting",
        "metadata": {
            "category": "exception-handling",
            "subcategory": "catch block order",
            "concepts": [
                "try-catch",
                "exception-hierarchy"
            ],
            "difficulty": "boshlang'ich",
            "csharpVersion": "6.0",
            "estimatedTimeSeconds": 80,
            "prerequisites": [
                "inheritance",
                "try-catch"
            ],
            "learningObjectives": [
                "Catch block order importance",
                "Exception hierarchy understanding",
                "Compiler error recognition"
            ],
            "commonMistakes": [
                "Generic exception ni oldin qo'yish",
                "Exception hierarchy bilmaslik"
            ],
            "relatedQuestions": [
                136,
                140
            ],
            "tags": [
                "catch-order",
                "exception-hierarchy",
                "compiler-error"
            ]
        },
        "codeWithError": "try\n{\n    int.Parse(\"abc\");\n}\ncatch (Exception ex)  // General exception first\n{\n    Console.WriteLine(\"General error\");\n}\ncatch (FormatException ex)  // Specific exception after - ERROR!\n{\n    Console.WriteLine(\"Format error\");\n}",
        "prompt": "Catch block tartibida xato bor. Compiler error beradi. Tuzating.",
        "answer": "try\n{\n    int.Parse(\"abc\");\n}\ncatch (FormatException ex)  // Specific exception first\n{\n    Console.WriteLine(\"Format error\");\n}\ncatch (Exception ex)  // General exception after\n{\n    Console.WriteLine(\"General error\");\n}",
        "explanation": "Aniq exception turlar umumiy turlardan oldin kelishi kerak. Exception eng umumiy tur bo'lgani uchun oxirida bo'lishi kerak."
    },
    {
        "id": 140,
        "type": "output_prediction",
        "metadata": {
            "category": "exception-handling",
            "subcategory": "exception flow",
            "concepts": [
                "try-catch",
                "exception-propagation"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "6.0",
            "estimatedTimeSeconds": 100,
            "prerequisites": [
                "try-catch"
            ],
            "learningObjectives": [
                "Exception flow understanding",
                "Multiple catch blocks",
                "Exception matching order"
            ],
            "commonMistakes": [
                "Exception hierarchy bilmaslik",
                "First-match rule bilmaslik"
            ],
            "relatedQuestions": [
                136,
                139
            ],
            "tags": [
                "exception-flow",
                "catch-matching",
                "execution-order"
            ]
        },
        "snippet": "try\n{\n    throw new ArgumentNullException(\"param\");\n}\ncatch (ArgumentException ex)\n{\n    Console.Write(\"Argument\");\n}\ncatch (ArgumentNullException ex)\n{\n    Console.Write(\"Null\");\n}\ncatch (Exception ex)\n{\n    Console.Write(\"General\");\n}\nConsole.Write(\"End\");",
        "prompt": "ArgumentNullException inheritance hierarchy: Exception > SystemException > ArgumentException > ArgumentNullException. Qaysi natija?",
        "answer": "ArgumentEnd",
        "explanation": "ArgumentNullException ArgumentException dan inherit qilgani uchun birinchi ArgumentException catch ishlaydi (first-match rule). Keyin \"End\" chiqadi."
    },
    {
        "id": 141,
        "type": "mcq",
        "metadata": {
            "category": "exception-handling",
            "subcategory": "Custom Exceptions",
            "concepts": [
                "custom-exceptions",
                "exception-types"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "8.0",
            "estimatedTimeSeconds": 90,
            "learningObjectives": [
                "Custom exception meros olishni tushunish",
                "Exception ierarxiya asoslari"
            ],
            "tags": [
                "custom-exceptions",
                "inheritance",
                "exception-types"
            ]
        },
        "prompt": "C# da custom exception class yaratganda nima sodir bo'ladi?",
        "options": [
            {
                "id": "a",
                "option": "U System.Exception yoki uning subclasslaridan meros olishi kerak"
            },
            {
                "id": "b",
                "option": "U avtomatik ravishda stack trace ma'lumotlarini o'z ichiga oladi"
            },
            {
                "id": "c",
                "option": "U generic Exception handlerlar tomonidan ushlana oladi"
            },
            {
                "id": "d",
                "option": "Barchasi to'g'ri"
            }
        ],
        "answer": [
            "d"
        ],
        "explanation": "Custom exceptionlar Exception yoki uning subclasslaridan meros olishi kerak, avtomatik ravishda stack trace ma'lumotlarini o'z ichiga oladi va meros tufayli generic Exception handlerlar tomonidan ushlana oladi."
    },
    {
        "id": 142,
        "type": "true_false",
        "metadata": {
            "category": "exception-handling",
            "subcategory": "Finally Blocks",
            "concepts": [
                "finally-blocks",
                "exception-best-practices"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "8.0",
            "estimatedTimeSeconds": 60,
            "learningObjectives": [
                "Finally blok bajarilish kafolatini tushunish",
                "Exception handling oqim nazorati"
            ],
            "tags": [
                "finally",
                "execution-flow",
                "cleanup"
            ]
        },
        "prompt": "Finally blok doimo bajariladi, hatto try blokda return statement bo'lsa ham.",
        "answer": "true",
        "explanation": "Finally blok try blok qanday chiqishidan qat'i nazar bajariladi - oddiy, return orqali yoki exception orqali. U tozalash maqsadlari uchun bajarilishi kafolatlanadi."
    },
    {
        "id": 143,
        "type": "fill",
        "metadata": {
            "category": "exception-handling",
            "subcategory": "Exception Filtering",
            "concepts": [
                "exception-filtering",
                "when-clauses"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "8.0",
            "estimatedTimeSeconds": 120,
            "learningObjectives": [
                "Exception filtering sintaksisini tushunish",
                "Ilg'or catch blok foydalanish"
            ],
            "tags": [
                "when-clause",
                "filtering",
                "conditional-catch"
            ]
        },
        "codeWithBlank": "try\n{\n    // xavfli operatsiya\n}\ncatch (ArgumentException ex) _____ (ex.ParamName == \"userId\")\n{\n    // maxsus parametr exceptionni boshqarish\n}",
        "prompt": "Exception filtering uchun kerakli kalit so'zni kiriting:",
        "answer": "when",
        "explanation": "C# da exception filtering uchun 'when' kalit so'zi ishlatiladi. U catch blok bajarilishi uchun qo'shimcha shartlarni belgilash imkonini beradi."
    },
    {
        "id": 144,
        "type": "error_spotting",
        "metadata": {
            "category": "exception-handling",
            "subcategory": "Exception Re-throwing",
            "concepts": [
                "re-throwing",
                "exception-best-practices"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "8.0",
            "estimatedTimeSeconds": 90,
            "learningObjectives": [
                "Stack trace saqlanishini tushunish",
                "To'g'ri exception qayta tashlash"
            ],
            "tags": [
                "re-throwing",
                "stack-trace",
                "best-practices"
            ]
        },
        "codeWithError": "try\n{\n    SomeRiskyOperation();\n}\ncatch (Exception ex)\n{\n    LogError(ex);\n    throw ex; // Exception ni qayta tashlash\n}",
        "prompt": "Ushbu exception qayta tashlash kodida xatoni toping:",
        "answer": "Stack trace ni saqlab qolish uchun 'throw ex;' o'rniga 'throw;' ishlatish kerak",
        "explanation": "'throw ex;' ishlatish stack trace ni qayta o'rnatadi, asl call stack ma'lumotlarini yo'qotadi. Asl stack trace ni saqlab qolish uchun 'throw;' ishlatish kerak.",
        "errorLocation": {
            "line": 6,
            "column": 5
        }
    },
    {
        "id": 145,
        "type": "output_prediction",
        "metadata": {
            "category": "exception-handling",
            "subcategory": "Exception Propagation",
            "concepts": [
                "finally-blocks",
                "exception-propagation"
            ],
            "difficulty": "murakkab",
            "csharpVersion": "8.0",
            "estimatedTimeSeconds": 150,
            "learningObjectives": [
                "Nested exception handling ni tushunish",
                "Finally blok bajarilish tartibi"
            ],
            "tags": [
                "nested-blocks",
                "execution-order",
                "propagation"
            ]
        },
        "snippet": "try\n{\n    try\n    {\n        throw new ArgumentException(\"Inner\");\n    }\n    finally\n    {\n        Console.WriteLine(\"Inner finally\");\n    }\n}\ncatch (Exception ex)\n{\n    Console.WriteLine($\"Caught: {ex.Message}\");\n}\nfinally\n{\n    Console.WriteLine(\"Outer finally\");\n}",
        "prompt": "Ushbu kodning natijasi nima bo'ladi?",
        "answer": "Inner finally\nCaught: Inner\nOuter finally",
        "explanation": "Exception tashlanganida ichki finally blok birinchi bajariladi, keyin tashqi catch blok exception ni boshqaradi va nihoyat tashqi finally blok bajariladi.",
        "stepByStepExecution": [
            "ArgumentException ichki try blokda tashlanadi",
            "Ichki finally blok bajariladi: 'Inner finally' chop etiladi",
            "Exception tashqi catch blokka o'tadi",
            "Tashqi catch blok exception ni ushlaydi: 'Caught: Inner' chop etiladi",
            "Tashqi finally blok bajariladi: 'Outer finally' chop etiladi"
        ]
    },
    {
        "id": 146,
        "type": "mcq",
        "metadata": {
            "category": "exception-handling",
            "subcategory": "Exception Hierarchy",
            "concepts": [
                "exception-types",
                "try-catch"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "8.0",
            "estimatedTimeSeconds": 90,
            "learningObjectives": [
                "Exception ierarxiya tartibini tushunish",
                "Catch blok tartibini bilish"
            ],
            "tags": [
                "exception-hierarchy",
                "catch-order",
                "inheritance"
            ]
        },
        "prompt": "Quyidagi catch bloklardan qaysi biri to'g'ri tartibda joylashgan?",
        "options": [
            {
                "id": "a",
                "option": "catch (Exception) → catch (ArgumentException) → catch (ArgumentNullException)"
            },
            {
                "id": "b",
                "option": "catch (ArgumentNullException) → catch (ArgumentException) → catch (Exception)"
            },
            {
                "id": "c",
                "option": "catch (ArgumentException) → catch (Exception) → catch (ArgumentNullException)"
            },
            {
                "id": "d",
                "option": "Tartib muhim emas"
            }
        ],
        "answer": [
            "b"
        ],
        "explanation": "Catch bloklar eng maxsus (specific) dan eng umumiy (general) ga qarab tartiblanishi kerak. ArgumentNullException → ArgumentException → Exception to'g'ri tartibdir, chunki har biri keyingisining subclass'i."
    },
    {
        "id": 147,
        "type": "true_false",
        "metadata": {
            "category": "exception-handling",
            "subcategory": "Performance",
            "concepts": [
                "exception-best-practices",
                "performance"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "8.0",
            "estimatedTimeSeconds": 60,
            "learningObjectives": [
                "Exception performance ta'sirini tushunish",
                "Best practice'larni bilish"
            ],
            "tags": [
                "performance",
                "best-practices",
                "optimization"
            ]
        },
        "prompt": "Exception'lar performance jihatdan qimmat operatsiyalar bo'lib, ular odatiy flow control uchun ishlatilmasligi kerak.",
        "answer": "true",
        "explanation": "Exception'lar stack trace yaratish va call stack'ni unwinding qilish tufayli performance jihatdan qimmat. Ular faqat haqiqiy xato holatlar uchun ishlatilishi kerak, oddiy flow control uchun emas."
    },
    {
        "id": 148,
        "type": "fill",
        "metadata": {
            "category": "exception-handling",
            "subcategory": "Custom Exception Constructors",
            "concepts": [
                "custom-exceptions",
                "exception-types"
            ],
            "difficulty": "o'rta",
            "csharpVersion": "8.0",
            "estimatedTimeSeconds": 120,
            "learningObjectives": [
                "Custom exception constructor'larini tushunish",
                "Exception chaining ni bilish"
            ],
            "tags": [
                "custom-exceptions",
                "constructors",
                "inner-exceptions"
            ]
        },
        "codeWithBlank": "public class CustomException : Exception\n{\n    public CustomException(string message, Exception innerException)\n        : _____(message, innerException)\n    {\n    }\n}",
        "prompt": "Custom exception constructor'ida base class constructor'ini to'g'ri chaqiring:",
        "answer": "base",
        "explanation": "Custom exception'larda base class (Exception) constructor'ini chaqirish uchun 'base' kalit so'zi ishlatiladi. Bu message va inner exception'ni base class'ga o'tkazadi."
    },
    {
        "id": 149,
        "type": "error_spotting",
        "metadata": {
            "category": "exception-handling",
            "subcategory": "Exception Filtering Errors",
            "concepts": [
                "exception-filtering",
                "when-clauses"
            ],
            "difficulty": "murakkab",
            "csharpVersion": "8.0",
            "estimatedTimeSeconds": 120,
            "learningObjectives": [
                "Exception filtering xatolarini aniqlash",
                "When clause limitation'larini bilish"
            ],
            "tags": [
                "when-clause",
                "filtering-errors",
                "side-effects"
            ]
        },
        "codeWithError": "try\n{\n    ProcessData();\n}\ncatch (Exception ex) when (LogException(ex))\n{\n    // handle exception\n}\n\nbool LogException(Exception ex)\n{\n    Console.WriteLine($\"Error: {ex.Message}\");\n    return true;\n}",
        "prompt": "Ushbu exception filtering kodida qanday muammo bor?",
        "answer": "When clause'da side effect'li funksiyalar ishlatilmasligi kerak, LogException har doim chaqiriladi",
        "explanation": "When clause'da side effect'li operatsiyalar (logging, file yozish) ishlatilmasligi kerak. Bu holda LogException har doim chaqiriladi va exception handle qilinadi, bu kutilmagan behavior'ga olib keladi.",
        "errorLocation": {
            "line": 4,
            "column": 32
        }
    },
    {
        "id": 150,
        "type": "output_prediction",
        "metadata": {
            "category": "exception-handling",
            "subcategory": "Using Statement Exception Handling",
            "concepts": [
                "finally-blocks",
                "exception-propagation"
            ],
            "difficulty": "murakkab",
            "csharpVersion": "8.0",
            "estimatedTimeSeconds": 180,
            "learningObjectives": [
                "Using statement va exception interaction'ini tushunish",
                "Resource disposal tartibini bilish"
            ],
            "tags": [
                "using-statement",
                "disposal",
                "exception-interaction"
            ]
        },
        "snippet": "public class TestResource : IDisposable\n{\n    public string Name { get; set; }\n    public void Dispose()\n    {\n        Console.WriteLine($\"Disposing {Name}\");\n    }\n}\n\ntry\n{\n    using (var resource = new TestResource { Name = \"Resource1\" })\n    {\n        Console.WriteLine(\"Using resource\");\n        throw new InvalidOperationException(\"Test error\");\n    }\n}\ncatch (Exception ex)\n{\n    Console.WriteLine($\"Caught: {ex.Message}\");\n}",
        "prompt": "Ushbu kodning natijasi nima bo'ladi?",
        "answer": "Using resource\nDisposing Resource1\nCaught: Test error",
        "explanation": "Using statement exception tashlanganida ham resurs dispose qilinishini kafolatlaydi. Avval 'Using resource' chop etiladi, keyin exception tashlanadi, using blok chiqishida 'Disposing Resource1' chop etiladi, va nihoyat catch blok exception'ni ushlaydi.",
        "stepByStepExecution": [
            "TestResource yaratiladi va Name = 'Resource1' o'rnatiladi",
            "'Using resource' chop etiladi",
            "InvalidOperationException tashlanadi",
            "Using blok chiqishida resource.Dispose() chaqiriladi",
            "'Disposing Resource1' chop etiladi",
            "Exception catch blokka o'tadi",
            "'Caught: Test error' chop etiladi"
        ]
    }
]