[
    {
        "id": 1,
        "type": "mcq",
        "codeBefore": "```csharp\nbool IsLong(string? s) => s switch\n{\n    null                  => false,\n    { Length: > 5 and < 10 } => true,\n    _                     => false\n};\n```",
        "codeAfter": "",
        "prompt": "Which of these calls returns `true`?",
        "options": [
            {
                "id": "A",
                "option": "`IsLong(\"123456\")`"
            },
            {
                "id": "B",
                "option": "`IsLong(\"1234567890\")`"
            },
            {
                "id": "C",
                "option": "`IsLong(null!)`"
            },
            {
                "id": "D",
                "option": "`IsLong(\"abcd\")`"
            }
        ],
        "answer": [
            "A"
        ]
    },
    {
        "id": 2,
        "type": "mcq",
        "codeBefore": "```csharp\nvoid M(in int x, out int y, params object[] rest) { }\n```",
        "codeAfter": "",
        "prompt": "Which of the following call sites is **illegal**?",
        "options": [
            {
                "id": "A",
                "option": "`M(5, out var y)`"
            },
            {
                "id": "B",
                "option": "`int a = 1; M(a, out a)`"
            },
            {
                "id": "C",
                "option": "`M(in 5, out _, 1, 2)`"
            },
            {
                "id": "D",
                "option": "`M(5, out var y, \"x\", 3)`"
            }
        ],
        "answer": [
            "B"
        ]
    },
    {
        "id": 3,
        "type": "mcq",
        "codeBefore": "```csharp\npublic record Point(int X, int Y);\nvar p = new Point(1,2) with { Y = 3 };\n```",
        "codeAfter": "",
        "prompt": "Which statement about `Point` is **false**?",
        "options": [
            {
                "id": "A",
                "option": "Two `Point` instances compare equal if their `X` and `Y` values match."
            },
            {
                "id": "B",
                "option": "You can override `ToString()` in a record."
            },
            {
                "id": "C",
                "option": "`with` creates a new instance."
            },
            {
                "id": "D",
                "option": "You can add a parameterless constructor to `Point`."
            }
        ],
        "answer": [
            "D"
        ]
    },
    {
        "id": 4,
        "type": "mcq",
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "Which is **true** for the C# modifiers `partial` and `file`?",
        "options": [
            {
                "id": "A",
                "option": "`partial class` can span multiple files."
            },
            {
                "id": "B",
                "option": "`file struct` can be referenced outside its file."
            },
            {
                "id": "C",
                "option": "You can declare a type as both `partial` and `file`."
            },
            {
                "id": "D",
                "option": "`file class` allows `private protected` members."
            }
        ],
        "answer": [
            "A"
        ]
    },
    {
        "id": 5,
        "type": "mcq",
        "codeBefore": "```csharp\nvoid F(params int[] nums) { }\n```",
        "codeAfter": "",
        "prompt": "What happens when you call `F(1, 2, new[]{3,4})`?",
        "options": [
            {
                "id": "A",
                "option": "Passes a single array `[1,2,3,4]`."
            },
            {
                "id": "B",
                "option": "Passes two arguments: `1,2` and an array `[3,4]`."
            },
            {
                "id": "C",
                "option": "Compile-time error."
            },
            {
                "id": "D",
                "option": "Packs nested array as one element."
            }
        ],
        "answer": [
            "A"
        ]
    },
    {
        "id": 6,
        "type": "mcq",
        "codeBefore": "```csharp\npublic static TResult Combine<TSource, TResult>(TSource a, TSource b)\n    where TSource : ________, IComparable<TSource>\n    where TResult : TSource, new()\n{\n    // ...\n}\n```",
        "codeAfter": "",
        "prompt": "Which generic constraint should replace the blank to allow arithmetic operators on `TSource` in C# 12?",
        "options": [
            {
                "id": "A",
                "option": "`INumber<TSource>`"
            },
            {
                "id": "B",
                "option": "`struct`"
            },
            {
                "id": "C",
                "option": "`IArithmetic<TSource>`"
            },
            {
                "id": "D",
                "option": "`class`"
            }
        ],
        "answer": [
            "A"
        ]
    },
    {
        "id": 7,
        "type": "mcq",
        "codeBefore": "```csharp\npublic static class Extensions\n{\n    public static bool IsEven(this int number)\n    {\n        return (number % 2) == 0;\n    }\n\n    public bool IsOdd(int number)\n    {\n        return (number % 2) != 0;\n    }\n}\n```",
        "codeAfter": "",
        "prompt": "Which statement is **true** about the code above?",
        "options": [
            {
                "id": "A",
                "option": "`IsEven` is an extension method, `IsOdd` is an instance method."
            },
            {
                "id": "B",
                "option": "Both `IsEven` and `IsOdd` are valid extension methods."
            },
            {
                "id": "C",
                "option": "`IsOdd` should be declared `static` to compile."
            },
            {
                "id": "D",
                "option": "`this int` is invalid in an extension method."
            }
        ],
        "answer": [
            "C"
        ]
    },
    {
        "id": 8,
        "type": "mcq",
        "codeBefore": "```csharp\nfile interface IHelper\n{\n    void Help();\n}\n\n// In another file\n// class HelperImpl : IHelper { ... }\n```",
        "codeAfter": "",
        "prompt": "Which is **true** about `IHelper` declared above?",
        "options": [
            {
                "id": "A",
                "option": "`IHelper` can be implemented only in the same file."
            },
            {
                "id": "B",
                "option": "`IHelper` is `public` across the assembly."
            },
            {
                "id": "C",
                "option": "You can implement `IHelper` in multiple files."
            },
            {
                "id": "D",
                "option": "`file interface` is not valid syntax."
            }
        ],
        "answer": [
            "A"
        ]
    },
    {
        "id": 9,
        "type": "mcq",
        "codeBefore": "```csharp\npublic struct DataPoint\n{\n    public readonly int X;\n    public readonly int Y;\n    public DataPoint(int x, int y) => (X, Y) = (x, y);\n}\n\nvar d1 = new DataPoint(1,2);\nvar d2 = d1;\n\nd2 = new DataPoint(3,4);\nConsole.WriteLine(d1.X + \",\" + d1.Y);\n```",
        "codeAfter": "",
        "prompt": "What will be printed, and why?",
        "options": [
            {
                "id": "A",
                "option": "`1,2` because structs are value types."
            },
            {
                "id": "B",
                "option": "`3,4` because d2 changes d1."
            },
            {
                "id": "C",
                "option": "`1,2` because readonly fields never change."
            },
            {
                "id": "D",
                "option": "Compile error because DataPoint is readonly."
            }
        ],
        "answer": [
            "A"
        ]
    },
    {
        "id": 10,
        "type": "mcq",
        "codeBefore": "```csharp\nint Classify(int x) => x switch\n{\n    < 0 => -1,\n    > 0 => 1,\n    _    => 0\n};\n\nvar result = Classify(0);\n```",
        "codeAfter": "",
        "prompt": "What is the value of `result`?",
        "options": [
            {
                "id": "A",
                "option": "`-1`"
            },
            {
                "id": "B",
                "option": "`0`"
            },
            {
                "id": "C",
                "option": "`1`"
            },
            {
                "id": "D",
                "option": "Compile-time error"
            }
        ],
        "answer": [
            "B"
        ]
    },
    {
        "id": 11,
        "type": "true_false",
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "Declaring a file-scoped namespace (e.g. `namespace MyApp;`) only changes indentationâ€”it does **not** affect accessibility.",
        "answer": "true"
    },
    {
        "id": 12,
        "type": "true_false",
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "A `record struct` can include a user-defined parameterless constructor.",
        "answer": "false"
    },
    {
        "id": 13,
        "type": "true_false",
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "An expression-bodied member using `=>` may contain code that throws exceptions.",
        "answer": "true"
    },
    {
        "id": 14,
        "type": "true_false",
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "C# `switch` patterns can combine type and value checks in one case, e.g. `case string s && s.Length > 0:`.",
        "answer": "true"
    },
    {
        "id": 15,
        "type": "true_false",
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "The default parameterless constructor for a `struct` cannot be overridden or redefined.",
        "answer": "true"
    },
    {
        "id": 16,
        "type": "true_false",
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "C# `switch` expressions require all possible input patterns to be covered at compile time.",
        "answer": "false"
    },
    {
        "id": 17,
        "type": "true_false",
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "Extension methods must be declared in static classes.",
        "answer": "true"
    },
    {
        "id": 18,
        "type": "true_false",
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "Optional parameters can appear before required parameters if you use named arguments at the call site.",
        "answer": "false"
    },
    {
        "id": 19,
        "type": "true_false",
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "Records in C# are reference types by default.",
        "answer": "true"
    },
    {
        "id": 20,
        "type": "true_false",
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "A `sealed` method cannot be further overridden in derived classes.",
        "answer": "true"
    },
    {
        "id": 21,
        "type": "fill",
        "codeWithBlank": "public static T AddAll<T>(T[] values)\n    where T : ________, ________\n{\n    T sum = default!;\n    foreach (var v in values)\n    {\n        sum += v;\n    }\n    return sum;\n}",
        "prompt": "Replace the two blanks with the appropriate .NET generic math interfaces so that both the `+` operator and `default` literal are supported for `T`.",
        "answer": "public static T AddAll<T>(T[] values)\n    where T : INumber<T>, IAdditionOperators<T, T, T>\n{\n    T sum = default!;\n    foreach (var v in values)\n    {\n        sum += v;\n    }\n    return sum;\n}"
    },
    {
        "id": 22,
        "type": "fill",
        "codeWithBlank": "file struct Point(int X, int Y)\n{\n    public void Deconstruct(out int x, out int y) => (x, y) = (______, ______);\n}",
        "prompt": "Point is a file-scoped positional struct. Replace the blanks so that `Deconstruct` returns the values of its primary constructor parameters.",
        "answer": "file struct Point(int X, int Y)\n{\n    public void Deconstruct(out int x, out int y) => (x, y) = (X, Y);\n}"
    },
    {
        "id": 23,
        "type": "fill",
        "codeWithBlank": "public interface IRepository<T>\n{\n    void Add(T item);\n    T? Get(int id);\n}\n\npublic class Repo<T> : ______\n{\n    void IRepository<T>.Add(T item) { /*...*/ }\n    T? IRepository<T>.Get(int id) { /*...*/ }\n}",
        "prompt": "Replace the blank so that `Repo<T>` explicitly implements `IRepository<T>`, hiding its `Add` and `Get` methods from the public API.",
        "answer": "public class Repo<T> : IRepository<T>\n{\n    void IRepository<T>.Add(T item) { /*...*/ }\n    T? IRepository<T>.Get(int id) { /*...*/ }\n}"
    },
    {
        "id": 24,
        "type": "fill",
        "codeWithBlank": "public interface ILogger\n{\n    void Log(string message);\n    void LogError(Exception ex) => ______;\n}",
        "prompt": "Replace the blank so that `LogError` calls `Log` with the exception's string representation.",
        "answer": "public interface ILogger\n{\n    void Log(string message);\n    void LogError(Exception ex) => Log(ex.ToString());\n}"
    },
    {
        "id": 25,
        "type": "fill",
        "codeWithBlank": "int Classify(object o) => o switch\n{\n    string s when ______ => 1,\n    int i when i % 2 == 0 => 2,\n    null                  => 0,\n    _                     => 3\n};",
        "prompt": "Replace the blank with a pattern that matches non-empty strings using C# 12 pattern syntax.",
        "answer": "int Classify(object o) => o switch\n{\n    string s when s.Length > 0 => 1,\n    int i when i % 2 == 0 => 2,\n    null                  => 0,\n    _                     => 3\n};"
    },
    {
        "id": 26,
        "type": "error_spotting",
        "codeWithError": "public class Calculator\n{\n    public static T Subtract<T>(T a, T b) where T : IComparable<T>\n    {\n        return a - b;\n    }\n}",
        "prompt": "Identify and fix the compilation error in the generic `Subtract` method declaration.",
        "answer": "public class Calculator\n{\n    public static T Subtract<T>(T a, T b)\n        where T : ISubtractionOperators<T, T, T>\n    {\n        return a - b;\n    }\n}"
    },
    {
        "id": 27,
        "type": "error_spotting",
        "codeWithError": "interface IShape\n{\n    double Area();\n}\n\npublic class Circle : IShape\n{\n    private readonly double radius;\n    public Circle(double radius) => this.radius = radius;\n    public double area() => Math.PI * radius * radius;\n}",
        "prompt": "Find and correct the error in the `Circle` implementation of `IShape`.",
        "answer": "interface IShape\n{\n    double Area();\n}\n\npublic class Circle : IShape\n{\n    private readonly double radius;\n    public Circle(double radius) => this.radius = radius;\n    public double Area() => Math.PI * radius * radius;\n}"
    },
    {
        "id": 28,
        "type": "error_spotting",
        "codeWithError": "public struct Rectangle\n{\n    public int Width { get; set; }\n    public int Height { get; set; }\n    public Rectangle(int width, int height)\n    {\n        Width = width;\n    }\n}\n",
        "prompt": "The `Rectangle` struct constructor is invalid. Explain and fix the error.",
        "answer": "public struct Rectangle\n{\n    public int Width { get; set; }\n    public int Height { get; set; }\n    public Rectangle(int width, int height)\n    {\n        Width = width;\n        Height = height;\n    }\n}\n"
    },
    {
        "id": 29,
        "type": "error_spotting",
        "codeWithError": "public record Person(string FirstName, string LastName)\n{\n    public string FullName => FirstName + \" \" + LastName;\n    public Person() {}\n}\n",
        "prompt": "This record declaration fails under C# 12. Identify why and provide a corrected version.",
        "answer": "public record Person(string FirstName, string LastName)\n{\n    public string FullName => FirstName + \" \" + LastName;\n    public Person() : this(string.Empty, string.Empty) {}\n}\n"
    },
    {
        "id": 30,
        "type": "error_spotting",
        "codeWithError": "public class Utils\n{\n    public static void LogMessage(string? msg!)\n    {\n        Console.WriteLine(msg);\n    }\n}\n",
        "prompt": "Spot and correct the misuse of nullable annotations in the `LogMessage` signature.",
        "answer": "public class Utils\n{\n    public static void LogMessage(string? msg)\n    {\n        Console.WriteLine(msg);\n    }\n}\n"
    },
    {
        "id": 31,
        "type": "error_spotting",
        "codeWithError": "public abstract class Base\n{\n    public abstract void Save(string data);\n}\n\npublic class FileSaver : Base\n{\n    public void Save(string data)\n    {\n        File.WriteAllText(\"out.txt\", data);\n    }\n}",
        "prompt": "Fix the compile error: `FileSaver` fails to implement `Save`. Correct the code so `FileSaver` properly overrides the abstract method in `Base`.",
        "answer": "public abstract class Base\n{\n    public abstract void Save(string data);\n}\n\npublic class FileSaver : Base\n{\n    public override void Save(string data)\n    {\n        File.WriteAllText(\"out.txt\", data);\n    }\n}"
    },
    {
        "id": 32,
        "type": "error_spotting",
        "codeWithError": "struct Configuration\n{\n    public string Url { get; init; }\n    public Configuration() { Url = \"\"; }\n}",
        "prompt": "Structs cannot define a parameterless constructor. Rewrite the code to initialize `Url` with a default value without adding a parameterless constructor.",
        "answer": "struct Configuration\n{\n    public string Url { get; init; } = string.Empty;\n}"
    },
    {
        "id": 33,
        "type": "error_spotting",
        "codeWithError": "public interface ICalc<T>\n{\n    T Add(T a, T b);\n}\n\npublic class Calculator : ICalc<int>\n{\n    public int Add(int a, int b)\n    {\n        return a + b;\n    }\n}",
        "prompt": "The interface `ICalc<T>` requires a generic parameter, but `Calculator` uses a concrete type. Refactor so that `Calculator` remains generic and correctly implements `ICalc<T>`.",
        "answer": "public interface ICalc<T>\n{\n    T Add(T a, T b);\n}\n\npublic class Calculator<T> : ICalc<T>\n    where T : IAdditionOperators<T, T, T>\n{\n    public T Add(T a, T b)\n    {\n        return a + b;\n    }\n}"
    },
    {
        "id": 34,
        "type": "error_spotting",
        "codeWithError": "public static class StringUtils\n{\n    public static bool IsPalindrome(string s)\n    {\n        return s == new string(s.Reverse().ToArray());\n    }\n\n    public bool IsAnagram(this string s, string t)\n    {\n        return s.OrderBy(c => c).SequenceEqual(t.OrderBy(c => c));\n    }\n}",
        "prompt": "Extension methods must be static. Fix the declaration of `IsAnagram` so it compiles and can be used as `someString.IsAnagram(otherString)`.",
        "answer": "public static class StringUtils\n{\n    public static bool IsPalindrome(string s)\n    {\n        return s == new string(s.Reverse().ToArray());\n    }\n\n    public static bool IsAnagram(this string s, string t)\n    {\n        return s.OrderBy(c => c).SequenceEqual(t.OrderBy(c => c));\n    }\n}"
    },
    {
        "id": 35,
        "type": "error_spotting",
        "codeWithError": "public record Person(string FirstName, string LastName)\n{\n    public Person() { }\n}",
        "prompt": "Records with positional parameters cannot have an additional parameterless constructor without forwarding. Provide a corrected `Person` record definition that allows a parameterless constructor initializing both names to empty strings.",
        "answer": "public record Person(string FirstName, string LastName)\n{\n    public Person() : this(string.Empty, string.Empty) { }\n}"
    }
]