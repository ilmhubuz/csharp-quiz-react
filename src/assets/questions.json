[
    {
        "id": 1,
        "type": "mcq",
        "metadata": {
            "category": "asosiy-til-xususiyatlari",
            "subcategory": "pattern matching"
        },
        "codeBefore": "```csharp\nbool IsLong(string? s) => s switch\n{\n    null                  => false,\n    { Length: > 5 and < 10 } => true,\n    _                     => false\n};\n```",
        "codeAfter": "",
        "prompt": "Yuqoridagi **pattern matching** kodida qaysi method chaqiruvi `true` natija qaytaradi?\n\n**Eslatma:** Property pattern `{ Length: > 5 and < 10 }` string uzunligi 5 dan **katta** va 10 dan **kichik** bo'lgan holatlarda `true` qaytaradi.",
        "options": [
            {
                "id": "A",
                "option": "`IsLong(\"123456\")` - string uzunligi 6"
            },
            {
                "id": "B",
                "option": "`IsLong(\"1234567890\")` - string uzunligi 10"
            },
            {
                "id": "C",
                "option": "`IsLong(null!)` - null qiymat"
            },
            {
                "id": "D",
                "option": "`IsLong(\"abcd\")` - string uzunligi 4"
            }
        ],
        "answer": [
            "A"
        ],
        "explanation": "Property pattern `{ Length: > 5 and < 10 }` uzunligi 6-9 orasidagi stringlarni tanlaydi. A variant: string uzunligi 6 (5 < 6 < 10 ✓), B variant: uzunlik 10 (10 >= 10 ✗), C variant: null (false ✗), D variant: uzunlik 4 (4 <= 5 ✗)."
    },
    {
        "id": 2,
        "type": "mcq",
        "metadata": {
            "category": "metod-xususiyatlari",
            "subcategory": "parametrlar"
        },
        "codeBefore": "```csharp\nvoid M(in int x, out int y, params object[] rest) { }\n```",
        "codeAfter": "",
        "prompt": "Yuqoridagi method da turli **parameter** turlari mavjud:\n- `in` - **readonly** parameter (o'qish uchun)\n- `out` - **write-only** parameter (yozish uchun)\n- `params` - **variable argument** list\n\nQaysi method chaqiruvi **noto'g'ri** va **compilation error** beradi?",
        "options": [
            {
                "id": "A",
                "option": "`M(5, out var y)` - literal qiymat `in` parameter uchun"
            },
            {
                "id": "B",
                "option": "`int a = 1; M(a, out a)` - bir xil variable ni `in` va `out` uchun ishlatish"
            },
            {
                "id": "C",
                "option": "`M(in 5, out _, 1, 2)` - explicit `in` keyword va discard pattern"
            },
            {
                "id": "D",
                "option": "`M(5, out var y, \"x\", 3)` - `params` bilan qo'shimcha argumentlar"
            }
        ],
        "answer": [
            "B"
        ],
        "explanation": "Bir xil variable ni bir method chaqiruvida ham `in` (readonly) ham `out` (write-only) parameter sifatida ishlatib bo'lmaydi. Bu logik contradiction yaratadi va compiler error beradi. A: literal `in` ga valid ✓, C: explicit `in` keyword valid ✓, D: `params` qo'shimcha argumentlar qabul qiladi ✓."
    },
    {
        "id": 3,
        "type": "mcq",
        "metadata": {
            "category": "asosiy-til-xususiyatlari",
            "subcategory": "records"
        },
        "codeBefore": "```csharp\npublic record Point(int X, int Y);\nvar p = new Point(1,2) with { Y = 3 };\n```",
        "codeAfter": "",
        "prompt": "Yuqoridagi **positional record** `Point` haqida qaysi gap **noto'g'ri**?\n\n**Eslatma:** Positional recordlar avtomatik property, constructor, equality comparison va `with` expression support beradi.",
        "options": [
            {
                "id": "A",
                "option": "Agar ikki `Point` objectining `X` va `Y` qiymatlari bir xil bo'lsa, ular **value equality** asosida teng hisoblanadi"
            },
            {
                "id": "B",
                "option": "Record typeda `ToString()` methodini **override** qilib, custom string representation yaratish mumkin"
            },
            {
                "id": "C",
                "option": "`with` expression orqali mavjud recorddan **copy** yaratib, ba'zi propertylarini o'zgartirish mumkin"
            },
            {
                "id": "D",
                "option": "Positional record ga qo'shimcha **parameterless constructor** qo'shish mumkin va primary constructorni bypass qilish mumkin"
            }
        ],
        "answer": [
            "D"
        ],
        "explanation": "Positional recordlarga qo'shimcha parameterless constructor qo'shib bo'lmaydi. Primary constructor - yagona yaratish usuli. A: recordlar value-based equality ga ega ✓, B: ToString() override qilish mumkin ✓, C: with expression copy-with-modifications pattern ✓."
    },
    {
        "id": 4,
        "type": "mcq",
        "metadata": {
            "category": "asosiy-til-xususiyatlari",
            "subcategory": "file-scoped-types"
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "C# da **type modifierlar** haqida qaysi gap **to'g'ri**?\n\n**Modifier turlari:**\n- `partial` - type ni bir nechta fayllarga bo'lish uchun\n- `file` - type ni faqat joriy faylda ko'rinish uchun",
        "options": [
            {
                "id": "A",
                "option": "`partial class` ni **bir nechta fayl** bo'ylab bo'lib, har qismini alohida faylda yozish mumkin"
            },
            {
                "id": "B",
                "option": "`file struct` ni **boshqa fayldan** access qilib, instance yaratish mumkin"
            },
            {
                "id": "C",
                "option": "Bir typeni **bir vaqtning o'zida** ham `partial` ham `file` modifier bilan e'lon qilish mumkin"
            },
            {
                "id": "D",
                "option": "`file class` da **private protected** access modifier ishlatib, member yaratish mumkin"
            }
        ],
        "answer": [
            "A"
        ],
        "explanation": "Partial classlar bir assemblydagi bir nechta faylga bo'linishi mumkin, kodni organize qilish va modularity uchun foydali. B: file types faqat joriy faylda visible ✗, C: partial va file modifierlarni birga ishlatib bo'lmaydi ✗, D: file classda private protected member bo'lishi mumkin emas ✗."
    },
    {
        "id": 5,
        "type": "mcq",
        "metadata": {
            "category": "metod-xususiyatlari",
            "subcategory": "params-arrays"
        },
        "codeBefore": "```csharp\nvoid F(params int[] nums) { }\n```",
        "codeAfter": "",
        "prompt": "Yuqoridagi methodga `F(1, 2, new[]{3,4})` **chaqiruvi** amalga oshirilganda nima bo'ladi?\n\n**Eslatma:** `params` parameter ikki xil usulda ishlatiladi:\n- Individual argumentlar: `F(1, 2, 3, 4)`\n- Bitta array: `F(new[]{1, 2, 3, 4})`",
        "options": [
            {
                "id": "A",
                "option": "Barcha argumentlar **combine** bo'lib, bitta `[1,2,3,4]` array yaratiladi"
            },
            {
                "id": "B",
                "option": "**Uch argument** uzatiladi: `1`, `2` va `int[]` array object"
            },
            {
                "id": "C",
                "option": "**Compilation error** - individual values va array ni aralashtirib bo'lmaydi"
            },
            {
                "id": "D",
                "option": "**Runtime exception** - argument type conversion muammosi"
            }
        ],
        "answer": [
            "C"
        ],
        "explanation": "params parameter bilan faqat ikki variant mumkin: yoki faqat individual values (F(1,2,3,4)) yoki faqat bitta array (F(new[]{1,2,3,4})). Individual values (1,2) va array (new[]{3,4}) ni aralashtirib bo'lmaydi - compilation error beradi."
    },
    {
        "id": 6,
        "type": "mcq",
        "metadata": {
            "category": "tip-tizimi-oop",
            "subcategory": "generics-constraints"
        },
        "codeBefore": "```csharp\npublic static TResult Combine<TSource, TResult>(TSource a, TSource b)\n    where TSource : ________, IComparable<TSource>\n    where TResult : TSource, new()\n{\n    // Arifmetik operatorlar ishlatiladi: +, -, *, /\n    return new TResult();\n}\n```",
        "codeAfter": "",
        "prompt": "**Generic math** (.NET 7+) da `TSource` type uchun **arifmetik operatorlar** (`+`, `-`, `*`, `/`) ishlatish uchun qaysi **generic constraint** kerak?\n\n**Eslatma:** C# 11+ da static abstract interface memberlar orqali operator overloading mumkin.",
        "options": [
            {
                "id": "A",
                "option": "`INumber<TSource>` - .NET 7+ generic math interface"
            },
            {
                "id": "B",
                "option": "`struct` - value type constraint"
            },
            {
                "id": "C",
                "option": "`IArithmetic<TSource>` - custom arithmetic interface"
            },
            {
                "id": "D",
                "option": "`class` - reference type constraint"
            }
        ],
        "answer": [
            "A"
        ],
        "explanation": "INumber<T> .NET 7+ da arifmetik operatorlar uchun asosiy interface. Static abstract interface memberlar orqali +, -, *, / operatorlarini ta'minlaydi. B: struct constraint arifmetik operator bermaydi ✗, C: IArithmetic<T> mavjud emas ✗, D: class constraint arifmetik operator bermaydi ✗."
    },
    {
        "id": 7,
        "type": "mcq",
        "metadata": {
            "category": "metod-xususiyatlari",
            "subcategory": "extension-methods"
        },
        "codeBefore": "```csharp\npublic static class Extensions\n{\n    public static bool IsEven(this int number)\n    {\n        return (number % 2) == 0;\n    }\n\n    public bool IsOdd(int number)\n    {\n        return (number % 2) != 0;\n    }\n}\n```",
        "codeAfter": "",
        "prompt": "Extension methodlar haqida yuqoridagi kodda qaysi muammo bor?",
        "options": [
            {
                "id": "A",
                "option": "`IsEven` extension method, `IsOdd` esa oddiy instance method.",
                "explanation_uz": "IsOdd instance metod emas, static kalit so'z etishmayapti"
            },
            {
                "id": "B",
                "option": "`IsEven` va `IsOdd` ikkalasi ham extension method bo'lishi mumkin.",
                "explanation_uz": "Agar IsOdd to'g'ri sintaksisga ega bo'lsa, ikkalasi ham extension metod bo'lishi mumkin"
            },
            {
                "id": "C",
                "option": "`IsOdd` ni kompilyatsiya uchun `static` qilish kerak.",
                "explanation_uz": "To'g'ri - static klassdagi barcha metodlar static bo'lishi kerak"
            },
            {
                "id": "D",
                "option": "`this int` kalit so'zi extension methodda kerak emas.",
                "explanation_uz": "'this' kalit so'z extension metodlar uchun kerak"
            }
        ],
        "answer": [
            "C"
        ],
        "explanation": "In a static class, all methods must be static. IsOdd method is missing the static keyword, which will cause a compilation error.",
        "explanation_uz": "Static klassda barcha metodlar static bo'lishi kerak. IsOdd metodida static kalit so'z etishmayapti, bu kompilyatsiya xatosiga olib keladi."
    },
    {
        "id": 8,
        "type": "mcq",
        "metadata": {
            "category": "asosiy-til-xususiyatlari",
            "subcategory": "file-scoped-types"
        },
        "codeBefore": "```csharp\nfile interface IHelper\n{\n    void Help();\n}\n\n// In another file\n// class HelperImpl : IHelper { ... }\n```",
        "codeAfter": "",
        "prompt": "`file` modifier bilan e'lon qilingan `IHelper` haqida qaysi fikr **to'g'ri**?",
        "options": [
            {
                "id": "A",
                "option": "`IHelper` faqat shu faylda ko'rinadi va implementatsiya qilinishi mumkin.",
                "explanation_uz": "To'g'ri - file turlari faqat o'sha fayl ichida ko'rinadi"
            },
            {
                "id": "B",
                "option": "`IHelper` butun assembly bo'ylab `public` hisoblanadi.",
                "explanation_uz": "file modifikatori ko'rinuvchanlikni faqat joriy fayl bilan cheklaydi"
            },
            {
                "id": "C",
                "option": "`IHelper` ni bir nechta faylda implementatsiya qilish mumkin.",
                "explanation_uz": "Fayl doirasidagi interfeyslarga boshqa fayllardan kira olmaydi"
            },
            {
                "id": "D",
                "option": "`file interface` noto'g'ri sintaksis.",
                "explanation_uz": "file interface C# 11+ da to'g'ri sintaksis"
            }
        ],
        "answer": [
            "A"
        ],
        "explanation": "File-scoped types (including interfaces) are only visible within the file where they are declared. They cannot be accessed or implemented from other files.",
        "explanation_uz": "Fayl doirasidagi turlar (interfeyslarga ham tegishli) faqat e'lon qilingan fayl ichida ko'rinadi. Ularni boshqa fayllardan kirish yoki tatbiq qilib bo'lmaydi."
    },
    {
        "id": 9,
        "type": "mcq",
        "metadata": {
            "category": "tip-tizimi-oop",
            "subcategory": "value-types"
        },
        "codeBefore": "```csharp\npublic struct DataPoint\n{\n    public readonly int X;\n    public readonly int Y;\n    public DataPoint(int x, int y) => (X, Y) = (x, y);\n}\n\nvar d1 = new DataPoint(1,2);\nvar d2 = d1;  // struct copy\n\nd2 = new DataPoint(3,4);\nConsole.WriteLine(d1.X + \",\" + d1.Y);\n```",
        "codeAfter": "",
        "prompt": "Struct value semantics tufayli natija nima bo'ladi?",
        "options": [
            {
                "id": "A",
                "option": "`1,2` – chunki struct value type, d2 ni o'zgartirish d1 ga ta'sir qilmaydi.",
                "explanation_uz": "To'g'ri - structlar qiymat semantikasiga ega, d1 va d2 mustaqil"
            },
            {
                "id": "B",
                "option": "`3,4` – chunki d2 o'zgartirilsa, d1 ham o'zgaradi.",
                "explanation_uz": "Bu reference turlar uchun to'g'ri bo'lardi, qiymat turlari uchun emas"
            },
            {
                "id": "C",
                "option": "`1,2` – chunki readonly fieldlar o'zgarmaydi.",
                "explanation_uz": "readonly omil bo'lsa-da, asosiy sabab qiymat semantikasidir"
            },
            {
                "id": "D",
                "option": "Kompilyatsiya xatosi, chunki DataPoint readonly.",
                "explanation_uz": "Kompilyatsiya xatosi yo'q - readonly fieldlar, readonly struct emas"
            }
        ],
        "answer": [
            "A"
        ],
        "explanation": "Structs have value semantics, meaning assignment creates independent copies. When d2 is assigned a new value, d1 remains unchanged because they are separate copies.",
        "explanation_uz": "Structlar qiymat semantikasiga ega, ya'ni tayinlash mustaqil nusxalar yaratadi. d2 ga yangi qiymat tayinlanganda, d1 o'zgarishsiz qoladi chunki ular alohida nusxalardir."
    },
    {
        "id": 10,
        "type": "mcq",
        "metadata": {
            "category": "asosiy-til-xususiyatlari",
            "subcategory": "pattern-matching"
        },
        "codeBefore": "```csharp\nint Classify(int x) => x switch\n{\n    < 0 => -1,  // manfiy\n    > 0 => 1,   // musbat\n    _   => 0    // nol\n};\n\nvar result = Classify(0);\n```",
        "codeAfter": "",
        "prompt": "Switch expression da 0 qiymati qaysi case ga mos keladi?",
        "options": [
            {
                "id": "A",
                "option": "`-1` - chunki < 0",
                "explanation_uz": "0 < 0 emas, shuning uchun bu pattern mos kelmaydi"
            },
            {
                "id": "B",
                "option": "`0` - chunki `_` (default) case",
                "explanation_uz": "To'g'ri - 0 na < 0 na > 0 ga mos kelmaydi, shuning uchun default _ ga tushadi"
            },
            {
                "id": "C",
                "option": "`1` - chunki > 0",
                "explanation_uz": "0 > 0 emas, shuning uchun bu pattern mos kelmaydi"
            },
            {
                "id": "D",
                "option": "Kompilyatsiya xatosi",
                "explanation_uz": "Kompilyatsiya xatosi yo'q - switch _ pattern bilan to'liq"
            }
        ],
        "answer": [
            "B"
        ],
        "explanation": "In switch expressions, patterns are evaluated in order. Since 0 is neither < 0 nor > 0, it falls through to the default pattern _ which returns 0.",
        "explanation_uz": "Switch expressionlarda patternlar tartib bilan baholanadi. 0 na < 0 na > 0 bo'lgani uchun, default pattern _ ga tushadi va 0 qaytaradi."
    },
    {
        "id": 11,
        "type": "true_false",
        "metadata": {
            "category": "asosiy-til-xususiyatlari",
            "subcategory": "file-scoped-namespaces"
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "File-scoped namespace (`namespace MyApp;`) faqat kodni tashkillashtirish uchun ishlatiladi va access modifierlar yoki ko'rinuvchanlikka ta'sir qilmaydi.",
        "answer": "true",
        "explanation": "File-scoped namespaces are purely for code organization and don't affect access modifiers or visibility rules.",
        "explanation_uz": "Fayl doirasidagi namespace-lar faqat kodni tashkil qilish uchun bo'lib, access modifierlar yoki ko'rinuvchanlik qoidalariga ta'sir qilmaydi."
    },
    {
        "id": 12,
        "type": "true_false",
        "metadata": {
            "category": "asosiy-til-xususiyatlari",
            "subcategory": "record-structs"
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "C# 10+ da `record struct` uchun foydalanuvchi tomonidan yaratilgan parametrsiz konstruktor e'lon qilish mumkin.",
        "answer": "true",
        "explanation": "C# 10+ allows parameterless constructors in record structs, unlike earlier versions where this was restricted.",
        "explanation_uz": "C# 10+ da record struct-larda parametrsiz konstruktor e'lon qilish mumkin, oldingi versiyalardan farqli o'laroq bu cheklangan edi."
    },
    {
        "id": 13,
        "type": "true_false",
        "metadata": {
            "category": "asosiy-til-xususiyatlari",
            "subcategory": "expression-bodied-members"
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "Expression-bodied member (`=>`) ichida exception throw qilish va kompleks mantiq yozish mumkin.",
        "answer": "true",
        "explanation": "Expression-bodied members can contain complex logic, including throwing exceptions, conditional expressions, and method calls.",
        "explanation_uz": "Expression-bodied a'zolarda murakkab mantiq, jumladan exception tashlaish, shartli expressionlar va metod chaqiruvlari bo'lishi mumkin."
    },
    {
        "id": 14,
        "type": "true_false",
        "metadata": {
            "category": "asosiy-til-xususiyatlari",
            "subcategory": "pattern-matching"
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "C# switch patternlari bir case ichida tip tekshirish va qo'shimcha shart birga yozilishi mumkin, masalan: `case string s when s.Length > 0:`.",
        "answer": "true",
        "explanation": "Pattern guards (when clauses) allow combining type patterns with additional boolean conditions in the same case.",
        "explanation_uz": "Pattern guardlar (when clause-lar) tip patternlarni qo'shimcha boolean shartlar bilan bitta case da birlashtirish imkonini beradi."
    },
    {
        "id": 15,
        "type": "true_false",
        "metadata": {
            "category": "tip-tizimi-oop",
            "subcategory": "structs"
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "C# 10+ da struct uchun parametrsiz konstruktor e'lon qilish va default xatti-harakatni o'zgartirish mumkin.",
        "answer": "true",
        "explanation": "C# 10+ allows declaring parameterless constructors in structs, enabling custom initialization logic beyond the default behavior.",
        "explanation_uz": "C# 10+ da struct-larda parametrsiz konstruktor e'lon qilish mumkin, bu default xatti-harakatdan tashqari maxsus initialization mantiqini yoqish imkonini beradi."
    },
    {
        "id": 16,
        "type": "true_false",
        "metadata": {
            "category": "asosiy-til-xususiyatlari",
            "subcategory": "switch expressions"
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "C# switch expressionlari barcha mumkin bo'lgan input patternlarni kompilyatsiya vaqtida qamrab olishi shart (default case bo'lmasa ham).",
        "answer": "false",
        "explanation": "Switch expressionlar exhaustive bo'lishi kerak, lekin kompilyator ba'zi hollarda barcha mumkin bo'lgan input patternlarni automatic aniqlayolmaydi va default case (_) talab qilishi mumkin."
    },
    {
        "id": 17,
        "type": "true_false",
        "metadata": {
            "category": "metod-xususiyatlari",
            "subcategory": "extension metodlar"
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "Extension methodlar faqat static class ichida e'lon qilinadi va o'zi ham static bo'lishi kerak.",
        "answer": "true",
        "explanation": "Extension metodlar faqat static klasslarda e'lon qilinadi va o'zlari ham static bo'lishi kerak. Birinchi parametr 'this' kalit so'zi bilan belgilanadi."
    },
    {
        "id": 18,
        "type": "true_false",
        "metadata": {
            "category": "metod-xususiyatlari",
            "subcategory": "named arguments"
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "Named argumentlardan foydalanganda method chaqirishda optional parametrlarni required parametrlardan oldin yozish mumkin.",
        "answer": "true",
        "explanation": "Named argumentlar ishlatilganda parametrlarning tartibini o'zgartirish mumkin, shu jumladan optional parametrlarni required parametrlardan oldin yozish ham mumkin."
    },
    {
        "id": 19,
        "type": "true_false",
        "metadata": {
            "category": "asosiy-til-xususiyatlari",
            "subcategory": "record class"
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "C# da `record` (record class) default bo'yicha reference type hisoblanadi.",
        "answer": "true",
        "explanation": "C# da 'record' kalit so'zi default bo'yicha record class yaratadi va u reference type hisoblanadi. Value type uchun aniq 'record struct' yozish kerak."
    },
    {
        "id": 20,
        "type": "true_false",
        "metadata": {
            "category": "tip-tizimi-oop",
            "subcategory": "inheritance"
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "`sealed` bilan belgilangan virtual metodni boshqa derived klasslarda override qilib bo'lmaydi.",
        "answer": "true",
        "explanation": "Sealed virtual metod override zanjirini to'xtatadi. Bu metodni further derived klasslarda override qilib bo'lmaydi, lekin base class implementatsiyasidan foydalanish mumkin."
    },
    {
        "id": 21,
        "type": "fill",
        "metadata": {
            "category": "tip-tizimi-oop",
            "subcategory": "generic math"
        },
        "codeWithBlank": "public static T AddAll<T>(T[] values)\n    where T : ________, ________\n{\n    T sum = default!;\n    foreach (var v in values)\n    {\n        sum += v;\n    }\n    return sum;\n}",
        "prompt": "`T` uchun `+` operatori va `default` literalini ishlatish imkonini beruvchi .NET 7+ generic math interfeyslarini ikki bo'sh joyga yozing.",
        "answer": "public static T AddAll<T>(T[] values)\n    where T : INumber<T>, IAdditionOperators<T, T, T>\n{\n    T sum = default!;\n    foreach (var v in values)\n    {\n        sum += v;\n    }\n    return sum;\n}",
        "explanation": "INumber<T> asosiy raqamli tip interfeysi bo'lib, IAdditionOperators<T, T, T> esa + operatorini ta'minlaydi. Ikkalasi ham .NET 7+ generic math sistemasi qismidir."
    },
    {
        "id": 22,
        "type": "fill",
        "metadata": {
            "category": "asosiy-til-xususiyatlari",
            "subcategory": "file-scoped types"
        },
        "codeWithBlank": "file struct Point(int X, int Y)\n{\n    public void Deconstruct(out int x, out int y) => (x, y) = (______, ______);\n}",
        "prompt": "File-scoped positional struct da Deconstruct metodi primary constructor parametrlarini qaytarishi uchun bo'sh joylarni to'ldiring.",
        "answer": "file struct Point(int X, int Y)\n{\n    public void Deconstruct(out int x, out int y) => (x, y) = (X, Y);\n}",
        "explanation": "Primary constructor parametrlari X va Y sifatida mavjud va ularni Deconstruct metodida to'g'ridan-to'g'ri ishlatish mumkin."
    },
    {
        "id": 23,
        "type": "fill",
        "metadata": {
            "category": "tip-tizimi-oop",
            "subcategory": "interfaces"
        },
        "codeWithBlank": "public interface IRepository<T>\n{\n    void Add(T item);\n    T? Get(int id);\n}\n\npublic class Repo<T> : ______\n{\n    void IRepository<T>.Add(T item) { /*...*/ }\n    T? IRepository<T>.Get(int id) { /*...*/ }\n}",
        "prompt": "Explicit interface implementation qilish uchun inheritance qismini to'ldiring (metodlar public emas, faqat interface orqali accessible).",
        "answer": "public class Repo<T> : IRepository<T>\n{\n    void IRepository<T>.Add(T item) { /*...*/ }\n    T? IRepository<T>.Get(int id) { /*...*/ }\n}",
        "explanation": "Generic interface IRepository<T> ni implement qilish uchun class inheritance da to'liq nom ko'rsatilishi kerak."
    },
    {
        "id": 24,
        "type": "fill",
        "metadata": {
            "category": "tip-tizimi-oop",
            "subcategory": "default implementation"
        },
        "codeWithBlank": "public interface ILogger\n{\n    void Log(string message);\n    void LogError(Exception ex) => ______;\n}",
        "prompt": "Default interface implementation: `LogError` metodi exception ni string formatda `Log` metodiga uzatsin.",
        "answer": "public interface ILogger\n{\n    void Log(string message);\n    void LogError(Exception ex) => Log(ex.ToString());\n}",
        "explanation": "Default implementation da Log metodini chaqirib, exception ni ToString() orqali string formatga aylantirib uzatish mumkin."
    },
    {
        "id": 25,
        "type": "fill",
        "metadata": {
            "category": "asosiy-til-xususiyatlari",
            "subcategory": "pattern matching"
        },
        "codeWithBlank": "int Classify(object o) => o switch\n{\n    string s when ______ => 1,\n    int i when i % 2 == 0 => 2,\n    null                  => 0,\n    _                     => 3\n};",
        "prompt": "Pattern matching da bo'sh bo'lmagan (non-empty) stringni tekshiruvchi shart yozing.",
        "answer": "int Classify(object o) => o switch\n{\n    string s when s.Length > 0 => 1,\n    int i when i % 2 == 0 => 2,\n    null                  => 0,\n    _                     => 3\n};",
        "explanation": "String type pattern da s.Length > 0 sharti bo'sh bo'lmagan stringlarni aniqlaydi. Null holatda already handled bo'lgani uchun null check kerak emas."
    },
    {
        "id": 26,
        "type": "error_spotting",
        "metadata": {
            "category": "tip-tizimi-oop",
            "subcategory": "generic math"
        },
        "codeWithError": "public class Calculator\n{\n    public static T Subtract<T>(T a, T b) where T : IComparable<T>\n    {\n        return a - b;  // Bu yerda xato\n    }\n}",
        "prompt": "Generic subtraction operatori uchun noto'g'ri constraint ishlatilgan. To'g'ri generic math interface bilen tuzating.",
        "answer": "public class Calculator\n{\n    public static T Subtract<T>(T a, T b)\n        where T : ISubtractionOperators<T, T, T>\n    {\n        return a - b;\n    }\n}",
        "explanation": "IComparable<T> faqat taqqoslash uchun, matematik operatorlar uchun emas. Subtraction uchun ISubtractionOperators<T, T, T> interfeysi kerak."
    },
    {
        "id": 27,
        "type": "error_spotting",
        "metadata": {
            "category": "tip-tizimi-oop",
            "subcategory": "interfaces"
        },
        "codeWithError": "interface IShape\n{\n    double Area();  // Capital A\n}\n\npublic class Circle : IShape\n{\n    private readonly double radius;\n    public Circle(double radius) => this.radius = radius;\n    public double area() => Math.PI * radius * radius;  // kichik a\n}",
        "prompt": "Interface implementationida method name case sensitivity xatosi bor. Tuzating.",
        "answer": "interface IShape\n{\n    double Area();\n}\n\npublic class Circle : IShape\n{\n    private readonly double radius;\n    public Circle(double radius) => this.radius = radius;\n    public double Area() => Math.PI * radius * radius;\n}",
        "explanation": "C# case-sensitive til. Interface da Area() deb e'lon qilingan metod aynan Area() nomli bo'lishi kerak, area() emas."
    },
    {
        "id": 28,
        "type": "error_spotting",
        "metadata": {
            "category": "tip-tizimi-oop",
            "subcategory": "structs"
        },
        "codeWithError": "public struct Rectangle\n{\n    public int Width { get; set; }\n    public int Height { get; set; }\n    public Rectangle(int width, int height)\n    {\n        Width = width;\n        // Height initsializatsiya qilinmagan!\n    }\n}",
        "prompt": "Struct konstruktorida barcha fieldlar/propertylar initsializatsiya qilinishi kerak. Tuzating.",
        "answer": "public struct Rectangle\n{\n    public int Width { get; set; }\n    public int Height { get; set; }\n    public Rectangle(int width, int height)\n    {\n        Width = width;\n        Height = height;\n    }\n}",
        "explanation": "Struct konstruktorida barcha fieldlar va propertylar initialize qilinishi kerak. Height property ga qiymat berilmagan."
    },
    {
        "id": 29,
        "type": "error_spotting",
        "metadata": {
            "category": "asosiy-til-xususiyatlari",
            "subcategory": "records"
        },
        "codeWithError": "public record Person(string FirstName, string LastName)\n{\n    public string FullName => FirstName + \" \" + LastName;\n    public Person() {}  // Primary constructor chaqirilmagan\n}",
        "prompt": "Positional record uchun parametrsiz konstruktor primary constructor ni chaqirishi kerak. Tuzating.",
        "answer": "public record Person(string FirstName, string LastName)\n{\n    public string FullName => FirstName + \" \" + LastName;\n    public Person() : this(string.Empty, string.Empty) {}\n}",
        "explanation": "Positional record da qo'shimcha konstruktor primary constructor ni this() orqali chaqirishi kerak."
    },
    {
        "id": 30,
        "type": "error_spotting",
        "metadata": {
            "category": "asosiy-til-xususiyatlari",
            "subcategory": "nullable reference types"
        },
        "codeWithError": "public class Utils\n{\n    public static void LogMessage(string? msg!)  // ? va ! birga ishlatilgan\n    {\n        Console.WriteLine(msg);\n    }\n}",
        "prompt": "Nullable annotation sintaksisida xato bor. Bir parametrda `?` va `!` birga ishlatilmaydi.",
        "answer": "public class Utils\n{\n    public static void LogMessage(string? msg)\n    {\n        Console.WriteLine(msg);\n    }\n}",
        "explanation": "Parametr deklaratsiyasida ? (nullable) va ! (null-forgiving) operatorlari birga ishlatilmaydi. Faqat string? yoki string ishlatish kerak."
    },
    {
        "id": 31,
        "type": "error_spotting",
        "metadata": {
            "category": "tip-tizimi-oop",
            "subcategory": "inheritance"
        },
        "codeWithError": "public abstract class Base\n{\n    public abstract void Save(string data);\n}\n\npublic class FileSaver : Base\n{\n    public void Save(string data)  // override kalit so'zi yo'q\n    {\n        File.WriteAllText(\"out.txt\", data);\n    }\n}",
        "prompt": "Abstract metodini implement qilishda `override` kalit so'zi kerak. Tuzating.",
        "answer": "public abstract class Base\n{\n    public abstract void Save(string data);\n}\n\npublic class FileSaver : Base\n{\n    public override void Save(string data)\n    {\n        File.WriteAllText(\"out.txt\", data);\n    }\n}",
        "explanation": "Abstract metodini implement qilishda override kalit so'zi shart. Bu abstract contract ni bajarayotganingizni ko'rsatadi."
    },
    {
        "id": 32,
        "type": "error_spotting",
        "metadata": {
            "category": "asosiy-til-xususiyatlari",
            "subcategory": "init properties"
        },
        "codeWithError": "struct Configuration\n{\n    public string Url { get; init; }\n    public Configuration() { Url = \"\"; }  // C# 11+ da ruxsat etilgan, lekin init-only property bilan muammo\n}",
        "prompt": "Init-only property ni konstruktor ichida to'g'ridan-to'g'ri initialize qilish o'rniga, property initializer ishlatish yaxshiroq. Tuzating.",
        "answer": "struct Configuration\n{\n    public string Url { get; init; } = string.Empty;\n}",
        "explanation": "Init-only property uchun property initializer ishlatish yaxshiroq, chunki bu property ning immutable nature ni ta'kidlaydi."
    },
    {
        "id": 33,
        "type": "error_spotting",
        "metadata": {
            "category": "tip-tizimi-oop",
            "subcategory": "generic constraints"
        },
        "codeWithError": "public interface ICalc<T>\n{\n    T Add(T a, T b);\n}\n\npublic class Calculator : ICalc<int>  // Konkret tip bilan cheklangan\n{\n    public int Add(int a, int b)\n    {\n        return a + b;\n    }\n}",
        "prompt": "Generic interface ni generic class bilan implement qiling va arifmetik operatorlar uchun constraint qo'shing.",
        "answer": "public interface ICalc<T>\n{\n    T Add(T a, T b);\n}\n\npublic class Calculator<T> : ICalc<T>\n    where T : IAdditionOperators<T, T, T>\n{\n    public T Add(T a, T b)\n    {\n        return a + b;\n    }\n}",
        "explanation": "Generic interface ni generic class bilan implement qilish type flexibility beradi. IAdditionOperators constraint matematik operatorni ta'minlaydi."
    },
    {
        "id": 34,
        "type": "error_spotting",
        "metadata": {
            "category": "metod-xususiyatlari",
            "subcategory": "extension methods"
        },
        "codeWithError": "public static class StringUtils\n{\n    public static bool IsPalindrome(string s)\n    {\n        return s == new string(s.Reverse().ToArray());\n    }\n\n    public bool IsAnagram(this string s, string t)  // static emas\n    {\n        return s.OrderBy(c => c).SequenceEqual(t.OrderBy(c => c));\n    }\n}",
        "prompt": "Extension method `static` bo'lishi kerak. Tuzating.",
        "answer": "public static class StringUtils\n{\n    public static bool IsPalindrome(string s)\n    {\n        return s == new string(s.Reverse().ToArray());\n    }\n\n    public static bool IsAnagram(this string s, string t)\n    {\n        return s.OrderBy(c => c).SequenceEqual(t.OrderBy(c => c));\n    }\n}",
        "explanation": "Static class ichidagi barcha metodlar static bo'lishi kerak. Extension metodlar ham static bo'lishi shart."
    },
    {
        "id": 35,
        "type": "error_spotting",
        "metadata": {
            "category": "asosiy-til-xususiyatlari",
            "subcategory": "records"
        },
        "codeWithError": "public record Person(string FirstName, string LastName)\n{\n    public Person() { }  // Primary constructor chaqirilmagan\n}",
        "prompt": "Positional record da parametrsiz konstruktor primary constructor ni chaqirishi kerak.",
        "answer": "public record Person(string FirstName, string LastName)\n{\n    public Person() : this(string.Empty, string.Empty) { }\n}",
        "explanation": "Positional record da qo'shimcha konstruktor primary constructor ni : this() sintaksis orqali chaqirishi kerak."
    },
    {
        "id": 36,
        "type": "output_prediction",
        "metadata": {
            "category": "tip-tizimi-oop",
            "subcategory": "method hiding"
        },
        "snippet": "class A\n{\n    public virtual string F() => \"A\";\n}\nclass B : A\n{\n    public override string F() => base.F() + \"B\";  // \"AB\"\n}\nclass C : B\n{\n    public new string F() => base.F() + \"C\";  // \"ABC\" lekin virtual dispatch yo'q\n}\n\nA obj = new C();\nConsole.WriteLine(obj.F());  // A reference orqali chaqirilmoqda",
        "prompt": "`new` keyword virtual dispatch ni to'xtatadi. `obj.F()` natijasi?",
        "answer": "AB",
        "explanation": "C.F() metodi 'new' bilan hide qilingan, shuning uchun A reference orqali B.F() chaqiriladi, natija 'AB'."
    },
    {
        "id": 37,
        "type": "output_prediction",
        "metadata": {
            "category": "tip-tizimi-oop",
            "subcategory": "default interface implementation"
        },
        "snippet": "interface ILog\n{\n    void Log(string msg) => Console.Write(\"DefaultLog:\");  // Default implementation\n}\nclass Logger : ILog { }  // O'z implementatsiyasi yo'q\n\nvar logger = new Logger();\n((ILog)logger).Log(\"Hello\");",
        "prompt": "Logger class Log metodini override qilmagan. Default interface implementation ishlatiladi.",
        "answer": "DefaultLog:",
        "explanation": "Logger class Log metodini implement qilmagan, shuning uchun interface cast orqali default implementation chaqiriladi."
    },
    {
        "id": 38,
        "type": "output_prediction",
        "metadata": {
            "category": "tip-tizimi-oop",
            "subcategory": "method resolution"
        },
        "snippet": "class Base\n{\n    public void Show() => Console.Write(\"Base\");  // Virtual emas\n    public virtual void Display() => Console.Write(\"BaseDisplay\");\n}\nclass Derived : Base\n{\n    public new void Show() => Console.Write(\"Derived\");  // Hiding\n    public override void Display() => Console.Write(\"DerivedDisplay\");  // Override\n}\n\nBase b = new Derived();\nb.Show();     // Base reference -> Base.Show()\nb.Display();  // Virtual dispatch -> Derived.Display()",
        "prompt": "`new` vs `override` farqi. Natija qanday?",
        "answer": "BaseDerivedDisplay",
        "explanation": "Show() non-virtual va 'new' bilan hide qilingan, shuning uchun Base.Show() chaqiriladi. Display() virtual va override qilingan, shuning uchun DerivedDisplay chaqiriladi."
    },
    {
        "id": 39,
        "type": "output_prediction",
        "metadata": {
            "category": "asosiy-til-xususiyatlari",
            "subcategory": "ref readonly"
        },
        "snippet": "var numbers = new[] { 1, 2, 3 };\nint sum = 0;\nforeach (ref readonly var n in numbers)  // Reference by readonly\n{\n    sum += n;  // 1+2+3\n}\nConsole.WriteLine(sum);",
        "prompt": "`ref readonly` faqat performance uchun, hisoblash bir xil. Yig'indi nima?",
        "answer": "6",
        "explanation": "ref readonly faqat performance optimization, mantiq o'zgarmaydi. 1+2+3=6."
    },
    {
        "id": 40,
        "type": "output_prediction",
        "metadata": {
            "category": "asosiy-til-xususiyatlari",
            "subcategory": "records"
        },
        "snippet": "record R(int X)\n{\n    public override string ToString() => $\"R:{X}\";  // Custom ToString\n}\n\nvar r1 = new R(5);\nvar r2 = r1 with { X = 7 };  // Copy with modification\nConsole.WriteLine(r1);\nConsole.WriteLine(r2);",
        "prompt": "Record da custom ToString va `with` expression. Ikki qator natija?",
        "answer": "R:5\nR:7",
        "explanation": "with expression yangi copy yaratadi. r1 o'zgarishsiz qoladi (R:5), r2 yangi qiymat bilan yaratiladi (R:7)."
    },
    {
        "id": 41,
        "type": "code_writing",
        "metadata": {
            "category": "asosiy-til-xususiyatlari",
            "subcategory": "konsol dasturlari"
        },
        "prompt": "### 1. Kontaktlar kitobi konsol dasturi\n\nFoydalanuvchi kontakt qo'shishi va ro'yxatini ko'rishi mumkin bo'lgan konsol dasturini yarating.\n\nHar bir kontaktning `Name`, `PhoneNumber` va `Email` maydonlari bo'ladi. Kontaktlar uchun `record` tipidan foydalaning.\n\nDastur quyidagilarni qo'llab-quvvatlashi kerak:\n- Yangi kontakt qo'shish (`add`)\n- Barcha kontaktlarni ko'rish (`list`)\n- Dasturdan chiqish (`exit`)\n\nKontaktlar ro'yxatini xotirada `List<Contact>` orqali saqlang. Buyruqlarni tanlash uchun sikl va `switch` expression ishlating.",
        "examples": [
            "Buyruq kiriting (add/list/exit): add\nIsm kiriting: Alice\nTelefon kiriting: 9981234567\nEmail kiriting: alice@mail.com\nBuyruq kiriting (add/list/exit): list\nAlice - 9981234567 - alice@mail.com\nBuyruq kiriting (add/list/exit): exit"
        ]
    },
    {
        "id": 42,
        "type": "code_writing",
        "metadata": {
            "category": "tip-tizimi-oop",
            "subcategory": "polimorfizm"
        },
        "prompt": "### 2. Polimorfizm yordamida shakllar yuzasini hisoblash\n\nTurli shakllarning yuzasini hisoblaydigan konsol dasturini yozing.\n\nTalablar:\n- `Shape` nomli abstract class yarating va unda abstract `double GetArea()` metodini e'lon qiling\n- `Circle` va `Rectangle` voris classlarini yarating\n- `GetArea()` metodini har bir classda `override` qiling\n- Foydalanuvchidan shakl turini tanlashni so'rang\n- `switch` expression va polimorfizmdan foydalaning",
        "examples": [
            "Shakl kiriting (circle/rectangle): circle\nRadius kiriting: 2.5\nYuza: 19.63",
            "Shakl kiriting (circle/rectangle): rectangle\nKenglik kiriting: 4\nBalandlik kiriting: 3\nYuza: 12"
        ]
    },
    {
        "id": 43,
        "type": "code_writing",
        "metadata": {
            "category": "metod-xususiyatlari",
            "subcategory": "extension methods"
        },
        "prompt": "### 3. Extension method yordamida telefon raqamini tekshirish\n\n`IsValidUzPhone(this string phone)` extension metodini yarating:\n\nQoidalar:\n- Satr `998` bilan boshlanishi kerak\n- Aniq 12 ta raqamdan iborat bo'lishi kerak\n- Faqat raqamlar bo'lishi kerak\n\nKonsol dasturida foydalanuvchidan raqam kiritishni so'rab, natijani `Valid` yoki `Invalid` deb chiqaring.\n\nExtension metodni `static` classda joylashtiring.",
        "examples": [
            "Telefon raqamini kiriting: 998901234567\nValid",
            "Telefon raqamini kiriting: 9901234567\nInvalid",
            "Telefon raqamini kiriting: 998123\nInvalid"
        ]
    },
    {
        "id": 44,
        "type": "code_writing",
        "metadata": {
            "category": "asosiy-til-xususiyatlari",
            "subcategory": "record structs"
        },
        "prompt": "### 4. `record struct` yordamida koordinata tahlili\n\n`Point` nomli `record struct` yarating, unda `X` va `Y` property bo'lsin.\n\n`Classify(Point p)` metodini yozing:\n- Agar X va Y ikkalasi ham 0: `\"Origin\"`\n- Agar faqat Y 0: `\"X-axis\"`\n- Agar faqat X 0: `\"Y-axis\"`\n- Boshqa holatlarda: `\"Quadrant\"`\n\nPattern matching va switch expressionlardan foydalaning.\n\nFoydalanuvchidan koordinatalarni kiritishni so'rang va natijani chiqaring.",
        "examples": [
            "X ni kiriting: 0\nY ni kiriting: 0\nJoylashuv: Origin",
            "X ni kiriting: 5\nY ni kiriting: 0\nJoylashuv: X-axis",
            "X ni kiriting: 3\nY ni kiriting: 4\nJoylashuv: Quadrant"
        ]
    },
    {
        "id": 45,
        "type": "code_writing",
        "metadata": {
            "category": "metod-xususiyatlari",
            "subcategory": "params arrays"
        },
        "prompt": "### 5. `params` va `switch` yordamida oddiy kalkulyator\n\n`Calculate(string operation, params double[] values)` metodini yarating:\n\nQo'llab-quvvatlanadigan operatsiyalar:\n- `\"sum\"` - barcha qiymatlarni qo'shish\n- `\"average\"` - o'rtacha qiymat\n- `\"max\"` - eng katta qiymat\n- `\"min\"` - eng kichik qiymat\n\n`switch` expressiondan foydalaning va edge caselarni handle qiling (bo'sh array, noto'g'ri operatsiya).\n\nKonsol dasturida foydalanuvchidan operatsiya va sonlarni kiritishni so'rang.",
        "examples": [
            "Operatsiyani kiriting: sum\nQiymatlarni probel bilan ajratib kiriting: 3 5 2\nNatija: 10",
            "Operatsiyani kiriting: average\nQiymatlarni probel bilan ajratib kiriting: 4 8\nNatija: 6"
        ]
    },
    {
        "id": 46,
        "type": "mcq",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "queue"
        },
        "codeBefore": "```csharp\nvar list = new List<int> { 1, 2, 3, 4, 5 };\nvar queue = new Queue<int>(list);\nvar result = queue.Dequeue();\n```",
        "codeAfter": "",
        "prompt": "`Queue<T>` FIFO tartibda ishlaydi. Yuqoridagi kodda `result` ning qiymati nima bo'ladi?",
        "options": [
            {
                "id": "A",
                "option": "`1`"
            },
            {
                "id": "B",
                "option": "`5`"
            },
            {
                "id": "C",
                "option": "`0`"
            },
            {
                "id": "D",
                "option": "Exception"
            }
        ],
        "answer": [
            "A"
        ],
        "explanation": "Queue<T> FIFO (First In, First Out) kolleksiya. List dan yaratilganda elementlar tartib saqlanadi va Dequeue() birinchi element (1) ni qaytaradi."
    },
    {
        "id": 47,
        "type": "mcq",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "dictionary"
        },
        "codeBefore": "```csharp\nvar dict = new Dictionary<string, int>\n{\n    [\"apple\"] = 5,\n    [\"banana\"] = 3\n};\ndict.TryAdd(\"apple\", 10);\nConsole.WriteLine(dict[\"apple\"]);\n```",
        "codeAfter": "",
        "prompt": "`Dictionary<TKey, TValue>` da `TryAdd` metodining xususiyati nimada? Natija nima bo'ladi?",
        "options": [
            {
                "id": "A",
                "option": "`10` - chunki yangi qiymat qo'shiladi"
            },
            {
                "id": "B",
                "option": "`5` - chunki mavjud key ni update qilmaydi"
            },
            {
                "id": "C",
                "option": "Exception - chunki duplicate key"
            },
            {
                "id": "D",
                "option": "`15` - chunki qiymatlar qo'shiladi"
            }
        ],
        "answer": [
            "B"
        ],
        "explanation": "TryAdd metodi mavjud key uchun hech narsa qilmaydi va false qaytaradi. 'apple' key allaqachon mavjud bo'lgani uchun qiymati 5 bo'lib qoladi."
    },
    {
        "id": 48,
        "type": "mcq",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "indexing slicing"
        },
        "codeBefore": "```csharp\nvar numbers = new int[] { 1, 2, 3, 4, 5 };\nvar lastTwo = numbers[^2..];\nConsole.WriteLine(string.Join(\", \", lastTwo));\n```",
        "codeAfter": "",
        "prompt": "Index (`^`) va Range (`..`) operatorlaridan foydalanilgan kodda natija qanday bo'ladi?",
        "options": [
            {
                "id": "A",
                "option": "`4, 5`"
            },
            {
                "id": "B",
                "option": "`3, 4`"
            },
            {
                "id": "C",
                "option": "`2, 3, 4, 5`"
            },
            {
                "id": "D",
                "option": "`5`"
            }
        ],
        "answer": [
            "A"
        ],
        "explanation": "^2 degani oxirdan 2 ta oldin (index 3, qiymat 4), .. degani oxirigacha. Natijada oxirgi 2 ta element: 4, 5."
    },
    {
        "id": 49,
        "type": "mcq",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "memory types"
        },
        "codeBefore": "```csharp\nspan<int> span = stackalloc int[3] { 1, 2, 3 };\nReadOnlySpan<int> readOnlySpan = span;\nvar memory = span.ToArray().AsMemory();\n```",
        "codeAfter": "",
        "prompt": "`Span<T>` va `Memory<T>` haqida qaysi fikr **to'g'ri**?",
        "options": [
            {
                "id": "A",
                "option": "`Span<T>` faqat stack da ishlaydi"
            },
            {
                "id": "B",
                "option": "`Memory<T>` heap va stack ikkalasida ham ishlaydi"
            },
            {
                "id": "C",
                "option": "`ReadOnlySpan<T>` dan `Span<T>` ga implicit cast mumkin"
            },
            {
                "id": "D",
                "option": "`Memory<T>` ref struct hisoblanadi"
            }
        ],
        "answer": [
            "B"
        ],
        "explanation": "Memory<T> heap va stack ikkalasida ham ishlaydi va async metodlarda ishlatish mumkin, Span<T>dan farqli o'laroq u ref struct emas."
    },
    {
        "id": 50,
        "type": "mcq",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "set operations"
        },
        "codeBefore": "```csharp\nvar hashSet = new HashSet<int> { 1, 2, 3 };\nvar list = new List<int> { 2, 3, 4, 5 };\nhashSet.IntersectWith(list);\n```",
        "codeAfter": "",
        "prompt": "`HashSet<T>.IntersectWith()` operatsiyasidan keyin `hashSet` da qanday elementlar qoladi?",
        "options": [
            {
                "id": "A",
                "option": "`{ 1, 2, 3, 4, 5 }`"
            },
            {
                "id": "B",
                "option": "`{ 2, 3 }`"
            },
            {
                "id": "C",
                "option": "`{ 1 }`"
            },
            {
                "id": "D",
                "option": "`{ 4, 5 }`"
            }
        ],
        "answer": [
            "B"
        ],
        "explanation": "IntersectWith matematik intersection operatsiyasi - faqat ikkala to'plamda ham mavjud elementlar qoladi: 2 va 3."
    },
    {
        "id": 51,
        "type": "mcq",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "stack"
        },
        "codeBefore": "```csharp\nvar stack = new Stack<string>();\nstack.Push(\"first\");\nstack.Push(\"second\");\nvar result = stack.Peek();\nstack.Pop();\nConsole.WriteLine($\"{result}, {stack.Count}\");\n```",
        "codeAfter": "",
        "prompt": "`Stack<T>` LIFO prinsipi bo'yicha ishlaydi. Yuqoridagi kodda natija nima?",
        "options": [
            {
                "id": "A",
                "option": "`first, 1`"
            },
            {
                "id": "B",
                "option": "`second, 1`"
            },
            {
                "id": "C",
                "option": "`second, 0`"
            },
            {
                "id": "D",
                "option": "`first, 0`"
            }
        ],
        "answer": [
            "B"
        ],
        "explanation": "Stack LIFO: Peek() oxirgi qo'shilgan 'second' ni qaytaradi (olib tashlamaydi), keyin Pop() uni olib tashlaydi. Count = 1 qoladi."
    },
    {
        "id": 52,
        "type": "mcq",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "indexing slicing"
        },
        "codeBefore": "```csharp\nvar numbers = new int[] { 10, 20, 30, 40, 50 };\nvar range = 1..^1;\nvar slice = numbers[range];\n```",
        "codeAfter": "",
        "prompt": "Range operatori `1..^1` nimani anglatadi va `slice` da qanday qiymatlar bo'ladi?",
        "options": [
            {
                "id": "A",
                "option": "1-indexdan oxirgi elementgacha: `{ 20, 30, 40, 50 }`"
            },
            {
                "id": "B",
                "option": "1-indexdan oxirgi elementni hisobga olmaganda: `{ 20, 30, 40 }`"
            },
            {
                "id": "C",
                "option": "Faqat 1-index: `{ 20 }`"
            },
            {
                "id": "D",
                "option": "Kompilyatsiya xatosi"
            }
        ],
        "answer": [
            "B"
        ],
        "explanation": "1..^1 degani index 1 dan (20) boshlab, oxirgi elementgacha (exclusive). ^1 oxirgi element pozitsiyasi, lekin range da exclusive. Natija: {20, 30, 40}."
    },
    {
        "id": 53,
        "type": "mcq",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "lookup"
        },
        "codeBefore": "```csharp\nvar lookup = new string[] { \"a\", \"bb\", \"ccc\", \"a\", \"bb\" }\n    .ToLookup(x => x.Length);\nvar result = lookup[2].Count();\n```",
        "codeAfter": "",
        "prompt": "`ILookup<TKey, TElement>` haqida qaysi fikr to'g'ri va yuqoridagi kodda `result` nima?",
        "options": [
            {
                "id": "A",
                "option": "Lookup bir key uchun bitta value saqlaydi, result = 1"
            },
            {
                "id": "B",
                "option": "Lookup bir key uchun ko'p value saqlaydi, result = 2"
            },
            {
                "id": "C",
                "option": "Lookup faqat unique valuelar saqlaydi, result = 1"
            },
            {
                "id": "D",
                "option": "Exception - key topilmadi"
            }
        ],
        "answer": [
            "B"
        ],
        "explanation": "ILookup one-to-many mapping. Length=2 uchun 'bb' 2 marta mavjud, shuning uchun Count()=2."
    },
    {
        "id": 54,
        "type": "mcq",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "memory types"
        },
        "codeBefore": "```csharp\nSpan<byte> buffer = stackalloc byte[1024];\nvar memory = new Memory<byte>(new byte[1024]);\nvar span1 = buffer.Slice(10, 100);\nvar span2 = memory.Span.Slice(10, 100);\n```",
        "codeAfter": "",
        "prompt": "`Span<T>.Slice()` va `Memory<T>.Span` haqida qaysi fikr **noto'g'ri**?",
        "options": [
            {
                "id": "A",
                "option": "`Slice()` yangi Span yaratadi, copy emas"
            },
            {
                "id": "B",
                "option": "`Memory<T>.Span` property orqali Span olish mumkin"
            },
            {
                "id": "C",
                "option": "`span1` stack da, `span2` heap da joylashgan"
            },
            {
                "id": "D",
                "option": "`Slice()` operatsiyasi xotira allocate qiladi"
            }
        ],
        "answer": [
            "D"
        ],
        "explanation": "Slice() operatsiyasi yangi xotira allocate qilmaydi - faqat mavjud memory ga yangi view (ko'rinish) yaratadi. Bu zero-copy operatsiya."
    },
    {
        "id": 55,
        "type": "mcq",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "priority queue"
        },
        "codeBefore": "```csharp\nvar priorityQueue = new PriorityQueue<string, int>();\npriorityQueue.Enqueue(\"task1\", 3);\npriorityQueue.Enqueue(\"task2\", 1);\npriorityQueue.Enqueue(\"task3\", 2);\nvar result = priorityQueue.Dequeue();\n```",
        "codeAfter": "",
        "prompt": "`PriorityQueue<TElement, TPriority>` eng kichik priority ni birinchi chiqaradi. `result` nima bo'ladi?",
        "options": [
            {
                "id": "A",
                "option": "`task1`"
            },
            {
                "id": "B",
                "option": "`task2`"
            },
            {
                "id": "C",
                "option": "`task3`"
            },
            {
                "id": "D",
                "option": "Exception"
            }
        ],
        "answer": [
            "B"
        ],
        "explanation": "PriorityQueue min-heap - eng kichik priority birinchi chiqadi. task2 ning priority si 1 (eng kichik), shuning uchun birinchi chiqadi."
    },
    {
        "id": 56,
        "type": "true_false",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "dictionary"
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "`Dictionary<TKey, TValue>` da key uchun `null` qiymat qo'yish mumkin, agar `TKey` nullable type bo'lsa.",
        "answer": "true",
        "explanation": "To'g'ri. Agar TKey nullable type bo'lsa (masalan, string? yoki int?), Dictionary null key qabul qiladi."
    },
    {
        "id": 57,
        "type": "true_false",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "set operations"
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "`HashSet<T>` collection elementlarning unique bo'lishini kafolatlaydi va tartibni saqlaydi.",
        "answer": "false",
        "explanation": "Yolg'on. HashSet uniqueness kafolatlaydi, lekin insertion tartibini saqlamaydi. Tartib uchun SortedSet ishlatiladi."
    },
    {
        "id": 58,
        "type": "true_false",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "indexing slicing"
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "Index operator `^0` massivning oxirgi elementini anglatadi.",
        "answer": "false",
        "explanation": "Yolg'on. ^0 massiv uzunligini bildiradi (bounds dan tashqarida). Oxirgi element ^1 bilan ko'rsatiladi."
    },
    {
        "id": 59,
        "type": "true_false",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "indexing slicing"
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "Range operator `..` faqat array va string uchun ishlatiladi, boshqa collectionlar uchun emas.",
        "answer": "false",
        "explanation": "Yolg'on. Range operator (..) indexer qo'llab-quvvatlaydigan barcha collection lar uchun ishlatiladi (List<T>, Span<T> va h.k.)."
    },
    {
        "id": 60,
        "type": "true_false",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "memory types"
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "`Span<T>` ref struct bo'lgani uchun heap da saqlanishi mumkin emas.",
        "answer": "true",
        "explanation": "To'g'ri. Span<T> ref struct bo'lib, faqat stack da saqlanadi. Heap da saqlash uchun Memory<T> ishlatiladi."
    },
    {
        "id": 61,
        "type": "true_false",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "memory types"
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "`Memory<T>` async metodlarda ishlatish mumkin, lekin `Span<T>` ishlatib bo'lmaydi.",
        "answer": "true",
        "explanation": "To'g'ri. Memory<T> async/await bilan ishlaydi, lekin Span<T> ref struct bo'lgani uchun async metodlarda ishlatib bo'lmaydi."
    },
    {
        "id": 62,
        "type": "true_false",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "thread safety"
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "`Queue<T>` va `Stack<T>` ikkalasi ham generic collection bo'lib, thread-safe emas.",
        "answer": "true",
        "explanation": "To'g'ri. Queue<T> va Stack<T> thread-safe emas. Multi-threading uchun ConcurrentQueue<T> va ConcurrentStack<T> ishlatiladi."
    },
    {
        "id": 63,
        "type": "true_false",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "sorted collections"
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "`SortedDictionary<TKey, TValue>` elementlarni key bo'yicha tartiblab saqlaydi.",
        "answer": "true",
        "explanation": "To'g'ri. SortedDictionary elementlarni key bo'yicha avtomatik tartiblab saqlaydi, insertion order ga qaramay."
    },
    {
        "id": 64,
        "type": "true_false",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "indexing slicing"
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "Range operator `numbers[2..]` 2-indexdan boshlab oxirigacha bo'lgan elementlarni oladi.",
        "answer": "true",
        "explanation": "To'g'ri. [2..] degani 2-indexdan boshlab oxirigacha bo'lgan barcha elementlar (2-index ham kiritiladi)."
    },
    {
        "id": 65,
        "type": "true_false",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "list types"
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "`LinkedList<T>` collection random access ni qo'llab-quvvatlaydi va indexer operator `[]` ga ega.",
        "answer": "false",
        "explanation": "Yolg'on. LinkedList<T> sequential access collection bo'lib, indexer operator [] ga ega emas. Random access uchun List<T> ishlatiladi."
    },
    {
        "id": 66,
        "type": "true_false",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "memory types"
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "`ReadOnlySpan<T>` dan `Span<T>` ga implicit conversion mumkin.",
        "answer": "false",
        "explanation": "Yolg'on. ReadOnlySpan<T> immutable, Span<T> mutable. Readonly dan writable ga implicit conversion mumkin emas."
    },
    {
        "id": 67,
        "type": "true_false",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "memory types"
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "`CollectionsMarshal.AsSpan()` metodi `List<T>` ni `Span<T>` ga xavfsiz tarzda convert qiladi.",
        "answer": "true",
        "explanation": "To'g'ri. CollectionsMarshal.AsSpan() List<T> ning ichki array ga xavfsiz access beradi va Span<T> sifatida qaytaradi."
    },
    {
        "id": 68,
        "type": "true_false",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "collection expressions"
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "Spread operator `..` C# 12 da collection expressions uchun ishlatiladi.",
        "answer": "true",
        "explanation": "To'g'ri. C# 12 da spread operator (..) collection expressions ichida existing collections ni spread qilish uchun ishlatiladi."
    },
    {
        "id": 69,
        "type": "true_false",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "thread safety"
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "`ConcurrentDictionary<TKey, TValue>` thread-safe bo'lib, lock-free operatsiyalarni qo'llab-quvvatlaydi.",
        "answer": "true",
        "explanation": "To'g'ri. ConcurrentDictionary internal lock-free algorithm ishlatib, thread-safe operatsiyalarni ta'minlaydi."
    },
    {
        "id": 70,
        "type": "true_false",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "memory types"
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "`Memory<T>` va `ReadOnlyMemory<T>` ikkalasi ham ref struct hisoblanadi.",
        "answer": "false",
        "explanation": "Yolg'on. Memory<T> va ReadOnlyMemory<T> oddiy struct lar. Faqat Span<T> va ReadOnlySpan<T> ref struct hisoblanadi."
    },
    {
        "id": 71,
        "type": "fill",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "list operations"
        },
        "codeWithBlank": "var numbers = new List<int> { 1, 2, 3, 4, 5 };\nvar result = numbers.GetRange(______, ______);\n// result should be { 2, 3, 4 }",
        "prompt": "`List<T>.GetRange(int index, int count)` metodida bo'sh joylarni to'ldiring, shunda natija `{ 2, 3, 4 }` bo'lsin.",
        "answer": "var numbers = new List<int> { 1, 2, 3, 4, 5 };\nvar result = numbers.GetRange(1, 3);\n// result should be { 2, 3, 4 }",
        "explanation": "Elements 2, 3, 4 index 1 dan boshlanadi va 3 ta element kerak: GetRange(1, 3)."
    },
    {
        "id": 72,
        "type": "fill",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "dictionary"
        },
        "codeWithBlank": "var dict = new Dictionary<string, int> { [\"a\"] = 1, [\"b\"] = 2 };\nvar success = dict.________(\"c\", ______);\n// Agar key mavjud bo'lmasa, default qiymat qaytarsin",
        "prompt": "`Dictionary<TKey, TValue>` da key mavjud bo'lmasa default qiymat qaytaradigan metod va qiymatni yozing.",
        "answer": "var dict = new Dictionary<string, int> { [\"a\"] = 1, [\"b\"] = 2 };\nvar success = dict.TryGetValue(\"c\", out var value);\n// Agar key mavjud bo'lmasa, default qiymat qaytarsin",
        "explanation": "TryGetValue metodі safe access ta'minlaydi: success false, value default qiymat bo'ladi."
    },
    {
        "id": 73,
        "type": "fill",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "indexing slicing"
        },
        "codeWithBlank": "var text = \"Hello World\";\nvar slice = text[______];\n// slice should be \"World\"",
        "prompt": "String dan \"World\" so'zini olish uchun Range operatorini yozing.",
        "answer": "var text = \"Hello World\";\nvar slice = text[6..];\n// slice should be \"World\"",
        "explanation": "'World' index 6 dan boshlanadi: text[6..] = 'World'."
    },
    {
        "id": 74,
        "type": "fill",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "memory types"
        },
        "codeWithBlank": "Span<int> span = stackalloc int[5];\nspan.Fill(________);\nvar slice = span.Slice(______, ______);\n// Fill with 42, then get middle 3 elements",
        "prompt": "`Span<T>` ni 42 bilan to'ldiring va o'rtadagi 3 ta elementni oling.",
        "answer": "Span<int> span = stackalloc int[5];\nspan.Fill(42);\nvar slice = span.Slice(1, 3);\n// Fill with 42, then get middle 3 elements",
        "explanation": "Fill(42) barcha elementlarni 42 ga o'rnatadi. O'rtadagi 3 element: index 1 dan 3 ta - Slice(1, 3)."
    },
    {
        "id": 75,
        "type": "fill",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "priority queue"
        },
        "codeWithBlank": "var queue = new PriorityQueue<string, int>();\nqueue.Enqueue(\"low\", ______);\nqueue.Enqueue(\"high\", ______);\n// \"high\" should be dequeued first",
        "prompt": "`PriorityQueue` da \"high\" birinchi chiqishi uchun priority qiymatlarini yozing.",
        "answer": "var queue = new PriorityQueue<string, int>();\nqueue.Enqueue(\"low\", 10);\nqueue.Enqueue(\"high\", 1);\n// \"high\" should be dequeued first",
        "explanation": "PriorityQueue min-heap: kichik raqam yuqori priority. 'high' birinchi chiqishi uchun 1 (kichik), 'low' uchun 10 (katta)."
    },
    {
        "id": 76,
        "type": "fill",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "set operations"
        },
        "codeWithBlank": "var hashSet1 = new HashSet<int> { 1, 2, 3 };\nvar hashSet2 = new HashSet<int> { 3, 4, 5 };\nhashSet1.________(hashSet2);\n// Result: { 1, 2, 3, 4, 5 }",
        "prompt": "Ikki `HashSet` ni birlashtirib, barcha unique elementlarni olish uchun metod nomini yozing.",
        "answer": "var hashSet1 = new HashSet<int> { 1, 2, 3 };\nvar hashSet2 = new HashSet<int> { 3, 4, 5 };\nhashSet1.UnionWith(hashSet2);\n// Result: { 1, 2, 3, 4, 5 }",
        "explanation": "UnionWith matematik union operatsiyasi - ikkala to'plamning barcha unique elementlarini birlashtirib, hashSet1 ni o'zgartiradi."
    },
    {
        "id": 77,
        "type": "fill",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "collection expressions"
        },
        "codeWithBlank": "var list1 = new List<int> { 1, 2 };\nvar list2 = new List<int> { 3, 4 };\nvar combined = [______];\n// Use collection expression with spread",
        "prompt": "C# 12 collection expression da spread operator yordamida ikki listni birlashtiring.",
        "answer": "var list1 = new List<int> { 1, 2 };\nvar list2 = new List<int> { 3, 4 };\nvar combined = [..list1, ..list2];\n// Use collection expression with spread",
        "explanation": "Collection expression da .. spread operator existing collection larni expand qiladi: [..list1, ..list2] = [1, 2, 3, 4]."
    },
    {
        "id": 78,
        "type": "fill",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "memory types"
        },
        "codeWithBlank": "var numbers = new int[] { 1, 2, 3, 4, 5 };\nvar memory = numbers.AsMemory();\nvar slice = memory.Slice(______, ______);\n// Get elements 2, 3, 4",
        "prompt": "`Memory<T>` dan elementlar 2, 3, 4 ni olish uchun `Slice` parametrlarini yozing.",
        "answer": "var numbers = new int[] { 1, 2, 3, 4, 5 };\nvar memory = numbers.AsMemory();\nvar slice = memory.Slice(1, 3);\n// Get elements 2, 3, 4",
        "explanation": "Elements 2, 3, 4 index 1 dan boshlanadi va 3 ta element: Memory.Slice(1, 3)."
    },
    {
        "id": 79,
        "type": "fill",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "sorted collections"
        },
        "codeWithBlank": "var sortedDict = new SortedDictionary<int, string>();\nsortedDict.Add(3, \"three\");\nsortedDict.Add(1, \"one\");\nsortedDict.Add(2, \"two\");\nvar firstKey = sortedDict.________.________;\n// Get the first key",
        "prompt": "`SortedDictionary` da birinchi key ni olish uchun property chain ni yozing.",
        "answer": "var sortedDict = new SortedDictionary<int, string>();\nsortedDict.Add(3, \"three\");\nsortedDict.Add(1, \"one\");\nsortedDict.Add(2, \"two\");\nvar firstKey = sortedDict.Keys.First();\n// Get the first key",
        "explanation": "SortedDictionary avtomatik tartiblab saqlaydi. Keys property sorted keys collection, First() birinchi key (1) ni qaytaradi."
    },
    {
        "id": 80,
        "type": "fill",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "memory types"
        },
        "codeWithBlank": "ReadOnlySpan<char> text = \"Hello\";\nvar index = text.IndexOf(________);\nif (index >= 0)\n{\n    var found = text[index];\n}",
        "prompt": "`ReadOnlySpan<char>` da 'l' harfini qidirish uchun parametrni yozing.",
        "answer": "ReadOnlySpan<char> text = \"Hello\";\nvar index = text.IndexOf('l');\nif (index >= 0)\n{\n    var found = text[index];\n}",
        "explanation": "IndexOf() metodi char parameter qabul qiladi. Single quotes bilan character literal 'l' ishlatiladi."
    },
    {
        "id": 81,
        "type": "error_spotting",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "memory types"
        },
        "codeWithError": "var list = new List<int> { 1, 2, 3, 4, 5 };\nvar span = list.AsSpan();\nlist.Add(6);\nConsole.WriteLine(span.Length);",
        "prompt": "`List<T>` ga element qo'shgandan so'ng `Span<T>` ishlatishda xatolik bor. Xatoni toping va tushuntiring.",
        "answer": "var list = new List<int> { 1, 2, 3, 4, 5 };\nvar span = CollectionsMarshal.AsSpan(list);\n// list.Add(6); // Bu dangerous - span invalid bo'ladi\nConsole.WriteLine(span.Length);",
        "explanation": "List ga element qo'shish internal array ni reallocate qilishi mumkin, span invalid bo'ladi. CollectionsMarshal ishlatib, list ni modify qilmaslik kerak."
    },
    {
        "id": 82,
        "type": "error_spotting",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "dictionary"
        },
        "codeWithError": "var dict = new Dictionary<string?, int>();\ndict.Add(null, 1);\ndict.Add(null, 2);\nConsole.WriteLine(dict.Count);",
        "prompt": "`Dictionary` da `null` key bilan bog'liq xatolikni toping va to'g'rilang.",
        "answer": "var dict = new Dictionary<string?, int>();\ndict.Add(null, 1);\n// dict.Add(null, 2); // Exception - duplicate key\ndict[null] = 2; // Bu to'g'ri - key ni update qiladi\nConsole.WriteLine(dict.Count);",
        "explanation": "Add() metodi duplicate key uchun exception beradi, null ham key hisoblanadi. Update uchun indexer [] ishlatiladi."
    },
    {
        "id": 83,
        "type": "error_spotting",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "indexing slicing"
        },
        "codeWithError": "var numbers = new int[] { 1, 2, 3, 4, 5 };\nvar range = 2..^0;\nvar slice = numbers[range];\nConsole.WriteLine(slice.Length);",
        "prompt": "Range operatorida xatolik bor. `^0` nima anglatadi va qanday to'g'rilash kerak?",
        "answer": "var numbers = new int[] { 1, 2, 3, 4, 5 };\nvar range = 2..^1; // ^0 is beyond end, ^1 is last element\nvar slice = numbers[range];\nConsole.WriteLine(slice.Length);",
        "explanation": "^0 array length pozitsiyasi (bounds dan tashqari). Range uchun ^1 ishlatiladi (oxirgi element, exclusive boundary)."
    },
    {
        "id": 84,
        "type": "error_spotting",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "memory types"
        },
        "codeWithError": "async Task ProcessAsync()\n{\n    Span<byte> buffer = stackalloc byte[1024];\n    await SomeAsyncMethod(buffer);\n}",
        "prompt": "`Span<T>` ni async metod ichida ishlatishdagi xatolikni toping va to'g'rilang.",
        "answer": "async Task ProcessAsync()\n{\n    Memory<byte> buffer = new byte[1024];\n    await SomeAsyncMethod(buffer);\n    // Yoki: var buffer = new byte[1024].AsMemory();\n}",
        "explanation": "Span<T> ref struct bo'lib, async metodlarda ishlatib bo'lmaydi. Memory<T> async-safe alternative hisoblanadi."
    },
    {
        "id": 85,
        "type": "error_spotting",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "queue"
        },
        "codeWithError": "var queue = new Queue<int>();\nqueue.Enqueue(1);\nqueue.Enqueue(2);\nvar result = queue.Peek();\nqueue.Clear();\nvar next = queue.Peek();",
        "prompt": "Bo'sh `Queue` dan element olishdagi xatolikni toping va to'g'rilang.",
        "answer": "var queue = new Queue<int>();\nqueue.Enqueue(1);\nqueue.Enqueue(2);\nvar result = queue.Peek();\nqueue.Clear();\nvar next = queue.Count > 0 ? queue.Peek() : 0; // Check before peek",
        "explanation": "Bo'sh Queue dan Peek() InvalidOperationException beradi. Count > 0 check qilib, safe access ta'minlash kerak."
    },
    {
        "id": 86,
        "type": "error_spotting",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "collection expressions"
        },
        "codeWithError": "var numbers = new List<int> { 1, 2, 3 };\nvar combined = [numbers, 4, 5];\nConsole.WriteLine(combined.Count);",
        "prompt": "Collection expression da spread operatorisiz ishlatishdagi xatolikni toping.",
        "answer": "var numbers = new List<int> { 1, 2, 3 };\nvar combined = [..numbers, 4, 5]; // Need spread operator\nConsole.WriteLine(combined.Count);",
        "explanation": "Collection expression da existing collection ni spread qilmasdan embed qilib bo'lmaydi. [..numbers, 4, 5] syntax kerak."
    },
    {
        "id": 87,
        "type": "error_spotting",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "memory types"
        },
        "codeWithError": "ReadOnlySpan<int> span = new int[] { 1, 2, 3 };\nspan[0] = 10;\nConsole.WriteLine(span[0]);",
        "prompt": "`ReadOnlySpan<T>` da elementni o'zgartirishdagi xatolikni toping.",
        "answer": "Span<int> span = new int[] { 1, 2, 3 }; // Use Span<T> instead\nspan[0] = 10;\nConsole.WriteLine(span[0]);",
        "explanation": "ReadOnlySpan<T> immutable - elementlarni o'zgartirib bo'lmaydi. Mutable operation uchun Span<T> ishlatiladi."
    },
    {
        "id": 88,
        "type": "error_spotting",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "stack"
        },
        "codeWithError": "var stack = new Stack<string>();\nstack.Push(\"first\");\nstack.Push(\"second\");\nvar items = stack.ToArray();\nConsole.WriteLine(items[0]);",
        "prompt": "`Stack<T>.ToArray()` metodining natijasida elementlar tartibini to'g'ri tushuntiring.",
        "answer": "var stack = new Stack<string>();\nstack.Push(\"first\");\nstack.Push(\"second\");\nvar items = stack.ToArray();\n// items[0] is \"second\" (LIFO order)\nConsole.WriteLine(items[0]); // Prints \"second\"",
        "explanation": "ToArray() LIFO tartibni saqlaydi: oxirgi push qilingan element array ning birinchi elementi bo'ladi."
    },
    {
        "id": 89,
        "type": "error_spotting",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "indexing slicing"
        },
        "codeWithError": "var text = \"Hello World\";\nvar slice = text[5..^5];\nConsole.WriteLine(slice);",
        "prompt": "String slicing da index va range xatoligini toping va to'g'rilang.",
        "answer": "var text = \"Hello World\";\nvar slice = text[6..^0]; // Start from 6 (space after Hello), go to end\n// Or: var slice = text[6..]; for \"World\"\nConsole.WriteLine(slice);",
        "explanation": "\"Hello World\" uzunligi 11. [5..^5] = [5..6] = \" \" (faqat space). \"World\" uchun [6..] kerak."
    },
    {
        "id": 90,
        "type": "error_spotting",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "memory types"
        },
        "codeWithError": "var memory = new Memory<int>();\nvar span = memory.Span;\nspan[0] = 42;\nConsole.WriteLine(span[0]);",
        "prompt": "Bo'sh `Memory<T>` dan `Span<T>` olish va ishlatishdagi xatolikni toping.",
        "answer": "var memory = new Memory<int>(new int[10]); // Initialize with array\nvar span = memory.Span;\nspan[0] = 42;\nConsole.WriteLine(span[0]);",
        "explanation": "Default Memory<T>() constructor bo'sh memory yaratadi. Array bilan initialize qilish kerak: new Memory<int>(new int[10])."
    },
    {
        "id": 91,
        "type": "output_prediction",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "dictionary"
        },
        "snippet": "var dict = new Dictionary<int, string> { [1] = \"one\", [2] = \"two\" };\ndict.TryAdd(1, \"ONE\");\ndict.TryAdd(3, \"three\");\nConsole.WriteLine($\"{dict[1]}, {dict.Count}\");",
        "prompt": "`Dictionary.TryAdd()` metodi mavjud key uchun qanday ishlaydi?",
        "answer": "one, 3",
        "explanation": "TryAdd mavjud key (1) ni update qilmaydi, faqat yangi key (3) ni qo'shadi. dict[1] = \"one\" qoladi, Count = 3."
    },
    {
        "id": 92,
        "type": "output_prediction",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "indexing slicing"
        },
        "snippet": "var numbers = new int[] { 10, 20, 30, 40, 50 };\nvar slice1 = numbers[1..4];\nvar slice2 = numbers[^3..^1];\nConsole.WriteLine($\"{slice1.Length}, {slice2.Length}\");",
        "prompt": "Range operatorlari bilan slice olishda uzunliklar qanday bo'ladi?",
        "answer": "3, 2",
        "explanation": "slice1[1..4] = {20,30,40} (length=3), slice2[^3..^1] = {30,40} (index 2..4, length=2)."
    },
    {
        "id": 93,
        "type": "output_prediction",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "set operations"
        },
        "snippet": "var hashSet = new HashSet<int> { 1, 2, 3, 1, 2 };\nConsole.WriteLine(hashSet.Count);\nvar list = new List<int> { 1, 2, 3, 1, 2 };\nConsole.WriteLine(list.Count);",
        "prompt": "`HashSet` va `List` da duplicate elementlar qanday ishlanadi?",
        "answer": "3\n5",
        "explanation": "HashSet faqat unique elementlarni saqlaydi (Count=3), List barcha elementlarni saqlaydi including duplicates (Count=5)."
    },
    {
        "id": 94,
        "type": "output_prediction",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "memory types"
        },
        "snippet": "Span<int> span = stackalloc int[3] { 1, 2, 3 };\nspan.Reverse();\nvar array = span.ToArray();\nConsole.WriteLine(string.Join(\", \", array));",
        "prompt": "`Span<T>.Reverse()` metodining natijasi qanday bo'ladi?",
        "answer": "3, 2, 1",
        "explanation": "Reverse() span ni in-place reverse qiladi: {1,2,3} → {3,2,1}. ToArray() reversed contentni array ga convert qiladi."
    },
    {
        "id": 95,
        "type": "output_prediction",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "queue"
        },
        "snippet": "var queue = new Queue<char>();\nforeach (char c in \"ABC\")\n    queue.Enqueue(c);\nwhile (queue.Count > 0)\n    Console.Write(queue.Dequeue());",
        "prompt": "`Queue<T>` FIFO tartibda elementlarni qanday chiqaradi?",
        "answer": "ABC",
        "explanation": "Queue FIFO: birinchi kiritilgan (A) birinchi chiqadi. Enqueue order: A→B→C, Dequeue order: A→B→C."
    },
    {
        "id": 96,
        "type": "output_prediction",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "stack"
        },
        "snippet": "var stack = new Stack<char>();\nforeach (char c in \"ABC\")\n    stack.Push(c);\nwhile (stack.Count > 0)\n    Console.Write(stack.Pop());",
        "prompt": "`Stack<T>` LIFO tartibda elementlarni qanday chiqaradi?",
        "answer": "CBA",
        "explanation": "Stack LIFO: oxirgi kiritilgan (C) birinchi chiqadi. Push order: A→B→C, Pop order: C→B→A."
    },
    {
        "id": 97,
        "type": "output_prediction",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "collection expressions"
        },
        "snippet": "var list1 = new List<int> { 1, 2 };\nvar list2 = new List<int> { 3, 4 };\nvar combined = [..list1, 5, ..list2];\nConsole.WriteLine(string.Join(\", \", combined));",
        "prompt": "Collection expression da spread operator qanday ishlaydi?",
        "answer": "1, 2, 5, 3, 4",
        "explanation": "Collection expression left-to-right evaluate: ..list1 (1,2), then 5, then ..list2 (3,4) = [1,2,5,3,4]."
    },
    {
        "id": 98,
        "type": "output_prediction",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "priority queue"
        },
        "snippet": "var priorityQueue = new PriorityQueue<string, int>();\npriorityQueue.Enqueue(\"C\", 3);\npriorityQueue.Enqueue(\"A\", 1);\npriorityQueue.Enqueue(\"B\", 2);\nConsole.WriteLine(priorityQueue.Dequeue());",
        "prompt": "`PriorityQueue` eng kichik priority ni birinchi chiqaradi. Natija nima?",
        "answer": "A",
        "explanation": "PriorityQueue min-heap: eng kichik priority (1) birinchi chiqadi. \"A\" ning priority si 1 - eng kichik."
    },
    {
        "id": 99,
        "type": "output_prediction",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "memory types"
        },
        "snippet": "ReadOnlySpan<char> text = \"Hello World\";\nvar index = text.LastIndexOf('l');\nConsole.WriteLine($\"{index}, {text[index]}\");",
        "prompt": "`ReadOnlySpan<char>` da oxirgi 'l' harfining indexi va qiymati?",
        "answer": "9, l",
        "explanation": "\"Hello World\" da 'l' lar: index 2, 3, 9. LastIndexOf() oxirgi occurrence (index 9) ni qaytaradi."
    },
    {
        "id": 100,
        "type": "output_prediction",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "memory types"
        },
        "snippet": "var memory = \"Hello\".AsMemory();\nvar span = memory.Span;\nvar slice = span[1..^1];\nConsole.WriteLine(slice.ToString());",
        "prompt": "String dan `Memory<T>` va `Span<T>` orqali slice olishda natija?",
        "answer": "ell",
        "explanation": "\"Hello\" → Memory → Span → slice[1..^1] = [1..4] = \"ell\" (index 1 dan 4 gacha, oxirgi char ni exclude qilib)."
    },
    {
        "id": 101,
        "type": "code_writing",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "system design"
        },
        "prompt": "### Generic Collection Manager\n\n`CollectionManager<T>` generic klassi yarating. Bu klass quyidagi collectionlarni boshqarsin:\n- `List<T>` - asosiy saqlash uchun\n- `HashSet<T>` - unique elementlar uchun\n- `Queue<T>` - FIFO operatsiyalar uchun\n\nMetodlar:\n- `AddItem(T item)` - barcha collectionlarga qo'shadi\n- `RemoveItem(T item)` - barcha collectionlardan olib tashlaydi\n- `GetUniqueCount()` - unique elementlar sonini qaytaradi\n- `GetNextInQueue()` - queue dan keyingi elementni oladi\n\n`where T : IEquatable<T>` constraint ishlating.",
        "examples": [
            "var manager = new CollectionManager<int>();\nmanager.AddItem(1);\nmanager.AddItem(1); // duplicate\nConsole.WriteLine(manager.GetUniqueCount()); // 1"
        ]
    },
    {
        "id": 102,
        "type": "code_writing",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "array operations"
        },
        "prompt": "### Array Slicer with Range/Index\n\n`ArraySlicer` static klassi yarating. Quyidagi metodlarni implement qiling:\n- `GetSlice<T>(T[] array, Range range)` - Range operatori bilan slice oladi\n- `GetFromEnd<T>(T[] array, Index index)` - Oxiridan sanab index oladi\n- `GetMiddle<T>(T[] array)` - O'rtadagi elementlar (1/4 dan 3/4 gacha)\n- `SplitArray<T>(T[] array, int parts)` - Arrayni teng qismlarga bo'ladi\n\nHar bir metod appropriate range/index operatorlarini ishlating.",
        "examples": [
            "var numbers = new[] { 1, 2, 3, 4, 5, 6, 7, 8 };\nvar middle = ArraySlicer.GetMiddle(numbers); // { 3, 4, 5, 6 }\nvar fromEnd = ArraySlicer.GetFromEnd(numbers, ^2); // 7"
        ]
    },
    {
        "id": 103,
        "type": "code_writing",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "memory management"
        },
        "prompt": "### Memory-Efficient Buffer Processor\n\n`BufferProcessor` klassi yarating. Katta massivlar bilan ishlash uchun `Memory<T>` va `Span<T>` dan foydalaning:\n\n- `ProcessChunks<T>(Memory<T> memory, int chunkSize, Action<Span<T>> processor)`\n- `FindPattern<T>(ReadOnlyMemory<T> memory, ReadOnlySpan<T> pattern) where T : IEquatable<T>`\n- `ReverseInPlace<T>(Memory<T> memory)`\n- `CopyWithTransform<T>(ReadOnlyMemory<T> source, Memory<T> destination, Func<T, T> transform)`\n\nStackalloc va heap allocation ni optimal tarzda ishlating.",
        "examples": [
            "var data = new int[1000].AsMemory();\nprocessor.ProcessChunks(data, 100, chunk => {\n    // Process each 100-element chunk\n});"
        ]
    },
    {
        "id": 104,
        "type": "code_writing",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "data storage systems"
        },
        "prompt": "### Multi-Collection Data Store\n\n`DataStore<T>` klassi yarating, quyidagilarni implement qiling:\n- `Dictionary<string, T>` - key-value storage\n- `SortedDictionary<DateTime, T>` - chronological storage\n- `PriorityQueue<T, int>` - priority-based processing\n\nMetodlar:\n- `Store(string key, T value, int priority = 0)`\n- `GetByKey(string key)` - dictionary dan\n- `GetByTimeRange(DateTime start, DateTime end)` - time range bo'yicha\n- `ProcessNext()` - priority queue dan\n- `GetStatistics()` - har bir collection bo'yicha ma'lumot\n\nTurli collection typelarining xususiyatlarini to'g'ri ishlating.",
        "examples": [
            "var store = new DataStore<string>();\nstore.Store(\"task1\", \"Important task\", priority: 1);\nstore.Store(\"task2\", \"Urgent task\", priority: 10);\nvar next = store.ProcessNext(); // \"Important task\" (lower priority first)"
        ]
    },
    {
        "id": 105,
        "type": "code_writing",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "modern collection features"
        },
        "prompt": "### Collection Expression Builder\n\nC# 12 collection expressions va spread operator ishlatib `CollectionBuilder` static klassi yarating:\n\n- `Combine<T>(params IEnumerable<T>[] collections)` - spread bilan birlashtirishc\n- `Interleave<T>(IEnumerable<T> first, IEnumerable<T> second)` - elementlarni navbatma-navbat\n- `CreateRange(int start, int count, int step = 1)` - arithmetic progression\n- `FilterAndCombine<T>(Func<T, bool> predicate, params IEnumerable<T>[] collections)`\n\nCollection expressions `[..]` sintaksisini ishlatib, performance optimized bo'lsin.",
        "examples": [
            "var list1 = [1, 2, 3];\nvar list2 = [4, 5, 6];\nvar combined = CollectionBuilder.Combine(list1, list2); // [1, 2, 3, 4, 5, 6]\nvar range = CollectionBuilder.CreateRange(0, 5, 2); // [0, 2, 4, 6, 8]"
        ]
    },
    {
        "id": 106,
        "type": "mcq",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "basic linq operations"
        },
        "codeBefore": "```csharp\nvar numbers = new[] { 1, 2, 3, 4, 5, 6 };\nvar result = numbers\n    .Where(x => x % 2 == 0)\n    .Select(x => x * x)\n    .Sum();\n```",
        "codeAfter": "",
        "prompt": "LINQ chain operatsiyalari: juft sonlarni tanlab, kvadratga ko'tarib, yig'indisini hisoblamoqda. `result` nima bo'ladi?",
        "options": [
            {
                "id": "A",
                "option": "`56` - (2² + 4² + 6² = 4 + 16 + 36)"
            },
            {
                "id": "B",
                "option": "`36` - faqat 6²"
            },
            {
                "id": "C",
                "option": "`91` - barcha sonlarning kvadrati yig'indisi"
            },
            {
                "id": "D",
                "option": "`12` - juft sonlar yig'indisi"
            }
        ],
        "answer": [
            "A"
        ],
        "explanation": "Where(x => x % 2 == 0): [2,4,6] → Select(x => x * x): [4,16,36] → Sum(): 56"
    },
    {
        "id": 107,
        "type": "mcq",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "grouping operations"
        },
        "codeBefore": "```csharp\nvar students = new[]\n{\n    new { Name = \"Ali\", Grade = 85 },\n    new { Name = \"Bobur\", Grade = 92 },\n    new { Name = \"Zara\", Grade = 78 }\n};\nvar result = students\n    .GroupBy(s => s.Grade >= 80 ? \"High\" : \"Low\")\n    .ToDictionary(g => g.Key, g => g.Count());\n```",
        "codeAfter": "",
        "prompt": "Students ni grade bo'yicha grouping qilib, har guruhda nechta student borligini hisoblamoqda. `result` nima?",
        "options": [
            {
                "id": "A",
                "option": "`{ \"High\": 2, \"Low\": 1 }` - 80+ va 80- bo'yicha guruhlash"
            },
            {
                "id": "B",
                "option": "`{ \"High\": 1, \"Low\": 2 }` - teskari hisoblash"
            },
            {
                "id": "C",
                "option": "`{ \"85\": 1, \"92\": 1, \"78\": 1 }` - har grade bo'yicha"
            },
            {
                "id": "D",
                "option": "Exception - anonymous type bilan muammo"
            }
        ],
        "answer": [
            "A"
        ],
        "explanation": "GroupBy key: Grade≥80 ? \"High\" : \"Low\" → Ali,Bobur: High(2), Zara: Low(1)"
    },
    {
        "id": 108,
        "type": "mcq",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "set operations"
        },
        "codeBefore": "```csharp\nvar list1 = new[] { 1, 2, 3, 4 };\nvar list2 = new[] { 3, 4, 5, 6 };\nvar union = list1.Union(list2).OrderBy(x => x);\nvar intersect = list1.Intersect(list2);\nConsole.WriteLine($\"{union.Count()}, {intersect.Count()}\");\n```",
        "codeAfter": "",
        "prompt": "Set operatsiyalari: `Union` barcha unique elementlar, `Intersect` umumiy elementlar. Natija?",
        "options": [
            {
                "id": "A",
                "option": "`6, 2` - union: {1,2,3,4,5,6}, intersect: {3,4}"
            },
            {
                "id": "B",
                "option": "`8, 4` - barcha elementlar va duplicate"
            },
            {
                "id": "C",
                "option": "`4, 2` - faqat birinchi array"
            },
            {
                "id": "D",
                "option": "`6, 0` - intersection yo'q"
            }
        ],
        "answer": [
            "A"
        ],
        "explanation": "Union: {1,2,3,4,5,6} unique = 6 elements, Intersect: {3,4} common = 2 elements"
    },
    {
        "id": 109,
        "type": "mcq",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "sorting operations"
        },
        "codeBefore": "```csharp\nvar data = new[] { \"apple\", \"banana\", \"apricot\", \"cherry\" };\nvar result = data\n    .Where(x => x.StartsWith(\"a\"))\n    .OrderByDescending(x => x.Length)\n    .ThenBy(x => x)\n    .First();\n```",
        "codeAfter": "",
        "prompt": "Multi-level sorting: avval uzunlik bo'yicha kamayish, keyin alfavit bo'yicha o'sish. Birinchi element?",
        "options": [
            {
                "id": "A",
                "option": "`\"apricot\"` - eng uzun 'a' bilan boshlanuvchi"
            },
            {
                "id": "B",
                "option": "`\"apple\"` - alfabetik jihatdan birinchi"
            },
            {
                "id": "C",
                "option": "`\"banana\"` - eng uzun"
            },
            {
                "id": "D",
                "option": "Exception - 'a' bilan boshlanuvchi yo'q"
            }
        ],
        "answer": [
            "A"
        ],
        "explanation": "Where('a'): [apple,apricot] → OrderByDescending(length): apricot(7), apple(5) → First(): apricot"
    },
    {
        "id": 110,
        "type": "mcq",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "query syntax"
        },
        "codeBefore": "```csharp\nvar query = from n in Enumerable.Range(1, 10)\n            let square = n * n\n            where square % 2 == 0\n            select new { Number = n, Square = square };\nvar result = query.Take(3).Sum(x => x.Square);\n```",
        "codeAfter": "",
        "prompt": "Query syntax: `let` keyword va deferred execution. Birinchi 3 ta juft kvadratning yig'indisi?",
        "options": [
            {
                "id": "A",
                "option": "`56` - (4 + 16 + 36 from 2², 4², 6²)"
            },
            {
                "id": "B",
                "option": "`30` - (1² + 2² + 3² ning jufti)"
            },
            {
                "id": "C",
                "option": "`20` - (2 + 4 + 6)²"
            },
            {
                "id": "D",
                "option": "`84` - barcha juft kvadratlar"
            }
        ],
        "answer": [
            "A"
        ],
        "explanation": "Range(1,10) → let square → where even squares: [4,16,36,64,100] → Take(3): [4,16,36] → Sum: 56"
    },
    {
        "id": 111,
        "type": "true_false",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "operation semantics"
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "LINQ da `Where().Select()` chain `Select().Where()` bilan bir xil natija beradi, faqat performance farq qilishi mumkin.",
        "answer": "false",
        "explanation": "Yolg'on. Where() va Select() commutative emas. Where(condition).Select(transform) ≠ Select(transform).Where(condition) chunki condition original value lar uchun, transform uchun emas."
    },
    {
        "id": 112,
        "type": "true_false",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "execution behavior"
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "`IEnumerable<T>` da LINQ operatsiyalari deferred execution qo'llaydi, ya'ni `ToList()` chaqirilgunga qadar execute bo'lmaydi.",
        "answer": "true",
        "explanation": "To'g'ri. LINQ operatsiyalari deferred (lazy) execution ishlatadi. Query definition vaqtida execute bo'lmaydi, balki enumeration (ToList, foreach, Count) paytida execute bo'ladi."
    },
    {
        "id": 113,
        "type": "true_false",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "grouping operations"
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "`GroupBy()` metodi natijasi `IGrouping<TKey, TElement>` tipidagi elementlardan iborat `IEnumerable` qaytaradi.",
        "answer": "true",
        "explanation": "To'g'ri. GroupBy() natijasi IEnumerable<IGrouping<TKey, TElement>> qaytaradi. Har bir IGrouping bir group ni represents qiladi va Key property va elements ga access beradi."
    },
    {
        "id": 114,
        "type": "true_false",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "element selection"
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "`First()` va `FirstOrDefault()` farqi shundaki, birinchisi exception beradi, ikkinchisi default qiymat qaytaradi.",
        "answer": "true",
        "explanation": "To'g'ri. First() bo'sh collection yoki condition match qilmaydigan holda InvalidOperationException beradi. FirstOrDefault() default(T) qaytaradi."
    },
    {
        "id": 115,
        "type": "true_false",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "provider support"
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "LINQ query syntax faqat `IEnumerable<T>` bilan ishlaydi, `IQueryable<T>` bilan ishlatib bo'lmaydi.",
        "answer": "false",
        "explanation": "Yolg'on. LINQ query syntax IQueryable<T> bilan ham ishlaydi. Bu LINQ to SQL, Entity Framework va boshqa query provider lar uchun juda muhim."
    },
    {
        "id": 116,
        "type": "fill",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "basic linq chain"
        },
        "codeWithBlank": "var numbers = new[] { 1, 2, 3, 4, 5 };\nvar result = numbers\n    .________(x => x > 2)\n    .________(x => x * 2)\n    .________();\n// Result should be [6, 8, 10]",
        "prompt": "LINQ chain: 2 dan katta sonlarni filterlash, 2 ga ko'paytirish, array ga aylantirish.",
        "answer": "var numbers = new[] { 1, 2, 3, 4, 5 };\nvar result = numbers\n    .Where(x => x > 2)\n    .Select(x => x * 2)\n    .ToArray();\n// Result should be [6, 8, 10]",
        "explanation": "Where(filtering) → Select(transformation) → ToArray(materialization) chain pattern."
    },
    {
        "id": 117,
        "type": "fill",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "grouping and aggregation"
        },
        "codeWithBlank": "var words = new[] { \"hello\", \"world\", \"linq\", \"query\" };\nvar grouped = words\n    .________(w => w.Length)\n    .________(g => g.Key, g => g.______());\n// Group by length, then create dictionary with counts",
        "prompt": "So'zlarni uzunlik bo'yicha guruhlab, har guruhda nechta element borligini dictionary sifatida qaytaring.",
        "answer": "var words = new[] { \"hello\", \"world\", \"linq\", \"query\" };\nvar grouped = words\n    .GroupBy(w => w.Length)\n    .ToDictionary(g => g.Key, g => g.Count());\n// Group by length, then create dictionary with counts",
        "explanation": "GroupBy(length) creates groups → ToDictionary(key, count) creates Dictionary<int, int>."
    },
    {
        "id": 118,
        "type": "fill",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "pagination and filtering"
        },
        "codeWithBlank": "var source = Enumerable.Range(1, 100);\nvar result = source\n    .________(10)        // Skip first 10\n    .________(5)         // Take next 5\n    .________(x => x % 2 == 1)  // Only odd numbers\n    .Sum();",
        "prompt": "Pagination va filtering: birinchi 10 tani o'tkazib yuborish, keyingi 5 tani olish, faqat toqlarini yig'ish.",
        "answer": "var source = Enumerable.Range(1, 100);\nvar result = source\n    .Skip(10)        // Skip first 10\n    .Take(5)         // Take next 5\n    .Where(x => x % 2 == 1)  // Only odd numbers\n    .Sum();",
        "explanation": "Skip(10) → Take(5) → Where(odd) → Sum(): pagination keyin filtering, oxirida aggregation."
    },
    {
        "id": 119,
        "type": "fill",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "quantifier methods"
        },
        "codeWithBlank": "var people = new[]\n{\n    new { Name = \"Ali\", Age = 25 },\n    new { Name = \"Sara\", Age = 30 }\n};\nvar result = people\n    .________(p => p.Age > 20)\n    .________(p => ________);\n// Check if any person older than 20, then check if all are older than 18",
        "prompt": "Quantifier methods: biror kishi 20 yoshdan katta bo'lsa, barcha kishilar 18 dan katta ekanligini tekshiring.",
        "answer": "var people = new[]\n{\n    new { Name = \"Ali\", Age = 25 },\n    new { Name = \"Sara\", Age = 30 }\n};\nvar hasOlder = people.Any(p => p.Age > 20);\nvar allAdults = people.All(p => p.Age > 18);\n// Check if any person older than 20, then check if all are older than 18",
        "explanation": "Any(condition) checks existence, All(condition) checks universal truth. Separate variables for clarity."
    },
    {
        "id": 120,
        "type": "fill",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "join operations"
        },
        "codeWithBlank": "var customers = new[] { \"Alice\", \"Bob\", \"Charlie\" };\nvar orders = new[] { \"Alice\", \"Alice\", \"Bob\", \"David\" };\nvar result = customers\n    .________(orders, c => c, o => o, (c, orderGroup) => \n        new { Customer = c, OrderCount = orderGroup.________ });\n// Group join to count orders per customer",
        "prompt": "Group join: har bir customer uchun order sonini hisoblash. Ba'zi customerlarning orderi yo'q bo'lishi mumkin.",
        "answer": "var customers = new[] { \"Alice\", \"Bob\", \"Charlie\" };\nvar orders = new[] { \"Alice\", \"Alice\", \"Bob\", \"David\" };\nvar result = customers\n    .GroupJoin(orders, c => c, o => o, (c, orderGroup) => \n        new { Customer = c, OrderCount = orderGroup.Count() });\n// Group join to count orders per customer",
        "explanation": "GroupJoin() creates left join with grouped results. Count() calculates orders per customer, including zero."
    },
    {
        "id": 121,
        "type": "error_spotting",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "deferred execution"
        },
        "codeWithError": "var numbers = new[] { 1, 2, 3, 4, 5 };\nvar query = numbers.Where(x => x > 2);\nnumbers[0] = 10;\nvar result = query.ToList();\nConsole.WriteLine(result.Count);",
        "prompt": "Deferred execution muammosi: query yaratilgandan keyin source data o'zgardi. Natija qanday bo'ladi?",
        "answer": "var numbers = new[] { 1, 2, 3, 4, 5 };\nvar query = numbers.Where(x => x > 2);\n// query hali execute bo'lmagan (deferred)\nnumbers[0] = 10;  // source data o'zgardi\nvar result = query.ToList();  // endi execute bo'ladi: [10, 3, 4, 5]\nConsole.WriteLine(result.Count);  // 4",
        "explanation": "Deferred execution: query creation vaqtida execute bo'lmaydi, ToList() chaqirilganda execute bo'ladi va o'zgartrilgan source data ishlatiladi."
    },
    {
        "id": 122,
        "type": "error_spotting",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "pipeline correctness"
        },
        "codeWithError": "var data = new[] { 1, 2, 3 };\nvar result = data\n    .Select(x => x * 2)\n    .Where(x => x > 3)\n    .First();\n// Should get first element > 3 after doubling",
        "prompt": "LINQ chain mantiqan to'g'ri, lekin qiymatlarni tekshirib ko'ring. 4 dan katta birinchi element topiladi?",
        "answer": "var data = new[] { 1, 2, 3 };\nvar result = data\n    .Select(x => x * 2)    // [2, 4, 6]\n    .Where(x => x > 3)     // [4, 6]\n    .First();              // 4\n// Natija: 4 (to'g'ri ishlaydi)",
        "explanation": "Bu 'trick question' - kod aslida to'g'ri ishlaydi. Select(x2): [2,4,6] → Where(>3): [4,6] → First(): 4."
    },
    {
        "id": 123,
        "type": "error_spotting",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "enumeration safety"
        },
        "codeWithError": "var items = new List<int> { 1, 2, 3, 4, 5 };\nforeach (var item in items.Where(x => x % 2 == 0))\n{\n    items.Remove(item);\n}\nConsole.WriteLine(items.Count);",
        "prompt": "Collection modification during enumeration xatosi. LINQ query execute bo'layotganda source collection o'zgartirilmoqda.",
        "answer": "var items = new List<int> { 1, 2, 3, 4, 5 };\n// To'g'ri yondashuv: avval natijani materialize qiling\nvar toRemove = items.Where(x => x % 2 == 0).ToList();\nforeach (var item in toRemove)\n{\n    items.Remove(item);\n}\nConsole.WriteLine(items.Count);",
        "explanation": "Collection modification during enumeration InvalidOperationException beradi. Avval ToList() qilib materialize qilish kerak."
    },
    {
        "id": 124,
        "type": "error_spotting",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "element selection"
        },
        "codeWithError": "var numbers = new[] { 1, 2, 3 };\nvar result = numbers\n    .GroupBy(x => x % 2)\n    .Select(g => g.Sum())\n    .Single();",
        "prompt": "`Single()` method faqat bitta element bo'lgan collection uchun ishlatiladi. Bu yerda nechta group bor?",
        "answer": "var numbers = new[] { 1, 2, 3 };\nvar result = numbers\n    .GroupBy(x => x % 2)    // 2 ta group: {0: [2], 1: [1,3]}\n    .Select(g => g.Sum())   // [2, 4]\n    .ToArray();             // Single() o'rniga ToArray() yoki First()/Last()\n// Single() exception beradi chunki 2 ta element bor",
        "explanation": "GroupBy(x % 2) 2 ta group yaratadi (even va odd). Single() faqat 1 ta element kutadi, 2 ta bo'lgani uchun exception beradi."
    },
    {
        "id": 125,
        "type": "error_spotting",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "null safety"
        },
        "codeWithError": "var words = new[] { \"apple\", \"banana\", null, \"cherry\" };\nvar result = words\n    .Where(w => w.Length > 5)\n    .Count();",
        "prompt": "Null reference exception: array da `null` element bor va `Length` property access qilinmoqda.",
        "answer": "var words = new[] { \"apple\", \"banana\", null, \"cherry\" };\nvar result = words\n    .Where(w => w != null && w.Length > 5)  // Null check kerak\n    .Count();\n// Yoki: .Where(w => w?.Length > 5)",
        "explanation": "Null element da Length property access NullReferenceException beradi. Null check yoki safe navigation operator kerak."
    },
    {
        "id": 126,
        "type": "output_prediction",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "selectmany operations"
        },
        "snippet": "var numbers = new[] { 1, 2, 3, 4, 5 };\nvar result = numbers\n    .SelectMany(x => Enumerable.Repeat(x, x))\n    .Sum();\nConsole.WriteLine(result);",
        "prompt": "`SelectMany` har raqamni o'sha raqam marta takrorlaydi. Masalan, 3 ni 3 marta: [3,3,3]. Yig'indi?",
        "answer": "30",
        "explanation": "1→[1], 2→[2,2], 3→[3,3,3], 4→[4,4,4,4], 5→[5,5,5,5,5] flatten→[1,2,2,3,3,3,4,4,4,4,5,5,5,5,5] Sum=30"
    },
    {
        "id": 127,
        "type": "output_prediction",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "character analysis"
        },
        "snippet": "var data = \"hello world\";\nvar result = data\n    .Where(c => char.IsLetter(c))\n    .GroupBy(c => c)\n    .OrderByDescending(g => g.Count())\n    .First()\n    .Key;\nConsole.WriteLine(result);",
        "prompt": "String dagi eng ko'p uchraydigan harfni topish. `hello world` da qaysi harf eng ko'p?",
        "answer": "l",
        "explanation": "\"hello world\" letters: h,e,l,l,o,w,o,r,l,d → 'l' appears 3 times (most frequent) → Key='l'"
    },
    {
        "id": 128,
        "type": "output_prediction",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "zip operations"
        },
        "snippet": "var list1 = new[] { 1, 2, 3 };\nvar list2 = new[] { 2, 3, 4 };\nvar result = list1.Zip(list2, (a, b) => a + b).ToArray();\nConsole.WriteLine(string.Join(\", \", result));",
        "prompt": "`Zip` method ikki collection elementlarini juftlab birlashtiradi. Har juftikning yig'indisi?",
        "answer": "3, 5, 7",
        "explanation": "Zip pairs: (1,2)→3, (2,3)→5, (3,4)→7 → string.Join(\", \") → \"3, 5, 7\""
    },
    {
        "id": 129,
        "type": "output_prediction",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "conditional operations"
        },
        "snippet": "var numbers = new[] { 5, 2, 8, 1, 9 };\nvar result = numbers\n    .TakeWhile(x => x != 8)\n    .Concat(numbers.SkipWhile(x => x != 8).Skip(1))\n    .ToArray();\nConsole.WriteLine(string.Join(\", \", result));",
        "prompt": "8 raqamini olib tashlash: 8 gacha olib, 8 dan keyingilarni olib, birlashtirish. Natija?",
        "answer": "5, 2, 1, 9",
        "explanation": "TakeWhile(≠8): [5,2] + SkipWhile(≠8).Skip(1): skip [5,2,8], then skip 1 more → [1,9] = [5,2,1,9]"
    },
    {
        "id": 130,
        "type": "output_prediction",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "nested flattening"
        },
        "snippet": "var ranges = new[] { \n    Enumerable.Range(1, 3), \n    Enumerable.Range(4, 2) \n};\nvar flattened = ranges.SelectMany(r => r).Sum();\nConsole.WriteLine(flattened);",
        "prompt": "`SelectMany` nested IEnumerable larni flatten qiladi. Range(1,3)=[1,2,3], Range(4,2)=[4,5]. Yig'indi?",
        "answer": "15",
        "explanation": "Range(1,3)→[1,2,3], Range(4,2)→[4,5] → SelectMany flatten→[1,2,3,4,5] → Sum=15"
    },
    {
        "id": 131,
        "type": "code_writing",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "data analysis projects"
        },
        "prompt": "### LINQ ma'lumotlar tahlili dasturi\n\nStudent ma'lumotlari bilan ishlaydigan konsol dasturini yozing.\n\n`Student` record yarating: `Name`, `Age`, `Grade`, `Subject` maydonlari bilan.\n\nQuyidagi LINQ operatsiyalarini implement qiling:\n- Barcha studentlarni grade bo'yicha guruhlab, har guruhda nechta student borligini chiqarish\n- Eng yosh va eng katta yoshdagi studentlarni topib chiqarish\n- Ma'lum subject bo'yicha o'rtacha grade ni hisoblash\n- Grade 80+ bo'lgan studentlarni name bo'yicha tartiblash\n\nDeferred execution va immediate execution farqini ko'rsating.",
        "examples": [
            "Students by grade groups:\nA: 3 students\nB: 5 students\n\nAge range: Min=18, Max=25\nMath average grade: 87.5"
        ]
    },
    {
        "id": 132,
        "type": "code_writing",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "text analysis projects"
        },
        "prompt": "### LINQ bilan matn tahlili\n\nMatn faylini tahlil qiladigan dastur yozing (yoki hardcoded string ishlating).\n\nQuyidagi funksiyalarni LINQ bilan implement qiling:\n- Eng uzun so'zni topish\n- Har harfning necha marta uchrashini hisoblash\n- Palindrom so'zlarni topish  \n- So'zlarni uzunlik bo'yicha guruhlab, har guruhdan eng kichik alfabetik tartibdagisini olish\n\nQuery syntax va method syntax ikkalasidan ham foydalaning.\n\n`SelectMany`, `GroupBy`, `OrderBy`, `Where` metodlarini ishlating.",
        "examples": [
            "Text: \"hello world level deed\"\nLongest word: world (5 letters)\nPalindromes: level, deed\nLetter 'l' appears 3 times"
        ]
    },
    {
        "id": 133,
        "type": "code_writing",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "business logic projects"
        },
        "prompt": "### LINQ bilan e-commerce ma'lumotlari\n\n`Product`, `Order`, `Customer` recordlarini yarating.\n\nQuyidagi business logikani LINQ bilan yozing:\n- Eng ko'p sotilgan 5 ta mahsulot\n- Har bir customer ning jami xarid summasi\n- Oylik sotuvlar statistikasi (group by month)\n- Hech narsa sotib olmagan customerlar ro'yxati\n\n`Join`, `GroupJoin`, `Aggregate`, `Sum` metodlaridan foydalaning.\n\nNull safety va edge caselarni handle qiling (bo'sh collections, null values).",
        "examples": [
            "Top products:\n1. Laptop - 15 orders\n2. Phone - 12 orders\n\nCustomer spending:\nAli: $1,250\nSara: $890"
        ]
    },
    {
        "id": 134,
        "type": "code_writing",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "performance optimization"
        },
        "prompt": "### LINQ Performance Comparison\n\nKatta collection lar bilan ishlash uchun performance test dasturini yozing.\n\nQuyidagilarni taqqoslang:\n- `Where().Count()` vs `Count(predicate)`\n- `Where().First()` vs `First(predicate)`  \n- `ToList().Where()` vs `Where().ToList()`\n- Deferred vs Immediate execution\n\n`Stopwatch` ishlatib, execution time ni o'lchang.\n\n1 million elementli `List<int>` yarating va turli LINQ operatsiyalarini test qiling.\n\nNatijalarni console ga formatted holda chiqaring.",
        "examples": [
            "Performance Test Results:\nWhere().Count(): 145ms\nCount(predicate): 98ms\n\nDeferred query creation: 0ms\nImmediate execution: 234ms"
        ]
    },
    {
        "id": 135,
        "type": "code_writing",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "extension methods"
        },
        "prompt": "### Custom LINQ Extension Methods\n\nO'zingizning LINQ extension methodlarini yarating:\n\n- `Batch<T>(this IEnumerable<T> source, int size)` - elementlarni chunk larga bo'lish\n- `DistinctBy<T, TKey>(this IEnumerable<T> source, Func<T, TKey> keySelector)` - key bo'yicha unique\n- `ForEach<T>(this IEnumerable<T> source, Action<T> action)` - har elementga action apply qilish\n- `IsEmpty<T>(this IEnumerable<T> source)` - collection bo'sh ekanligini tekshirish\n\nHar bir extension method uchun:\n- Null checking\n- Deferred execution (kerak bo'lsa)\n- `yield return` ishlatish\n- Generic constraints (kerak bo'lsa)\n\nTest kodini ham yozing.",
        "examples": [
            "var numbers = Enumerable.Range(1, 10);\nvar batches = numbers.Batch(3).ToList();\n// Result: [[1,2,3], [4,5,6], [7,8,9], [10]]\n\nvar people = GetPeople();\nvar unique = people.DistinctBy(p => p.Email);"
        ]
    },
    {
        "id": 136,
        "type": "mcq",
        "metadata": {
            "category": "exception-handling",
            "subcategory": "try-catch basics"
        },
        "codeBefore": "```csharp\ntry\n{\n    int result = int.Parse(\"abc\");\n    Console.WriteLine(result);\n}\ncatch (FormatException ex)\n{\n    Console.WriteLine(\"Format error\");\n}\ncatch (Exception ex)\n{\n    Console.WriteLine(\"General error\");\n}\n```",
        "codeAfter": "",
        "prompt": "Yuqoridagi kodda qaysi catch block ishlaydi?",
        "options": [
            {
                "id": "A",
                "option": "FormatException catch block"
            },
            {
                "id": "B",
                "option": "Exception catch block"
            },
            {
                "id": "C",
                "option": "Ikkala catch block ham"
            },
            {
                "id": "D",
                "option": "Hech qaysi catch block"
            }
        ],
        "answer": [
            "A"
        ],
        "explanation": "int.Parse(\"abc\") FormatException tashlay, va FormatException uchun aniq catch block mavjud bo'lgani uchun u ishlatiladi."
    },
    {
        "id": 137,
        "type": "true_false",
        "metadata": {
            "category": "exception-handling",
            "subcategory": "exception best practices"
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "Exception handling performance overhead yaratadi va ularni oddiy control flow uchun ishlatmaslik kerak.",
        "answer": "true",
        "explanation": "Exception lar expensive operatsiya hisoblanadi va faqat haqiqiy error holatlar uchun ishlatilishi kerak, oddiy control flow uchun emas."
    },
    {
        "id": 138,
        "type": "fill",
        "metadata": {
            "category": "exception-handling",
            "subcategory": "try-catch syntax"
        },
        "codeWithBlank": "try\n{\n    int.Parse(\"invalid\");\n}\n______ (FormatException ex)\n{\n    Console.WriteLine(\"Format error: \" + ex.Message);\n}\n______ (Exception ex)\n{\n    Console.WriteLine(\"General error: \" + ex.Message);\n}",
        "prompt": "Try-catch strukturasini to'ldiring. Exception larni catch qilish uchun kerakli kalit so'zni yozing.",
        "answer": "try\n{\n    int.Parse(\"invalid\");\n}\ncatch (FormatException ex)\n{\n    Console.WriteLine(\"Format error: \" + ex.Message);\n}\ncatch (Exception ex)\n{\n    Console.WriteLine(\"General error: \" + ex.Message);\n}",
        "explanation": "Catch kalit so'zi exception larni ushlash uchun ishlatiladi. Har bir catch block ma'lum exception turini handle qiladi."
    },
    {
        "id": 139,
        "type": "error_spotting",
        "metadata": {
            "category": "exception-handling",
            "subcategory": "catch block order"
        },
        "codeWithError": "try\n{\n    int.Parse(\"abc\");\n}\ncatch (Exception ex)  // General exception first\n{\n    Console.WriteLine(\"General error\");\n}\ncatch (FormatException ex)  // Specific exception after - ERROR!\n{\n    Console.WriteLine(\"Format error\");\n}",
        "prompt": "Catch block tartibida xato bor. Compiler error beradi. Tuzating.",
        "answer": "try\n{\n    int.Parse(\"abc\");\n}\ncatch (FormatException ex)  // Specific exception first\n{\n    Console.WriteLine(\"Format error\");\n}\ncatch (Exception ex)  // General exception after\n{\n    Console.WriteLine(\"General error\");\n}",
        "explanation": "Aniq exception turlar umumiy turlardan oldin kelishi kerak. Exception eng umumiy tur bo'lgani uchun oxirida bo'lishi kerak."
    },
    {
        "id": 140,
        "type": "output_prediction",
        "metadata": {
            "category": "exception-handling",
            "subcategory": "exception flow"
        },
        "snippet": "try\n{\n    throw new ArgumentNullException(\"param\");\n}\ncatch (ArgumentException ex)\n{\n    Console.Write(\"Argument\");\n}\ncatch (ArgumentNullException ex)\n{\n    Console.Write(\"Null\");\n}\ncatch (Exception ex)\n{\n    Console.Write(\"General\");\n}\nConsole.Write(\"End\");",
        "prompt": "ArgumentNullException inheritance hierarchy: Exception > SystemException > ArgumentException > ArgumentNullException. Qaysi natija?",
        "answer": "ArgumentEnd",
        "explanation": "ArgumentNullException ArgumentException dan inherit qilgani uchun birinchi ArgumentException catch ishlaydi (first-match rule). Keyin \"End\" chiqadi."
    },
    {
        "id": 141,
        "type": "mcq",
        "metadata": {
            "category": "exception-handling",
            "subcategory": "Custom Exceptions"
        },
        "prompt": "C# da custom exception class yaratganda nima sodir bo'ladi?",
        "options": [
            {
                "id": "a",
                "option": "U System.Exception yoki uning subclasslaridan meros olishi kerak"
            },
            {
                "id": "b",
                "option": "U avtomatik ravishda stack trace ma'lumotlarini o'z ichiga oladi"
            },
            {
                "id": "c",
                "option": "U generic Exception handlerlar tomonidan ushlana oladi"
            },
            {
                "id": "d",
                "option": "Barchasi to'g'ri"
            }
        ],
        "answer": [
            "d"
        ],
        "explanation": "Custom exceptionlar Exception yoki uning subclasslaridan meros olishi kerak, avtomatik ravishda stack trace ma'lumotlarini o'z ichiga oladi va meros tufayli generic Exception handlerlar tomonidan ushlana oladi."
    },
    {
        "id": 142,
        "type": "true_false",
        "metadata": {
            "category": "exception-handling",
            "subcategory": "Finally Blocks"
        },
        "prompt": "Finally blok doimo bajariladi, hatto try blokda return statement bo'lsa ham.",
        "answer": "true",
        "explanation": "Finally blok try blok qanday chiqishidan qat'i nazar bajariladi - oddiy, return orqali yoki exception orqali. U tozalash maqsadlari uchun bajarilishi kafolatlanadi."
    },
    {
        "id": 143,
        "type": "fill",
        "metadata": {
            "category": "exception-handling",
            "subcategory": "Exception Filtering"
        },
        "codeWithBlank": "try\n{\n    // xavfli operatsiya\n}\ncatch (ArgumentException ex) _____ (ex.ParamName == \"userId\")\n{\n    // maxsus parametr exceptionni boshqarish\n}",
        "prompt": "Exception filtering uchun kerakli kalit so'zni kiriting:",
        "answer": "when",
        "explanation": "C# da exception filtering uchun 'when' kalit so'zi ishlatiladi. U catch blok bajarilishi uchun qo'shimcha shartlarni belgilash imkonini beradi."
    },
    {
        "id": 144,
        "type": "error_spotting",
        "metadata": {
            "category": "exception-handling",
            "subcategory": "Exception Re-throwing"
        },
        "codeWithError": "try\n{\n    SomeRiskyOperation();\n}\ncatch (Exception ex)\n{\n    LogError(ex);\n    throw ex;\n}",
        "prompt": "Ushbu exception *re-throw* kodida xatoni toping:",
        "answer": "Stack trace ni saqlab qolish uchun 'throw ex;' o'rniga 'throw;' ishlatish kerak",
        "explanation": "'throw ex;' ishlatish stack trace ni qayta o'rnatadi, asl call stack ma'lumotlarini yo'qotadi. Asl stack trace ni saqlab qolish uchun 'throw;' ishlatish kerak."
    },
    {
        "id": 145,
        "type": "output_prediction",
        "metadata": {
            "category": "exception-handling",
            "subcategory": "Exception Propagation"
        },
        "snippet": "try\n{\n    try\n    {\n        throw new ArgumentException(\"Inner\");\n    }\n    finally\n    {\n        Console.WriteLine(\"Inner finally\");\n    }\n}\ncatch (Exception ex)\n{\n    Console.WriteLine($\"Caught: {ex.Message}\");\n}\nfinally\n{\n    Console.WriteLine(\"Outer finally\");\n}",
        "prompt": "Ushbu kodning natijasi nima bo'ladi?",
        "answer": "Inner finally\nCaught: Inner\nOuter finally",
        "explanation": "Exception tashlanganida ichki finally blok birinchi bajariladi, keyin tashqi catch blok exception ni boshqaradi va nihoyat tashqi finally blok bajariladi."
    },
    {
        "id": 146,
        "type": "mcq",
        "metadata": {
            "category": "exception-handling",
            "subcategory": "Exception Hierarchy"
        },
        "prompt": "Quyidagi catch bloklardan qaysi biri to'g'ri tartibda joylashgan?",
        "options": [
            {
                "id": "a",
                "option": "catch (Exception) → catch (ArgumentException) → catch (ArgumentNullException)"
            },
            {
                "id": "b",
                "option": "catch (ArgumentNullException) → catch (ArgumentException) → catch (Exception)"
            },
            {
                "id": "c",
                "option": "catch (ArgumentException) → catch (Exception) → catch (ArgumentNullException)"
            },
            {
                "id": "d",
                "option": "Tartib muhim emas"
            }
        ],
        "answer": [
            "b"
        ],
        "explanation": "Catch bloklar eng maxsus (specific) dan eng umumiy (general) ga qarab tartiblanishi kerak. ArgumentNullException → ArgumentException → Exception to'g'ri tartibdir, chunki har biri keyingisining subclass'i."
    },
    {
        "id": 147,
        "type": "true_false",
        "metadata": {
            "category": "exception-handling",
            "subcategory": "Performance"
        },
        "prompt": "Exception'lar performance jihatdan qimmat operatsiyalar bo'lib, ular odatiy flow control uchun ishlatilmasligi kerak.",
        "answer": "true",
        "explanation": "Exception'lar stack trace yaratish va call stack'ni unwinding qilish tufayli performance jihatdan qimmat. Ular faqat haqiqiy xato holatlar uchun ishlatilishi kerak, oddiy flow control uchun emas."
    },
    {
        "id": 148,
        "type": "fill",
        "metadata": {
            "category": "exception-handling",
            "subcategory": "Custom Exception Constructors"
        },
        "codeWithBlank": "public class CustomException : Exception\n{\n    public CustomException(string message, Exception innerException)\n        : _____(message, innerException)\n    {\n    }\n}",
        "prompt": "Custom exception constructor'ida base class constructor'ini to'g'ri chaqiring:",
        "answer": "base",
        "explanation": "Custom exception'larda base class (Exception) constructor'ini chaqirish uchun 'base' kalit so'zi ishlatiladi. Bu message va inner exception'ni base class'ga o'tkazadi."
    },
    {
        "id": 149,
        "type": "error_spotting",
        "metadata": {
            "category": "exception-handling",
            "subcategory": "Exception Filtering Errors"
        },
        "codeWithError": "try\n{\n    ProcessData();\n}\ncatch (Exception ex) when (LogException(ex))\n{\n    // handle exception\n}\n\nbool LogException(Exception ex)\n{\n    Console.WriteLine($\"Error: {ex.Message}\");\n    return true;\n}",
        "prompt": "Ushbu exception filtering kodida qanday muammo bor?",
        "answer": "When clause'da side effect'li funksiyalar ishlatilmasligi kerak, LogException har doim chaqiriladi",
        "explanation": "When clause'da side effect'li operatsiyalar (logging, file yozish) ishlatilmasligi kerak. Bu holda LogException har doim chaqiriladi va exception handle qilinadi, bu kutilmagan behavior'ga olib keladi."
    },
    {
        "id": 150,
        "type": "output_prediction",
        "metadata": {
            "category": "exception-handling",
            "subcategory": "Using Statement Exception Handling"
        },
        "snippet": "public class TestResource : IDisposable\n{\n    public string Name { get; set; }\n    public void Dispose()\n    {\n        Console.WriteLine($\"Disposing {Name}\");\n    }\n}\n\ntry\n{\n    using (var resource = new TestResource { Name = \"Resource1\" })\n    {\n        Console.WriteLine(\"Using resource\");\n        throw new InvalidOperationException(\"Test error\");\n    }\n}\ncatch (Exception ex)\n{\n    Console.WriteLine($\"Caught: {ex.Message}\");\n}",
        "prompt": "Ushbu kodning natijasi nima bo'ladi?",
        "answer": "Using resource\nDisposing Resource1\nCaught: Test error",
        "explanation": "Using statement exception tashlanganida ham resurs dispose qilinishini kafolatlaydi. Avval 'Using resource' chop etiladi, keyin exception tashlanadi, using blok chiqishida 'Disposing Resource1' chop etiladi, va nihoyat catch blok exception'ni ushlaydi."
    }
]