[
    {
        "id": 1,
        "type": "mcq",
        "metadata": {
            "category": "asosiy-til-xususiyatlari",
            "subcategory": "pattern matching"
        },
        "codeBefore": "```csharp\nbool IsLong(string? s) => s switch\n{\n    null                  => false,\n    { Length: > 5 and < 10 } => true,\n    _                     => false\n};\n```",
        "codeAfter": "",
        "prompt": "Yuqoridagi **pattern matching** kodida qaysi method chaqiruvi `true` natija qaytaradi?\n\n**Eslatma:** Property pattern `{ Length: > 5 and < 10 }` string uzunligi 5 dan **katta** va 10 dan **kichik** bo'lgan holatlarda `true` qaytaradi.",
        "options": [
            {
                "id": "A",
                "option": "`IsLong(\"123456\")` - string uzunligi 6"
            },
            {
                "id": "B",
                "option": "`IsLong(\"1234567890\")` - string uzunligi 10"
            },
            {
                "id": "C",
                "option": "`IsLong(null!)` - null qiymat"
            },
            {
                "id": "D",
                "option": "`IsLong(\"abcd\")` - string uzunligi 4"
            }
        ],
        "answer": [
            "A"
        ],
        "explanation": "Property pattern `{ Length: > 5 and < 10 }` uzunligi 6-9 orasidagi stringlarni tanlaydi. A variant: string uzunligi 6 (5 < 6 < 10 ✓), B variant: uzunlik 10 (10 >= 10 ✗), C variant: null (false ✗), D variant: uzunlik 4 (4 <= 5 ✗)."
    },
    {
        "id": 2,
        "type": "mcq",
        "metadata": {
            "category": "metod-xususiyatlari",
            "subcategory": "parametrlar"
        },
        "codeBefore": "```csharp\nvoid M(in int x, out int y, params object[] rest) { }\n```",
        "codeAfter": "",
        "prompt": "Yuqoridagi method da turli **parameter** turlari mavjud:\n- `in` - **readonly** parameter (o'qish uchun)\n- `out` - **write-only** parameter (yozish uchun)\n- `params` - **variable argument** list\n\nQaysi method chaqiruvi **noto'g'ri** va **compilation error** beradi?",
        "options": [
            {
                "id": "A",
                "option": "`M(5, out var y)` - literal qiymat `in` parameter uchun"
            },
            {
                "id": "B",
                "option": "`int a = 1; M(a, out a)` - bir xil variable ni `in` va `out` uchun ishlatish"
            },
            {
                "id": "C",
                "option": "`M(in 5, out _, 1, 2)` - explicit `in` keyword va discard pattern"
            },
            {
                "id": "D",
                "option": "`M(5, out var y, \"x\", 3)` - `params` bilan qo'shimcha argumentlar"
            }
        ],
        "answer": [
            "B"
        ],
        "explanation": "Bir xil variable ni bir method chaqiruvida ham `in` (readonly) ham `out` (write-only) parameter sifatida ishlatib bo'lmaydi. Bu logik contradiction yaratadi va compiler error beradi. A: literal `in` ga valid ✓, C: explicit `in` keyword valid ✓, D: `params` qo'shimcha argumentlar qabul qiladi ✓."
    },
    {
        "id": 3,
        "type": "mcq",
        "metadata": {
            "category": "asosiy-til-xususiyatlari",
            "subcategory": "records"
        },
        "codeBefore": "```csharp\npublic record Point(int X, int Y);\nvar p = new Point(1,2) with { Y = 3 };\n```",
        "codeAfter": "",
        "prompt": "Yuqoridagi **positional record** `Point` haqida qaysi gap **noto'g'ri**?\n\n**Eslatma:** Positional recordlar avtomatik property, constructor, equality comparison va `with` expression support beradi.",
        "options": [
            {
                "id": "A",
                "option": "Agar ikki `Point` objectining `X` va `Y` qiymatlari bir xil bo'lsa, ular **value equality** asosida teng hisoblanadi"
            },
            {
                "id": "B",
                "option": "Record typeda `ToString()` methodini **override** qilib, custom string representation yaratish mumkin"
            },
            {
                "id": "C",
                "option": "`with` expression orqali mavjud recorddan **copy** yaratib, ba'zi propertylarini o'zgartirish mumkin"
            },
            {
                "id": "D",
                "option": "Positional record ga qo'shimcha **parameterless constructor** qo'shish mumkin va primary constructorni bypass qilish mumkin"
            }
        ],
        "answer": [
            "D"
        ],
        "explanation": "Positional recordlarga qo'shimcha parameterless constructor qo'shib bo'lmaydi. Primary constructor - yagona yaratish usuli. A: recordlar value-based equality ga ega ✓, B: ToString() override qilish mumkin ✓, C: with expression copy-with-modifications pattern ✓."
    },
    {
        "id": 4,
        "type": "mcq",
        "metadata": {
            "category": "asosiy-til-xususiyatlari",
            "subcategory": "file-scoped-types"
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "C# da **type modifierlar** haqida qaysi gap **to'g'ri**?\n\n**Modifier turlari:**\n- `partial` - type ni bir nechta fayllarga bo'lish uchun\n- `file` - type ni faqat joriy faylda ko'rinish uchun",
        "options": [
            {
                "id": "A",
                "option": "`partial class` ni **bir nechta fayl** bo'ylab bo'lib, har qismini alohida faylda yozish mumkin"
            },
            {
                "id": "B",
                "option": "`file struct` ni **boshqa fayldan** access qilib, instance yaratish mumkin"
            },
            {
                "id": "C",
                "option": "Bir typeni **bir vaqtning o'zida** ham `partial` ham `file` modifier bilan e'lon qilish mumkin"
            },
            {
                "id": "D",
                "option": "`file class` da **private protected** access modifier ishlatib, member yaratish mumkin"
            }
        ],
        "answer": [
            "A"
        ],
        "explanation": "Partial classlar bir assemblydagi bir nechta faylga bo'linishi mumkin, kodni organize qilish va modularity uchun foydali. B: file types faqat joriy faylda visible ✗, C: partial va file modifierlarni birga ishlatib bo'lmaydi ✗, D: file classda private protected member bo'lishi mumkin emas ✗."
    },
    {
        "id": 5,
        "type": "mcq",
        "metadata": {
            "category": "metod-xususiyatlari",
            "subcategory": "params-arrays"
        },
        "codeBefore": "```csharp\nvoid F(params int[] nums) { }\n```",
        "codeAfter": "",
        "prompt": "Yuqoridagi methodga `F(1, 2, new[]{3,4})` **chaqiruvi** amalga oshirilganda nima bo'ladi?\n\n**Eslatma:** `params` parameter ikki xil usulda ishlatiladi:\n- Individual argumentlar: `F(1, 2, 3, 4)`\n- Bitta array: `F(new[]{1, 2, 3, 4})`",
        "options": [
            {
                "id": "A",
                "option": "Barcha argumentlar **combine** bo'lib, bitta `[1,2,3,4]` array yaratiladi"
            },
            {
                "id": "B",
                "option": "**Uch argument** uzatiladi: `1`, `2` va `int[]` array object"
            },
            {
                "id": "C",
                "option": "**Compilation error** - individual values va array ni aralashtirib bo'lmaydi"
            },
            {
                "id": "D",
                "option": "**Runtime exception** - argument type conversion muammosi"
            }
        ],
        "answer": [
            "C"
        ],
        "explanation": "params parameter bilan faqat ikki variant mumkin: yoki faqat individual values (F(1,2,3,4)) yoki faqat bitta array (F(new[]{1,2,3,4})). Individual values (1,2) va array (new[]{3,4}) ni aralashtirib bo'lmaydi - compilation error beradi."
    },
    {
        "id": 6,
        "type": "mcq",
        "metadata": {
            "category": "tip-tizimi-oop",
            "subcategory": "generics-constraints"
        },
        "codeBefore": "```csharp\npublic static TResult Combine<TSource, TResult>(TSource a, TSource b)\n    where TSource : ________, IComparable<TSource>\n    where TResult : TSource, new()\n{\n    // Arifmetik operatorlar ishlatiladi: +, -, *, /\n    return new TResult();\n}\n```",
        "codeAfter": "",
        "prompt": "**Generic math** (.NET 7+) da `TSource` type uchun **arifmetik operatorlar** (`+`, `-`, `*`, `/`) ishlatish uchun qaysi **generic constraint** kerak?\n\n**Eslatma:** C# 11+ da static abstract interface memberlar orqali operator overloading mumkin.",
        "options": [
            {
                "id": "A",
                "option": "`INumber<TSource>` - .NET 7+ generic math interface"
            },
            {
                "id": "B",
                "option": "`struct` - value type constraint"
            },
            {
                "id": "C",
                "option": "`IArithmetic<TSource>` - custom arithmetic interface"
            },
            {
                "id": "D",
                "option": "`class` - reference type constraint"
            }
        ],
        "answer": [
            "A"
        ],
        "explanation": "INumber<T> .NET 7+ da arifmetik operatorlar uchun asosiy interface. Static abstract interface memberlar orqali +, -, *, / operatorlarini ta'minlaydi. B: struct constraint arifmetik operator bermaydi ✗, C: IArithmetic<T> mavjud emas ✗, D: class constraint arifmetik operator bermaydi ✗."
    },
    {
        "id": 7,
        "type": "mcq",
        "metadata": {
            "category": "metod-xususiyatlari",
            "subcategory": "extension-methods"
        },
        "codeBefore": "```csharp\npublic static class Extensions\n{\n    public static bool IsEven(this int number)\n    {\n        return (number % 2) == 0;\n    }\n\n    public bool IsOdd(int number)\n    {\n        return (number % 2) != 0;\n    }\n}\n```",
        "codeAfter": "",
        "prompt": "Yuqoridagi **extension method** kodida qaysi **compilation error** bor?\n\n**Extension method talablari:**\n- Static class ichida bo'lishi kerak\n- Method o'zi ham static bo'lishi kerak\n- Birinchi parameter `this` keyword bilan belgilanadi",
        "options": [
            {
                "id": "A",
                "option": "`IsEven` **extension method**, `IsOdd` esa **instance method** sifatida yaratilgan"
            },
            {
                "id": "B",
                "option": "`IsEven` va `IsOdd` ikkalasi ham **extension method** bo'lishi kerak"
            },
            {
                "id": "C",
                "option": "`IsOdd` methodida **static** keyword etishmayapti - compilation error"
            },
            {
                "id": "D",
                "option": "`this int` keyword **extension method** uchun majburiy emas"
            }
        ],
        "answer": [
            "C"
        ],
        "explanation": "Static class ichidagi barcha methodlar static bo'lishi majburiy. IsOdd methodida static keyword etishmayapti, bu compilation error ga olib keladi. A: IsOdd instance method emas ✗, B: ikkalasi ham extension bo'lishi shart emas ✗, D: this keyword extension method uchun majburiy ✓."
    },
    {
        "id": 8,
        "type": "mcq",
        "metadata": {
            "category": "asosiy-til-xususiyatlari",
            "subcategory": "file-scoped-types"
        },
        "codeBefore": "```csharp\n// File1.cs\nfile interface IHelper\n{\n    void Help();\n}\n\n// File2.cs\nclass HelperImpl : IHelper { ... }  // Bu mumkinmi?\n```",
        "codeAfter": "",
        "prompt": "**File-scoped types** (C# 11+) haqida: `file` modifier bilan e'lon qilingan `IHelper` interface ni **boshqa fayldan** ishlatish mumkinmi?\n\n**File-scoped types xususiyatlari:**\n- Faqat e'lon qilingan file ichida ko'rinadi\n- Boshqa filelar uchun invisible\n- Assembly-level visibility yo'q",
        "options": [
            {
                "id": "A",
                "option": "**Ha** - `IHelper` faqat shu file ichida ko'rinadi va implement qilish mumkin"
            },
            {
                "id": "B",
                "option": "**Yo'q** - `IHelper` butun assembly bo'ylab `public` hisoblanadi"
            },
            {
                "id": "C",
                "option": "**Yo'q** - `IHelper` ni bir nechta filedan implement qilish mumkin"
            },
            {
                "id": "D",
                "option": "**Yo'q** - `file interface` noto'g'ri syntax"
            }
        ],
        "answer": [
            "A"
        ],
        "explanation": "File-scoped types (file interface, file class, file struct) faqat e'lon qilingan file ichida ko'rinadi. Boshqa filelar bu typelarga access qila olmaydi. A: Faqat o'sha file ichida ✓, B: Assembly-level visibility yo'q ✗, C: Boshqa filelardan access yo'q ✗, D: C# 11+ da valid syntax ✓."
    },
    {
        "id": 9,
        "type": "mcq",
        "metadata": {
            "category": "tip-tizimi-oop",
            "subcategory": "value-types"
        },
        "codeBefore": "```csharp\npublic struct DataPoint\n{\n    public readonly int X;\n    public readonly int Y;\n    public DataPoint(int x, int y) => (X, Y) = (x, y);\n}\n\nvar d1 = new DataPoint(1, 2);\nvar d2 = d1;  // struct assignment\n\nd2 = new DataPoint(3, 4);  // d2 ga yangi qiymat\nConsole.WriteLine(d1.X + \",\" + d1.Y);\n```",
        "codeAfter": "",
        "prompt": "**Struct value semantics** tufayli `Console.WriteLine` natijasi nima bo'ladi?\n\n**Value type xususiyatlari:**\n- Assignment copy by value yaratadi\n- Har bir variable mustaqil copy\n- Reference semantics yo'q",
        "options": [
            {
                "id": "A",
                "option": "**`1,2`** - struct value type, d2 ni o'zgartirish d1 ga ta'sir qilmaydi"
            },
            {
                "id": "B",
                "option": "**`3,4`** - d2 o'zgartirilsa, d1 ham o'zgaradi (reference semantics)"
            },
            {
                "id": "C",
                "option": "**`1,2`** - readonly fieldlar o'zgarmaydi, assignment bo'lmaydi"
            },
            {
                "id": "D",
                "option": "**Compilation error** - readonly struct assignment mumkin emas"
            }
        ],
        "answer": [
            "A"
        ],
        "explanation": "Struct value semantics: assignment copy by value yaratadi. d1 va d2 mustaqil copieslar. d2 ga yangi qiymat berilganda d1 o'zgarishsiz qoladi. A: Value semantics ✓, B: Reference semantics emas ✗, C: readonly field, readonly struct emas ✗, D: Assignment valid ✓."
    },
    {
        "id": 10,
        "type": "mcq",
        "metadata": {
            "category": "asosiy-til-xususiyatlari",
            "subcategory": "pattern-matching"
        },
        "codeBefore": "```csharp\nint Classify(int x) => x switch\n{\n    < 0 => -1,  // manfiy\n    > 0 => 1,   // musbat\n    _   => 0    // default case\n};\n\nvar result = Classify(0);\n```",
        "codeAfter": "",
        "prompt": "**Switch expression** da `Classify(0)` qiymatini hisoblash: `0` qiymati qaysi **pattern** ga mos keladi?\n\n**Pattern matching tartibi:**\n- Patterns yuqoridan pastga tekshiriladi\n- Birinchi mos kelgan pattern execute bo'ladi\n- `_` - default pattern (catch-all)",
        "options": [
            {
                "id": "A",
                "option": "**`-1`** - chunki `< 0` pattern ga mos keladi"
            },
            {
                "id": "B",
                "option": "**`0`** - chunki `_` (default) pattern ga mos keladi"
            },
            {
                "id": "C",
                "option": "**`1`** - chunki `> 0` pattern ga mos keladi"
            },
            {
                "id": "D",
                "option": "**Compilation error** - exhaustive pattern matching yo'q"
            }
        ],
        "answer": [
            "B"
        ],
        "explanation": "Switch expression da patterns yuqoridan pastga tekshiriladi. 0 qiymat uchun: `< 0` false ✗, `> 0` false ✗, `_` (default) true ✓ - natija 0. A: 0 < 0 emas ✗, B: Default pattern ✓, C: 0 > 0 emas ✗, D: `_` pattern bilan exhaustive ✓."
    },
    {
        "id": 11,
        "type": "true_false",
        "metadata": {
            "category": "asosiy-til-xususiyatlari",
            "subcategory": "file-scoped-namespaces"
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "**File-scoped namespace** (`namespace MyApp;`) faqat kodni **tashkillashtirish** uchun ishlatiladi va **access modifierlar** yoki **visibility** ga ta'sir qilmaydi.\n\n**Eslatma:** File-scoped namespace C# 10+ da kiritilgan feature bo'lib, traditional namespace syntaxni soddalashtiradi.",
        "answer": "true",
        "explanation": "File-scoped namespace faqat code organization uchun. Access modifierlar (public, private, internal) va visibility rules bir xil qoladi. Faqat indentation va braces kamayadi. Traditional namespace: { } blok kerak, file-scoped: semicolon (;) yetarli."
    },
    {
        "id": 12,
        "type": "true_false",
        "metadata": {
            "category": "asosiy-til-xususiyatlari",
            "subcategory": "record-structs"
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "**C# 10+** da `record struct` uchun foydalanuvchi tomonidan yaratilgan **parametersiz constructor** e'lon qilish mumkin.\n\n**Eslatma:** Oldingi versiyalarda struct va record structlarda faqat parametrli constructorlar ruxsat etilgan edi.",
        "answer": "true",
        "explanation": "C# 10+ da record struct uchun parametersiz constructor e'lon qilish mumkin. Bu C# 9 da cheklangan edi. Parametersiz constructor explicit yozish mumkin va default initialization logic ni override qilish mumkin."
    },
    {
        "id": 13,
        "type": "true_false",
        "metadata": {
            "category": "asosiy-til-xususiyatlari",
            "subcategory": "expression-bodied-members"
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "**Expression-bodied member** (`=>`) ichida **exception throw** qilish va **kompleks mantiq** yozish mumkin.\n\n**Masalan:** `string GetValue() => condition ? \"value\" : throw new Exception(\"Error\");`\n\n**Eslatma:** Expression-bodied memberlar faqat single expression bilan cheklangan.",
        "answer": "true",
        "explanation": "Expression-bodied memberlar single expression bilan cheklangan, lekin bu expression kompleks bo'lishi mumkin. Exception throw, conditional expressions (?:), method calls, va boshqa expressionlar mumkin. Faqat statements (if, for, while) mumkin emas."
    },
    {
        "id": 14,
        "type": "true_false",
        "metadata": {
            "category": "asosiy-til-xususiyatlari",
            "subcategory": "pattern-matching"
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "**C# switch pattern** da bir **case** ichida **type pattern** va **qo'shimcha shart** birga yozilishi mumkin.\n\n**Masalan:** `case string s when s.Length > 0:`\n\n**Pattern guard (when clause)** orqali type patternni boolean condition bilan birlashtirish.",
        "answer": "true",
        "explanation": "Pattern guard (when clause) orqali type pattern va boolean condition birgalikda ishlatiladi. `case string s when s.Length > 0:` - bu s ni string sifatida cast qiladi va s.Length > 0 shartini tekshiradi. Ikki shart ham true bo'lishi kerak."
    },
    {
        "id": 15,
        "type": "true_false",
        "metadata": {
            "category": "tip-tizimi-oop",
            "subcategory": "structs"
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "**C# 10+** da `struct` uchun **parametersiz constructor** e'lon qilish va **default initialization** xatti-harakatni o'zgartirish mumkin.\n\n**Eslatma:** Oldingi versiyalarda struct uchun faqat parametrli constructorlar ruxsat etilgan edi.\n\n**Masalan:** `public MyStruct() { Value = 42; }`",
        "answer": "true",
        "explanation": "C# 10+ da struct uchun parametersiz constructor e'lon qilish mumkin. Bu default initialization logic ni override qilish imkonini beradi. Oldingi versiyalarda bu cheklangan edi - faqat parametrli constructorlar ruxsat etilgan edi."
    },
    {
        "id": 16,
        "type": "true_false",
        "metadata": {
            "category": "asosiy-til-xususiyatlari",
            "subcategory": "switch expressions"
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "**C# switch expressions** da barcha mumkin bo'lgan **input patterns** ni kompilyatsiya vaqtida qamrab olish shart (**exhaustive** bo'lishi kerak), **default case** (`_`) bo'lmasa ham.\n\n**Eslatma:** Compiler static analysis orqali barcha caseslar qamrab olinganligini tekshiradi.",
        "answer": "false",
        "explanation": "Switch expression exhaustive bo'lishi kerak, lekin compiler ba'zi hollarda barcha mumkin bo'lgan input patterns ni automatic aniqlay olmaydi. Complex types yoki open-ended patterns uchun default case (_) talab qilinadi. Enum kabi finite types uchun compiler barcha values ni track qiladi."
    },
    {
        "id": 17,
        "type": "true_false",
        "metadata": {
            "category": "metod-xususiyatlari",
            "subcategory": "extension metodlar"
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "**Extension methods** faqat **static class** ichida e'lon qilinadi va o'zi ham **static** bo'lishi kerak.\n\n**Extension method talablari:**\n- Static class ichida\n- Method o'zi static\n- Birinchi parameter `this` keyword bilan\n\n**Masalan:** `public static void MyMethod(this string str)`",
        "answer": "true",
        "explanation": "Extension methodlar qat'iy qoidalar asosida yaratiladi: 1) Faqat static class ichida, 2) Method o'zi static, 3) Birinchi parameter this keyword bilan. Bu syntactic sugar bo'lib, compiler method call ni static method call ga aylantirishadi."
    },
    {
        "id": 18,
        "type": "true_false",
        "metadata": {
            "category": "metod-xususiyatlari",
            "subcategory": "named arguments"
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "**Named arguments** dan foydalanganda method chaqirishda **optional parameters** ni **required parameters** dan oldin yozish mumkin.\n\n**Named arguments imkoniyatlari:**\n- Parametrlar tartibini o'zgartirish\n- Optional parametrlarni skip qilish\n- Code readability yaxshilash\n\n**Masalan:** `Method(optional: 10, required: \"text\")`",
        "answer": "true",
        "explanation": "Named arguments parametrlar tartibini o'zgartirish imkonini beradi. Optional parametrlarni required parametrlardan oldin yozish, ba'zi parametrlarni skip qilish va code readability ni yaxshilash mumkin. Compiler parametrlarni to'g'ri joylarga assign qiladi."
    },
    {
        "id": 19,
        "type": "true_false",
        "metadata": {
            "category": "asosiy-til-xususiyatlari",
            "subcategory": "record class"
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "**C#** da `record` (record class) **default** bo'yicha **reference type** hisoblanadi.\n\n**Record types:**\n- `record` = `record class` (reference type)\n- `record struct` (value type)\n\n**Eslatma:** Record class default equality, ToString(), va with expressions ni ta'minlaydi.",
        "answer": "true",
        "explanation": "C# da `record` keyword default bo'yicha record class yaratadi va u reference type hisoblanadi. Value type uchun aniq `record struct` yozish kerak. Record class heap da saqlanadi, reference semantics, va immutable pattern uchun optimized."
    },
    {
        "id": 20,
        "type": "true_false",
        "metadata": {
            "category": "tip-tizimi-oop",
            "subcategory": "inheritance"
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "`sealed` bilan belgilangan **virtual method** ni boshqa **derived classes** da **override** qilib bo'lmaydi.\n\n**Sealed override pattern:**\n- Base class virtual method\n- Derived class override sealed method\n- Further derived classes override qila olmaydi\n\n**Eslatma:** Sealed method override chain ni to'xtatadi.",
        "answer": "true",
        "explanation": "Sealed virtual method override chain ni to'xtatadi. Sealed method ni further derived classes da override qilib bo'lmaydi, lekin base class implementation dan foydalanish mumkin. Bu method ni \"finalize\" qilish uchun ishlatiladi."
    },
    {
        "id": 21,
        "type": "fill",
        "metadata": {
            "category": "tip-tizimi-oop",
            "subcategory": "generic math"
        },
        "codeWithBlank": "public static T AddAll<T>(T[] values)\n    where T : ________, ________\n{\n    T sum = default!;\n    foreach (var v in values)\n    {\n        sum += v;\n    }\n    return sum;\n}",
        "prompt": "**Generic math** (.NET 7+) da `T` type uchun **`+` operatori** va **`default` literal** ishlatish imkonini beruvchi **ikki interface** ni to'ldiring.\n\n**Eslatma:** \n- Birinchi interface: asosiy numeric type interface\n- Ikkinchi interface: addition operator interface\n\n**Generic math constraint** larni vergul bilan ajrating.",
        "answer": "public static T AddAll<T>(T[] values)\n    where T : INumber<T>, IAdditionOperators<T, T, T>\n{\n    T sum = default!;\n    foreach (var v in values)\n    {\n        sum += v;\n    }\n    return sum;\n}",
        "explanation": "INumber<T> - .NET 7+ da asosiy numeric type interface, barcha raqamli operatorlar uchun base interface. IAdditionOperators<T, T, T> - + operatorini ta'minlaydi (TLeft + TRight = TResult pattern). Ikkalasi ham static abstract interface memberlar orqali matematik operatorlarni qo'llab-quvvatlaydi."
    },
    {
        "id": 22,
        "type": "fill",
        "metadata": {
            "category": "asosiy-til-xususiyatlari",
            "subcategory": "file-scoped types"
        },
        "codeWithBlank": "file struct Point(int X, int Y)\n{\n    public void Deconstruct(out int x, out int y) => (x, y) = (______, ______);\n}",
        "prompt": "**File-scoped positional struct** da **Deconstruct method** primary constructor **parametrlarini qaytarishi** uchun bo'sh joylarni to'ldiring.\n\n**Eslatma:** \n- Primary constructor parametrlari automatically properties sifatida mavjud\n- Deconstruct method tuple deconstruction ni ta'minlaydi\n- `var (x, y) = point;` syntax uchun kerak",
        "answer": "file struct Point(int X, int Y)\n{\n    public void Deconstruct(out int x, out int y) => (x, y) = (X, Y);\n}",
        "explanation": "Primary constructor parametrlari X va Y automatically properties sifatida mavjud bo'ladi. Deconstruct method da ularni to'g'ridan-to'g'ri ishlatish mumkin. Bu tuple deconstruction syntax ni qo'llab-quvvatlaydi: var (x, y) = point;"
    },
    {
        "id": 23,
        "type": "fill",
        "metadata": {
            "category": "tip-tizimi-oop",
            "subcategory": "interfaces"
        },
        "codeWithBlank": "public interface IRepository<T>\n{\n    void Add(T item);\n    T? Get(int id);\n}\n\npublic class Repo<T> : ______\n{\n    void IRepository<T>.Add(T item) { /*...*/ }\n    T? IRepository<T>.Get(int id) { /*...*/ }\n}",
        "prompt": "**Explicit interface implementation** qilish uchun **inheritance** qismini to'ldiring.\n\n**Explicit interface implementation xususiyatlari:**\n- Methodlar public emas\n- Faqat interface orqali accessible\n- Interface name fully qualified bo'ladi\n\n**Generic interface** ni implement qilish syntax ni yozing.",
        "answer": "public interface IRepository<T>\n{\n    void Add(T item);\n    T? Get(int id);\n}\n\npublic class Repo<T> : IRepository<T>\n{\n    void IRepository<T>.Add(T item) { /*...*/ }\n    T? IRepository<T>.Get(int id) { /*...*/ }\n}",
        "explanation": "Generic interface IRepository<T> ni implement qilish uchun class inheritance da to'liq nom ko'rsatilishi kerak. Explicit interface implementation da methodlar interface name bilan fully qualified bo'ladi va faqat interface reference orqali accessible."
    },
    {
        "id": 24,
        "type": "fill",
        "metadata": {
            "category": "tip-tizimi-oop",
            "subcategory": "default implementation"
        },
        "codeWithBlank": "public interface ILogger\n{\n    void Log(string message);\n    void LogError(Exception ex) => ______;\n}",
        "prompt": "**Default interface implementation** (C# 8+): `LogError` method **exception** ni **string format** da `Log` methodiga uzatsin.\n\n**Default interface implementation xususiyatlari:**\n- Interface da method implementation berish\n- Implementing class override qilmasligi mumkin\n- Interface methodlarini ichkaridan call qilish mumkin\n\n**Exception** ni string ga aylantirish method ni yozing.",
        "answer": "public interface ILogger\n{\n    void Log(string message);\n    void LogError(Exception ex) => Log(ex.ToString());\n}",
        "explanation": "Default interface implementation da boshqa interface methodlarini chaqirish mumkin. Exception ni ToString() orqali string formatga aylantirib Log() methodiga uzatish. Bu implementing classlar uchun LogError() ni override qilish ixtiyoriy qiladi."
    },
    {
        "id": 25,
        "type": "fill",
        "metadata": {
            "category": "asosiy-til-xususiyatlari",
            "subcategory": "pattern matching"
        },
        "codeWithBlank": "int Classify(object o) => o switch\n{\n    string s when ______ => 1,\n    int i when i % 2 == 0 => 2,\n    null                  => 0,\n    _                     => 3\n};",
        "prompt": "**Pattern matching** da **bo'sh bo'lmagan** (non-empty) **string** ni tekshiruvchi **when clause** shart yozing.\n\n**Pattern guard (when clause) xususiyatlari:**\n- Type pattern bilan birga ishlatiladi\n- Boolean expression bo'lishi kerak\n- Pattern variable ga access beradi\n\n**String** ning bo'sh emasligini tekshirish condition ni yozing.",
        "answer": "int Classify(object o) => o switch\n{\n    string s when s.Length > 0 => 1,\n    int i when i % 2 == 0 => 2,\n    null                  => 0,\n    _                     => 3\n};",
        "explanation": "String type pattern da s variable orqali string ga access qilish mumkin. s.Length > 0 sharti bo'sh bo'lmagan stringlarni aniqlaydi. null case already handled bo'lgani uchun null check kerak emas - type pattern null safety beradi."
    },
    {
        "id": 26,
        "type": "error_spotting",
        "metadata": {
            "category": "tip-tizimi-oop",
            "subcategory": "generic math"
        },
        "codeWithError": "public class Calculator\n{\n    public static T Subtract<T>(T a, T b) where T : IComparable<T>\n    {\n        return a - b;  // Bu yerda xato\n    }\n}",
        "prompt": "**Generic math** (.NET 7+) da **subtraction operatori** (`-`) uchun **noto'g'ri constraint** ishlatilgan.\n\n**Muammo:** `IComparable<T>` constraint matematik operatorlarni qo'llab-quvvatlamaydi.\n\n**Vazifa:** To'g'ri **generic math interface** bilan tuzating.",
        "answer": "public class Calculator\n{\n    public static T Subtract<T>(T a, T b)\n        where T : ISubtractionOperators<T, T, T>\n    {\n        return a - b;\n    }\n}",
        "explanation": "IComparable<T> faqat comparison uchun, matematik operatorlar uchun emas. Subtraction operatori (-) uchun ISubtractionOperators<T, T, T> interfeysi kerak. Bu .NET 7+ generic math systemining qismi bo'lib, static abstract interface memberlar orqali matematik operatorlarni ta'minlaydi."
    },
    {
        "id": 27,
        "type": "error_spotting",
        "metadata": {
            "category": "tip-tizimi-oop",
            "subcategory": "interfaces"
        },
        "codeWithError": "interface IShape\n{\n    double Area();  // Capital A\n}\n\npublic class Circle : IShape\n{\n    private readonly double radius;\n    public Circle(double radius) => this.radius = radius;\n    public double area() => Math.PI * radius * radius;  // kichik a\n}",
        "prompt": "**Interface implementation** da **method name case sensitivity** xatosi bor.\n\n**Muammo:** Interface da `Area()` (capital A) e'lon qilingan, lekin class da `area()` (lowercase a) implement qilingan.\n\n**Eslatma:** C# **case-sensitive** programming language.\n\n**Vazifa:** Method name ni to'g'ri case bilan tuzating.",
        "answer": "interface IShape\n{\n    double Area();\n}\n\npublic class Circle : IShape\n{\n    private readonly double radius;\n    public Circle(double radius) => this.radius = radius;\n    public double Area() => Math.PI * radius * radius;\n}",
        "explanation": "C# case-sensitive programming language. Interface da Area() (capital A) deb e'lon qilingan method aynan Area() nomli bo'lishi kerak, area() (lowercase a) emas. Method signature exactly match bo'lishi shart."
    },
    {
        "id": 28,
        "type": "error_spotting",
        "metadata": {
            "category": "tip-tizimi-oop",
            "subcategory": "structs"
        },
        "codeWithError": "public struct Rectangle\n{\n    public int Width { get; set; }\n    public int Height { get; set; }\n    public Rectangle(int width, int height)\n    {\n        Width = width;\n        // Height initsializatsiya qilinmagan!\n    }\n}",
        "prompt": "**Struct constructor** da **barcha fields/properties** **initialization** qilinishi kerak.\n\n**Muammo:** `Height` property initialization qilinmagan.\n\n**Struct constructor qoidasi:** Barcha fields va properties constructor da initialize qilinishi majburiy.\n\n**Vazifa:** Etishmayotgan initialization ni qo'shing.",
        "answer": "public struct Rectangle\n{\n    public int Width { get; set; }\n    public int Height { get; set; }\n    public Rectangle(int width, int height)\n    {\n        Width = width;\n        Height = height;\n    }\n}",
        "explanation": "Struct constructor da barcha fields va properties initialize qilinishi majburiy. Compiler struct ning completely initialized bo'lishini talab qiladi. Height property ga height parameter qiymatini assign qilish kerak."
    },
    {
        "id": 29,
        "type": "error_spotting",
        "metadata": {
            "category": "asosiy-til-xususiyatlari",
            "subcategory": "records"
        },
        "codeWithError": "public record Person(string FirstName, string LastName)\n{\n    public string FullName => FirstName + \" \" + LastName;\n    public Person() {}  // Primary constructor chaqirilmagan\n}",
        "prompt": "**Positional record** da **parametersiz constructor** **primary constructor** ni chaqirishi kerak.\n\n**Muammo:** Qo'shimcha constructor primary constructor ni chaqirmayapti.\n\n**Positional record qoidasi:** Barcha constructorlar primary constructor ni `this()` orqali chaqirishi majburiy.\n\n**Vazifa:** Constructor chaining qo'shing.",
        "answer": "public record Person(string FirstName, string LastName)\n{\n    public string FullName => FirstName + \" \" + LastName;\n    public Person() : this(string.Empty, string.Empty) {}\n}",
        "explanation": "Positional record da qo'shimcha constructor primary constructor ni `: this()` syntax orqali chaqirishi majburiy. Bu record ning positional parameters ni to'g'ri initialize qilish uchun kerak. Primary constructor ning signature ga mos keluvchi argumentlar berish shart."
    },
    {
        "id": 30,
        "type": "error_spotting",
        "metadata": {
            "category": "asosiy-til-xususiyatlari",
            "subcategory": "nullable reference types"
        },
        "codeWithError": "public class Utils\n{\n    public static void LogMessage(string? msg!)  // ? va ! birga ishlatilgan\n    {\n        Console.WriteLine(msg);\n    }\n}",
        "prompt": "**Nullable annotation syntax** da xato bor.\n\n**Muammo:** Parameter declaration da `?` (nullable) va `!` (null-forgiving) operatorlari birga ishlatilgan.\n\n**Nullable annotation qoidalari:**\n- `string?` - nullable reference type\n- `string!` - null-forgiving operator (usage da)\n- Ikkalasini birga ishlatib bo'lmaydi\n\n**Vazifa:** To'g'ri nullable annotation qo'shing.",
        "answer": "public class Utils\n{\n    public static void LogMessage(string? msg)\n    {\n        Console.WriteLine(msg);\n    }\n}",
        "explanation": "Parameter declaration da `?` (nullable) va `!` (null-forgiving) operatorlari birga ishlatilmaydi. `?` type declaration uchun, `!` expression da null warning suppress qilish uchun. Parameter uchun faqat `string?` (nullable) yoki `string` (non-nullable) ishlatish mumkin."
    },
    {
        "id": 31,
        "type": "error_spotting",
        "metadata": {
            "category": "tip-tizimi-oop",
            "subcategory": "inheritance"
        },
        "codeWithError": "public abstract class Base\n{\n    public abstract void Save(string data);\n}\n\npublic class FileSaver : Base\n{\n    public void Save(string data)  // override kalit so'zi yo'q\n    {\n        File.WriteAllText(\"out.txt\", data);\n    }\n}",
        "prompt": "**Abstract method implementation** da **`override` keyword** etishmayapti.\n\n**Muammo:** Derived class da abstract method ni implement qilishda `override` keyword ishlatilmagan.\n\n**Abstract method qoidasi:** Abstract base class dan inherit qilingan method ni implement qilishda `override` keyword majburiy.\n\n**Vazifa:** Etishmayotgan `override` keyword ni qo'shing.",
        "answer": "public abstract class Base\n{\n    public abstract void Save(string data);\n}\n\npublic class FileSaver : Base\n{\n    public override void Save(string data)\n    {\n        File.WriteAllText(\"out.txt\", data);\n    }\n}",
        "explanation": "Abstract method ni implement qilishda `override` keyword majburiy. Bu compiler ga abstract contract ni fulfill qilayotganingizni bildiradi. `override` keyword ni ishlatmaslik compilation error ga olib keladi."
    },
    {
        "id": 32,
        "type": "error_spotting",
        "metadata": {
            "category": "asosiy-til-xususiyatlari",
            "subcategory": "init properties"
        },
        "codeWithError": "struct Configuration\n{\n    public string Url { get; init; }\n    public Configuration() { Url = \"\"; }  // C# 11+ da ruxsat etilgan, lekin init-only property bilan muammo\n}",
        "prompt": "**Init-only property** ni constructor da initialization qilish o'rniga **property initializer** ishlatish yaxshiroq.\n\n**Muammo:** Constructor ichida init-only property ni set qilish mumkin, lekin property initializer ishlatish idiomatic C# style.\n\n**Property initializer afzalligi:** \n- Ko'proq declarative\n- Property ning default value ini aniq ko'rsatadi\n- Kod qisqaroq va tushunarli\n\n**Vazifa:** Constructor ni olib tashlang va property initializer ishlatib qiymat bering.",
        "answer": "struct Configuration\n{\n    public string Url { get; init; } = string.Empty;\n}",
        "explanation": "Init-only property uchun property initializer ishlatish yaxshiroq. Bu property ning immutable nature ni ta'kidlaydi va default value ni aniq ko'rsatadi. Constructor o'rniga property initializer ishlatish idiomatic C# style hisoblanadi."
    },
    {
        "id": 33,
        "type": "error_spotting",
        "metadata": {
            "category": "tip-tizimi-oop",
            "subcategory": "generic constraints"
        },
        "codeWithError": "public interface ICalc<T>\n{\n    T Add(T a, T b);\n}\n\npublic class Calculator : ICalc<int>  // Konkret tip bilan cheklangan\n{\n    public int Add(int a, int b)\n    {\n        return a + b;\n    }\n}",
        "prompt": "**Generic interface** ni faqat konkret type bilan implement qilish o'rniga **generic class** ishlatish va **constraint** qo'shish kerak.\n\n**Muammo:** \n- Interface generic, lekin class konkret type bilan implement qilingan\n- Matematik operatorlar uchun constraint yo'q\n\n**Generic math (C# 11+):** `IAdditionOperators<T, T, T>` constraint matematik operatorlarni ta'minlaydi.\n\n**Vazifa:** Class ni generic qiling va matematik constraint qo'shing.",
        "answer": "public interface ICalc<T>\n{\n    T Add(T a, T b);\n}\n\npublic class Calculator<T> : ICalc<T>\n    where T : IAdditionOperators<T, T, T>\n{\n    public T Add(T a, T b)\n    {\n        return a + b;\n    }\n}",
        "explanation": "Generic interface ni generic class bilan implement qilish type flexibility beradi. `IAdditionOperators<T, T, T>` constraint matematik operatorni ta'minlaydi va compile-time da `+` operatorini ishlatishga imkon beradi."
    },
    {
        "id": 34,
        "type": "error_spotting",
        "metadata": {
            "category": "metod-xususiyatlari",
            "subcategory": "extension methods"
        },
        "codeWithError": "public static class StringUtils\n{\n    public static bool IsPalindrome(string s)\n    {\n        return s == new string(s.Reverse().ToArray());\n    }\n\n    public bool IsAnagram(this string s, string t)  // static emas\n    {\n        return s.OrderBy(c => c).SequenceEqual(t.OrderBy(c => c));\n    }\n}",
        "prompt": "**Extension method** da **`static` keyword** etishmayapti.\n\n**Muammo:** Static class ichida extension method `static` keyword siz e'lon qilingan.\n\n**Extension method qoidalari:**\n- Faqat static class ichida bo'lishi mumkin\n- Extension method ham `static` bo'lishi kerak\n- Birinchi parameter `this` keyword bilan\n\n**Vazifa:** Extension method ni `static` qiling.",
        "answer": "public static class StringUtils\n{\n    public static bool IsPalindrome(string s)\n    {\n        return s == new string(s.Reverse().ToArray());\n    }\n\n    public static bool IsAnagram(this string s, string t)\n    {\n        return s.OrderBy(c => c).SequenceEqual(t.OrderBy(c => c));\n    }\n}",
        "explanation": "Extension method static class ichida static method bo'lishi kerak. `IsAnagram` method ni `static` qilish orqali extension method syntax ishlaydi va string instance larida chaqirish mumkin bo'ladi."
    },
    {
        "id": 35,
        "type": "error_spotting",
        "metadata": {
            "category": "asosiy-til-xususiyatlari",
            "subcategory": "records"
        },
        "codeWithError": "public record Person(string FirstName, string LastName)\n{\n    public Person() { }  // Primary constructor chaqirilmagan\n}",
        "prompt": "**Positional record** da qo'shimcha constructor **primary constructor** ni chaqirishi kerak.\n\n**Muammo:** Parametrsiz constructor primary constructor ga chain qilmayapti.\n\n**Record constructor chaining:**\n- Positional record primary constructor bilan keladi\n- Qo'shimcha constructor `: this(...)` syntax bilan chain qilishi kerak\n- Primary constructor parametrlar uchun default value lar berish kerak\n\n**Vazifa:** `: this(...)` syntax bilan primary constructor ni chaqiring.",
        "answer": "public record Person(string FirstName, string LastName)\n{\n    public Person() : this(string.Empty, string.Empty) { }\n}",
        "explanation": "Positional record da qo'shimcha constructor primary constructor ni `: this()` syntax orqali chaqirishi kerak. Bu record ning positional nature ni saqlaydi va primary constructor orqali property initialization ni ta'minlaydi."
    },
    {
        "id": 36,
        "type": "output_prediction",
        "metadata": {
            "category": "tip-tizimi-oop",
            "subcategory": "method hiding"
        },
        "snippet": "class A\n{\n    public virtual string F() => \"A\";\n}\nclass B : A\n{\n    public override string F() => base.F() + \"B\";  // \"AB\"\n}\nclass C : B\n{\n    public new string F() => base.F() + \"C\";  // \"ABC\" lekin virtual dispatch yo'q\n}\n\nA obj = new C();\nConsole.WriteLine(obj.F());  // A reference orqali chaqirilmoqda",
        "prompt": "**Method hiding** vs **virtual dispatch** farqi nima?\n\n**Kod tahlili:**\n- `A.F()` - virtual method \n- `B.F()` - override (virtual dispatch continues)\n- `C.F()` - **new** keyword (virtual dispatch breaks)\n- `obj` - `A` reference, `C` instance\n\n**Savol:** `obj.F()` chaqirilganda qanday natija chiqadi?",
        "answer": "AB",
        "explanation": "✓ **Virtual dispatch qoidasi:** `new` keyword virtual dispatch ni to'xtatadi\n\n✓ **Method resolution:**\n- `A` reference orqali chaqirilmoqda\n- `C.F()` da `new` keyword ishlatilgan\n- Virtual chain: `A.F()` → `B.F()` (override)\n- `C.F()` virtual chain dan tashqarida\n\n✓ **Natija:** `B.F()` chaqiriladi → `base.F()` + \"B\" → \"A\" + \"B\" = \"AB\""
    },
    {
        "id": 37,
        "type": "output_prediction",
        "metadata": {
            "category": "tip-tizimi-oop",
            "subcategory": "default interface implementation"
        },
        "snippet": "interface ILog\n{\n    void Log(string msg) => Console.Write(\"DefaultLog:\");  // Default implementation\n}\nclass Logger : ILog { }  // O'z implementatsiyasi yo'q\n\nvar logger = new Logger();\n((ILog)logger).Log(\"Hello\");",
        "prompt": "**Default interface implementation** (C# 8+) qanday ishlaydi?\n\n**Kod tahlili:**\n- `ILog` interface da default implementation bor\n- `Logger` class hech qanday implementation bermagan\n- `((ILog)logger).Log()` - interface cast orqali chaqirilmoqda\n\n**Savol:** Console ga qanday matn chiqadi?",
        "answer": "DefaultLog:",
        "explanation": "✓ **Default interface implementation qoidasi:** Class o'z implementation bermasa, default implementation ishlatiladi\n\n✓ **Interface cast:**\n- `Logger` class `Log` metodini implement qilmagan\n- `((ILog)logger)` - interface reference ga cast\n- Interface ning default implementation chaqiriladi\n\n✓ **Natija:** `Console.Write(\"DefaultLog:\")` ishga tushadi"
    },
    {
        "id": 38,
        "type": "output_prediction",
        "metadata": {
            "category": "tip-tizimi-oop",
            "subcategory": "method resolution"
        },
        "snippet": "class Base\n{\n    public void Show() => Console.Write(\"Base\");  // Virtual emas\n    public virtual void Display() => Console.Write(\"BaseDisplay\");\n}\nclass Derived : Base\n{\n    public new void Show() => Console.Write(\"Derived\");  // Hiding\n    public override void Display() => Console.Write(\"DerivedDisplay\");  // Override\n}\n\nBase b = new Derived();\nb.Show();     // Base reference -> Base.Show()\nb.Display();  // Virtual dispatch -> Derived.Display()",
        "prompt": "**Method hiding** (`new`) vs **method overriding** (`override`) farqini ko'rsatuvchi misol.\n\n**Kod tahlili:**\n- `Show()` - non-virtual, `new` bilan hide qilingan\n- `Display()` - virtual, `override` qilingan\n- `b` - `Base` reference, `Derived` instance\n\n**Savol:** `b.Show()` va `b.Display()` ning birga chiqishi qanday?",
        "answer": "BaseDerivedDisplay",
        "explanation": "✓ **Method hiding vs Override:**\n- `Show()` non-virtual → `new` hiding → `Base.Show()` chaqiriladi\n- `Display()` virtual → `override` → `Derived.Display()` chaqiriladi\n\n✓ **Method resolution:**\n- `b.Show()` → \"Base\" (hiding)\n- `b.Display()` → \"DerivedDisplay\" (virtual dispatch)\n\n✓ **Natija:** \"Base\" + \"DerivedDisplay\" = \"BaseDerivedDisplay\""
    },
    {
        "id": 39,
        "type": "output_prediction",
        "metadata": {
            "category": "asosiy-til-xususiyatlari",
            "subcategory": "ref readonly"
        },
        "snippet": "var numbers = new[] { 1, 2, 3 };\nint sum = 0;\nforeach (ref readonly var n in numbers)  // Reference by readonly\n{\n    sum += n;  // 1+2+3\n}\nConsole.WriteLine(sum);",
        "prompt": "**Ref readonly** (C# 7.2+) performance optimization qanday ishlaydi?\n\n**Kod tahlili:**\n- `foreach (ref readonly var n in numbers)` - copy o'rniga reference\n- `sum += n` - oddiy hisoblash\n- `numbers` = `[1, 2, 3]`\n\n**Savol:** `Console.WriteLine(sum)` natijasi nima?",
        "answer": "6",
        "explanation": "✓ **Ref readonly xususiyati:** Performance optimization, mantiq o'zgarmaydi\n\n✓ **Hisoblash jarayoni:**\n- `n` har bir element uchun readonly reference\n- `sum += 1` → sum = 1\n- `sum += 2` → sum = 3  \n- `sum += 3` → sum = 6\n\n✓ **Afzallik:** Katta struct lar uchun copy overhead kamaytiradi"
    },
    {
        "id": 40,
        "type": "output_prediction",
        "metadata": {
            "category": "asosiy-til-xususiyatlari",
            "subcategory": "records"
        },
        "snippet": "record R(int X)\n{\n    public override string ToString() => $\"R:{X}\";  // Custom ToString\n}\n\nvar r1 = new R(5);\nvar r2 = r1 with { X = 7 };  // Copy with modification\nConsole.WriteLine(r1);\nConsole.WriteLine(r2);",
        "prompt": "**Record** da **custom ToString** va **with expression** qanday ishlaydi?\n\n**Kod tahlili:**\n- `record R(int X)` - positional record\n- `ToString()` custom implementation\n- `r1 = new R(5)` - original record\n- `r2 = r1 with { X = 7 }` - copy with modification\n\n**Savol:** Ikki `Console.WriteLine` ning natijasi qanday?",
        "answer": "R:5\nR:7",
        "explanation": "✓ **With expression immutability:** Original record o'zgarishsiz qoladi\n\n✓ **Custom ToString ishlashi:**\n- `r1.ToString()` → `$\"R:{X}\"` → `\"R:5\"`\n- `r2.ToString()` → `$\"R:{X}\"` → `\"R:7\"`\n\n✓ **Record copy semantics:** `with` expression yangi instance yaratadi, original o'zgarmaydi"
    },
    {
        "id": 41,
        "type": "code_writing",
        "metadata": {
            "category": "asosiy-til-xususiyatlari",
            "subcategory": "konsol dasturlari"
        },
        "prompt": "**Kontaktlar kitobi** konsol dasturi yarating.\n\n**Talablar:**\n- `record Contact(string Name, string PhoneNumber, string Email)` \n- `List<Contact>` da saqlash\n- `switch` expression bilan buyruqlar: `add`, `list`, `exit`\n- `while` loop bilan davom etish\n\n**Buyruqlar:**\n- `add` - yangi kontakt qo'shish\n- `list` - barcha kontaktlarni ko'rsatish  \n- `exit` - dasturdan chiqish",
        "examples": [
            "Buyruq: add\nIsm: Alice\nTelefon: 998901234567\nEmail: alice@mail.com\nKontakt qo'shildi!",
            "Buyruq: list\nAlice - 998901234567 - alice@mail.com\nBob - 998987654321 - bob@mail.com",
            "Buyruq: exit\nDastur yakunlandi."
        ]
    },
    {
        "id": 42,
        "type": "code_writing",
        "metadata": {
            "category": "tip-tizimi-oop",
            "subcategory": "polimorfizm"
        },
        "prompt": "**Polimorfizm** bilan shakllar yuzasini hisoblash.\n\n**Talablar:**\n- `abstract class Shape` va `abstract double GetArea()` metodi\n- `Circle` (radius) va `Rectangle` (width, height) voris classlar\n- `GetArea()` ni har birida `override` qiling\n- `switch` expression bilan shakl tanlash\n- Polimorfizm orqali yuzani hisoblash",
        "examples": [
            "Shakl: circle\nRadius: 2.5\nYuza: 19.63",
            "Shakl: rectangle\nEni: 4\nBoyi: 3\nYuza: 12"
        ]
    },
    {
        "id": 43,
        "type": "code_writing",
        "metadata": {
            "category": "metod-xususiyatlari",
            "subcategory": "extension methods"
        },
        "prompt": "**Extension method** bilan telefon raqamini tekshirish.\n\n**Talablar:**\n- `static class PhoneValidator` yarating\n- `IsValidUzPhone(this string phone)` extension metodi\n- `998` bilan boshlanishi, 12 ta raqam, faqat raqamlar\n- Konsol dasturida test qiling\n\n**Validation qoidalari:**\n- `998` prefiksi majburiy\n- Jami 12 ta belgi\n- Faqat raqamlar (`char.IsDigit`)",
        "examples": [
            "Telefon: 998901234567\nNatija: Valid",
            "Telefon: 9901234567\nNatija: Invalid",
            "Telefon: 998abc123456\nNatija: Invalid"
        ]
    },
    {
        "id": 44,
        "type": "code_writing",
        "metadata": {
            "category": "asosiy-til-xususiyatlari",
            "subcategory": "record structs"
        },
        "prompt": "**Record struct** bilan koordinata tahlili.\n\n**Talablar:**\n- `record struct Point(int X, int Y)` yarating\n- `Classify(Point p)` metodini yozing\n- **Pattern matching** va **switch expression** ishlating\n\n**Classification qoidalari:**\n- `X = 0, Y = 0` → `\"Origin\"`\n- `X ≠ 0, Y = 0` → `\"X-axis\"`\n- `X = 0, Y ≠ 0` → `\"Y-axis\"`\n- Boshqa → `\"Quadrant\"`",
        "examples": [
            "X: 0, Y: 0\nJoylashuv: Origin",
            "X: 5, Y: 0\nJoylashuv: X-axis", 
            "X: 0, Y: 3\nJoylashuv: Y-axis",
            "X: 2, Y: 4\nJoylashuv: Quadrant"
        ]
    },
    {
        "id": 45,
        "type": "code_writing",
        "metadata": {
            "category": "metod-xususiyatlari",
            "subcategory": "params arrays"
        },
        "prompt": "**Params array** va **switch expression** bilan kalkulyator.\n\n**Talablar:**\n- `Calculate(string operation, params double[] values)` metodi\n- `switch` expression bilan operatsiyalar\n- Edge case handling (bo'sh array, noto'g'ri operatsiya)\n\n**Operatsiyalar:**\n- `\"sum\"` - yig'indi\n- `\"average\"` - o'rtacha\n- `\"max\"` - maksimal\n- `\"min\"` - minimal",
        "examples": [
            "Operatsiya: sum\nSonlar: 3 5 2\nNatija: 10",
            "Operatsiya: average\nSonlar: 4 8\nNatija: 6",
            "Operatsiya: max\nSonlar: 1 9 5\nNatija: 9"
        ]
    },
    {
        "id": 46,
        "type": "mcq",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "queue"
        },
        "codeBefore": "```csharp\nvar list = new List<int> { 1, 2, 3, 4, 5 };\nvar queue = new Queue<int>(list);\nvar result = queue.Dequeue();\n```",
        "codeAfter": "",
        "prompt": "**Queue<T>** FIFO (First In, First Out) tartibda ishlaydi.\n\n**Kod tahlili:**\n- `List<int> {1, 2, 3, 4, 5}` dan queue yaratildi\n- `Dequeue()` birinchi elementni olib tashlaydi va qaytaradi\n\n**Savol:** `result` ning qiymati nima?",
        "options": [
            {
                "id": "A",
                "option": "`1`"
            },
            {
                "id": "B",
                "option": "`5`"
            },
            {
                "id": "C",
                "option": "`0`"
            },
            {
                "id": "D",
                "option": "Exception"
            }
        ],
        "answer": [
            "A"
        ],
        "explanation": "✓ **Queue<T> FIFO qoidasi:** Birinchi kiritilgan element birinchi chiqadi\n\n✓ **Queue yaratilishi:** `List<int> {1, 2, 3, 4, 5}` dan queue yaratilganda elementlar tartib saqlanadi\n\n✓ **Dequeue() ishlashi:** Birinchi element (1) ni qaytaradi va queue dan olib tashlaydi\n\n✓ **Natija:** `result = 1`"
    },
    {
        "id": 47,
        "type": "mcq",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "dictionary"
        },
        "codeBefore": "```csharp\nvar dict = new Dictionary<string, int>\n{\n    [\"apple\"] = 5,\n    [\"banana\"] = 3\n};\ndict.TryAdd(\"apple\", 10);\nConsole.WriteLine(dict[\"apple\"]);\n```",
        "codeAfter": "",
        "prompt": "**Dictionary<TKey, TValue>** da **TryAdd** metodining xususiyati nimada?\n\n**Kod tahlili:**\n- Dictionary da `\"apple\": 5` mavjud\n- `TryAdd(\"apple\", 10)` chaqirilmoqda\n- `dict[\"apple\"]` qiymati chiqarilmoqda\n\n**Savol:** Console ga qanday qiymat chiqadi?",
        "options": [
            {
                "id": "A",
                "option": "`10` - chunki yangi qiymat qo'shiladi"
            },
            {
                "id": "B",
                "option": "`5` - chunki mavjud key ni update qilmaydi"
            },
            {
                "id": "C",
                "option": "Exception - chunki duplicate key"
            },
            {
                "id": "D",
                "option": "`15` - chunki qiymatlar qo'shiladi"
            }
        ],
        "answer": [
            "B"
        ],
        "explanation": "✓ **TryAdd metodining xususiyati:** Mavjud key uchun hech narsa qilmaydi\n\n✓ **TryAdd vs Add farqi:**\n- `Add()` - mavjud key uchun exception\n- `TryAdd()` - mavjud key uchun `false` qaytaradi, qiymat o'zgarmaydi\n\n✓ **Natija:** `\"apple\"` key allaqachon mavjud, shuning uchun qiymati `5` bo'lib qoladi"
    },
    {
        "id": 48,
        "type": "mcq",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "indexing slicing"
        },
        "codeBefore": "```csharp\nvar numbers = new int[] { 1, 2, 3, 4, 5 };\nvar lastTwo = numbers[^2..];\nConsole.WriteLine(string.Join(\", \", lastTwo));\n```",
        "codeAfter": "",
        "prompt": "**Index (`^`) va Range (`..`) operatorlari** (C# 8+) qanday ishlaydi?\n\n**Kod tahlili:**\n- Array: `{1, 2, 3, 4, 5}`\n- `^2` - oxirdan 2-chi element (index 3)\n- `[^2..]` - oxirdan 2-chi elementdan boshlab oxirigacha\n\n**Savol:** `string.Join(\", \", lastTwo)` natijasi?",
        "options": [
            {
                "id": "A",
                "option": "`4, 5`"
            },
            {
                "id": "B",
                "option": "`3, 4`"
            },
            {
                "id": "C",
                "option": "`2, 3, 4, 5`"
            },
            {
                "id": "D",
                "option": "`5`"
            }
        ],
        "answer": [
            "A"
        ],
        "explanation": "✓ **Index operator (`^`):** Oxirdan sanash\n- `^1` - oxirgi element\n- `^2` - oxirdan 2-chi element (index 3, qiymat 4)\n\n✓ **Range operator (`..`):** Slice operatori\n- `[^2..]` - oxirdan 2-chi elementdan boshlab oxirigacha\n\n✓ **Natija:** `[3..5]` → `{4, 5}` → `\"4, 5\"`"
    },
    {
        "id": 49,
        "type": "mcq",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "memory types"
        },
        "codeBefore": "```csharp\nspan<int> span = stackalloc int[3] { 1, 2, 3 };\nReadOnlySpan<int> readOnlySpan = span;\nvar memory = span.ToArray().AsMemory();\n```",
        "codeAfter": "",
        "prompt": "**Span<T>** va **Memory<T>** (C# 7.2+) haqida qaysi fikr **to'g'ri**?\n\n**Kod tahlili:**\n- `stackalloc` - stack da memory allocation\n- `Span<T>` - ref struct, stack-only\n- `ReadOnlySpan<T>` - immutable span\n- `Memory<T>` - heap va stack, async-safe\n\n**Savol:** Qaysi statement to'g'ri?",
        "options": [
            {
                "id": "A",
                "option": "`Span<T>` faqat stack da ishlaydi"
            },
            {
                "id": "B",
                "option": "`Memory<T>` heap va stack ikkalasida ham ishlaydi"
            },
            {
                "id": "C",
                "option": "`ReadOnlySpan<T>` dan `Span<T>` ga implicit cast mumkin"
            },
            {
                "id": "D",
                "option": "`Memory<T>` ref struct hisoblanadi"
            }
        ],
        "answer": [
            "B"
        ],
        "explanation": "✓ **Memory<T> xususiyatlari:** Heap va stack ikkalasida ham ishlaydi\n\n✓ **Span<T> vs Memory<T>:**\n- `Span<T>` - ref struct, stack-only, async da ishlatib bo'lmaydi\n- `Memory<T>` - regular struct, heap/stack, async-safe\n\n✓ **Noto'g'ri variantlar:**\n- A: `Span<T>` heap da ham ishlaydi\n- C: ReadOnly dan mutable ga cast mumkin emas\n- D: `Memory<T>` ref struct emas"
    },
    {
        "id": 50,
        "type": "mcq",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "set operations"
        },
        "codeBefore": "```csharp\nvar hashSet = new HashSet<int> { 1, 2, 3 };\nvar list = new List<int> { 2, 3, 4, 5 };\nhashSet.IntersectWith(list);\n```",
        "codeAfter": "",
        "prompt": "**HashSet<T>.IntersectWith()** set intersection operatsiyasi qanday ishlaydi?\n\n**Kod tahlili:**\n- `hashSet = {1, 2, 3}`\n- `list = {2, 3, 4, 5}`\n- `IntersectWith()` - intersection (kesishma) operatsiyasi\n\n**Savol:** `hashSet` da qanday elementlar qoladi?",
        "options": [
            {
                "id": "A",
                "option": "`{ 1, 2, 3, 4, 5 }`"
            },
            {
                "id": "B",
                "option": "`{ 2, 3 }`"
            },
            {
                "id": "C",
                "option": "`{ 1 }`"
            },
            {
                "id": "D",
                "option": "`{ 4, 5 }`"
            }
        ],
        "answer": [
            "B"
        ],
        "explanation": "✓ **IntersectWith operatsiyasi:** Matematik intersection (kesishma)\n\n✓ **Set operatsiyasi:**\n- `hashSet = {1, 2, 3}`\n- `list = {2, 3, 4, 5}`\n- Intersection = faqat ikkala to'plamda ham mavjud elementlar\n\n✓ **Natija:** `{2, 3}` - faqat umumiy elementlar qoladi"
    },
    {
        "id": 51,
        "type": "mcq",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "stack"
        },
        "codeBefore": "```csharp\nvar stack = new Stack<string>();\nstack.Push(\"first\");\nstack.Push(\"second\");\nvar result = stack.Peek();\nstack.Pop();\nConsole.WriteLine($\"{result}, {stack.Count}\");\n```",
        "codeAfter": "",
        "prompt": "**Stack<T>** LIFO (Last In, First Out) prinsipi bo'yicha ishlaydi.\n\n**Kod tahlili:**\n- `Push(\"first\")` → stack: [\"first\"]\n- `Push(\"second\")` → stack: [\"first\", \"second\"]\n- `Peek()` - oxirgi elementni qaytaradi (olib tashlamaydi)\n- `Pop()` - oxirgi elementni olib tashlaydi\n\n**Savol:** `Console.WriteLine` natijasi nima?",
        "options": [
            {
                "id": "A",
                "option": "`first, 1`"
            },
            {
                "id": "B",
                "option": "`second, 1`"
            },
            {
                "id": "C",
                "option": "`second, 0`"
            },
            {
                "id": "D",
                "option": "`first, 0`"
            }
        ],
        "answer": [
            "B"
        ],
        "explanation": "✓ **Stack LIFO qoidasi:** Oxirgi qo'shilgan element birinchi chiqadi\n\n✓ **Kod bajarilishi:**\n- `Peek()` → \"second\" (oxirgi element, olib tashlamaydi)\n- `Pop()` → \"second\" ni olib tashlaydi\n- `Count` → 1 (\"first\" qoladi)\n\n✓ **Natija:** `\"second, 1\"`"
    },
    {
        "id": 52,
        "type": "mcq",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "indexing slicing"
        },
        "codeBefore": "```csharp\nvar numbers = new int[] { 10, 20, 30, 40, 50 };\nvar range = 1..^1;\nvar slice = numbers[range];\n```",
        "codeAfter": "",
        "prompt": "**Range operatori** `1..^1` nimani anglatadi?\n\n**Kod tahlili:**\n- Array: `{10, 20, 30, 40, 50}`\n- `1..^1` - 1-index dan oxirgi elementgacha (exclusive)\n- `^1` - oxirgi element pozitsiyasi\n- Range da end exclusive\n\n**Savol:** `slice` da qanday qiymatlar bo'ladi?",
        "options": [
            {
                "id": "A",
                "option": "1-indexdan oxirgi elementgacha: `{ 20, 30, 40, 50 }`"
            },
            {
                "id": "B",
                "option": "1-indexdan oxirgi elementni hisobga olmaganda: `{ 20, 30, 40 }`"
            },
            {
                "id": "C",
                "option": "Faqat 1-index: `{ 20 }`"
            },
            {
                "id": "D",
                "option": "Kompilyatsiya xatosi"
            }
        ],
        "answer": [
            "B"
        ],
        "explanation": "✓ **Range syntax:** `start..end` (end exclusive)\n\n✓ **Index hisoblash:**\n- `1` → index 1 (qiymat 20)\n- `^1` → oxirgi element pozitsiyasi (index 4)\n- `1..^1` → index 1 dan 4 gacha (exclusive)\n\n✓ **Natija:** `{20, 30, 40}` (index 1, 2, 3)"
    },
    {
        "id": 53,
        "type": "mcq",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "lookup"
        },
        "codeBefore": "```csharp\nvar lookup = new string[] { \"a\", \"bb\", \"ccc\", \"a\", \"bb\" }\n    .ToLookup(x => x.Length);\nvar result = lookup[2].Count();\n```",
        "codeAfter": "",
        "prompt": "**ILookup<TKey, TElement>** one-to-many mapping qanday ishlaydi?\n\n**Kod tahlili:**\n- Array: `{\"a\", \"bb\", \"ccc\", \"a\", \"bb\"}`\n- `ToLookup(x => x.Length)` - string length bo'yicha guruhlash\n- `lookup[2]` - length = 2 bo'lgan elementlar\n- `Count()` - shu group dagi elementlar soni\n\n**Savol:** `result` ning qiymati nima?",
        "options": [
            {
                "id": "A",
                "option": "Lookup bir key uchun bitta value saqlaydi, result = 1"
            },
            {
                "id": "B",
                "option": "Lookup bir key uchun ko'p value saqlaydi, result = 2"
            },
            {
                "id": "C",
                "option": "Lookup faqat unique valuelar saqlaydi, result = 1"
            },
            {
                "id": "D",
                "option": "Exception - key topilmadi"
            }
        ],
        "answer": [
            "B"
        ],
        "explanation": "✓ **ILookup xususiyati:** One-to-many mapping - bir key uchun ko'p value\n\n✓ **Guruhlanish:**\n- Key = 1: `{\"a\", \"a\"}` (2 ta)\n- Key = 2: `{\"bb\", \"bb\"}` (2 ta)\n- Key = 3: `{\"ccc\"}` (1 ta)\n\n✓ **Natija:** `lookup[2].Count()` = 2 (\"bb\" ikki marta)"
    },
    {
        "id": 54,
        "type": "mcq",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "memory types"
        },
        "codeBefore": "```csharp\nSpan<byte> buffer = stackalloc byte[1024];\nvar memory = new Memory<byte>(new byte[1024]);\nvar span1 = buffer.Slice(10, 100);\nvar span2 = memory.Span.Slice(10, 100);\n```",
        "codeAfter": "",
        "prompt": "**Span<T>.Slice()** va **Memory<T>.Span** haqida qaysi fikr **noto'g'ri**?\n\n**Kod tahlili:**\n- `stackalloc` - stack da memory allocation\n- `new byte[1024]` - heap da memory allocation\n- `Slice(10, 100)` - 10-indexdan 100 ta element\n- Zero-copy operations\n\n**Savol:** Qaysi statement yolg'on?",
        "options": [
            {
                "id": "A",
                "option": "`Slice()` yangi Span yaratadi, copy emas"
            },
            {
                "id": "B",
                "option": "`Memory<T>.Span` property orqali Span olish mumkin"
            },
            {
                "id": "C",
                "option": "`span1` stack da, `span2` heap da joylashgan"
            },
            {
                "id": "D",
                "option": "`Slice()` operatsiyasi xotira allocate qiladi"
            }
        ],
        "answer": [
            "D"
        ],
        "explanation": "✓ **Noto'g'ri statement:** `Slice()` operatsiyasi xotira allocate qiladi\n\n✓ **Zero-copy operatsiya:** `Slice()` yangi xotira allocate qilmaydi\n- Faqat mavjud memory ga yangi view (ko'rinish) yaratadi\n- Pointer va length ma'lumotlarini o'zgartiradi\n\n✓ **To'g'ri statements:**\n- A: Slice() yangi Span yaratadi, lekin copy emas\n- B: Memory<T>.Span property mavjud\n- C: span1 stack da, span2 heap da"
    },
    {
        "id": 55,
        "type": "mcq",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "priority queue"
        },
        "codeBefore": "```csharp\nvar priorityQueue = new PriorityQueue<string, int>();\npriorityQueue.Enqueue(\"task1\", 3);\npriorityQueue.Enqueue(\"task2\", 1);\npriorityQueue.Enqueue(\"task3\", 2);\nvar result = priorityQueue.Dequeue();\n```",
        "codeAfter": "",
        "prompt": "**PriorityQueue<TElement, TPriority>** (C# 10+) min-heap sifatida ishlaydi.\n\n**Kod tahlili:**\n- `Enqueue(\"task1\", 3)` - priority = 3\n- `Enqueue(\"task2\", 1)` - priority = 1\n- `Enqueue(\"task3\", 2)` - priority = 2\n- `Dequeue()` - eng kichik priority li elementni chiqaradi\n\n**Savol:** `result` ning qiymati nima?",
        "options": [
            {
                "id": "A",
                "option": "`task1`"
            },
            {
                "id": "B",
                "option": "`task2`"
            },
            {
                "id": "C",
                "option": "`task3`"
            },
            {
                "id": "D",
                "option": "Exception"
            }
        ],
        "answer": [
            "B"
        ],
        "explanation": "✓ **PriorityQueue qoidasi:** Min-heap - eng kichik priority birinchi chiqadi\n\n✓ **Priority tartiblanishi:**\n- task2: priority = 1 (eng kichik)\n- task3: priority = 2\n- task1: priority = 3\n\n✓ **Natija:** `Dequeue()` → \"task2\" (eng kichik priority)"
    },
    {
        "id": 56,
        "type": "true_false",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "dictionary"
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "**Dictionary<TKey, TValue>** da key uchun `null` qiymat qo'yish mumkin, agar `TKey` nullable type bo'lsa.\n\n**Nullable reference types (C# 8+):**\n- `string?` - nullable reference type\n- `int?` - nullable value type\n- Dictionary null key qabul qilish mumkinmi?",
        "answer": "true",
        "explanation": "✓ **To'g'ri statement**\n\n✓ **Nullable key qo'llab-quvvatlash:**\n- `Dictionary<string?, int>` - null key qabul qiladi\n- `Dictionary<int?, string>` - null key qabul qiladi\n- `Dictionary<string, int>` - null key qabul qilmaydi (non-nullable)\n\n✓ **Misol:** `dict[null] = 42` - nullable TKey uchun valid"
    },
    {
        "id": 57,
        "type": "true_false",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "set operations"
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "**HashSet<T>** collection elementlarning unique bo'lishini kafolatlaydi va tartibni saqlaydi.\n\n**HashSet xususiyatlari:**\n- Unique elementlar kafolati\n- Hash table based implementation\n- Tartib saqlash haqida gap\n- SortedSet alternative",
        "answer": "false",
        "explanation": "✗ **Yolg'on statement**\n\n✓ **HashSet xususiyatlari:**\n- Uniqueness kafolatlaydi ✓\n- Insertion tartibini saqlamaydi ✗\n- O(1) average time complexity\n- Hash table based\n\n✓ **Tartib uchun alternativalar:**\n- `SortedSet<T>` - sorted order\n- `LinkedHashSet` - insertion order (Java da, C# da yo'q)"
    },
    {
        "id": 58,
        "type": "true_false",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "indexing slicing"
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "**Index operator** `^0` massivning oxirgi elementini anglatadi.\n\n**Index operator (C# 8+):**\n- `^1` - oxirgi element\n- `^2` - oxirdan ikkinchi element\n- `^0` - nima demakchi?\n- Array bounds checking",
        "answer": "false",
        "explanation": "✗ **Yolg'on statement**\n\n✓ **Index operator qoidalari:**\n- `^0` - array length ni bildiradi (bounds dan tashqarida)\n- `^1` - oxirgi element (length - 1)\n- `^2` - oxirdan ikkinchi element (length - 2)\n\n✓ **Misol:** `arr[^0]` → `IndexOutOfRangeException`"
    },
    {
        "id": 59,
        "type": "true_false",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "indexing slicing"
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "**Range operator** `..` faqat array va string uchun ishlatiladi, boshqa collectionlar uchun emas.\n\n**Range operator (C# 8+):**\n- Array da `arr[1..3]`\n- String da `str[2..5]`\n- List<T> da ishlatish mumkinmi?\n- Span<T> da ishlatish mumkinmi?",
        "answer": "false",
        "explanation": "✗ **Yolg'on statement**\n\n✓ **Range operator qo'llab-quvvatlash:**\n- Array ✓\n- String ✓\n- List<T> ✓\n- Span<T> ✓\n- ReadOnlySpan<T> ✓\n- Memory<T> ✓\n\n✓ **Shart:** Indexer va Length/Count property ni qo'llab-quvvatlaydigan barcha collection lar"
    },
    {
        "id": 60,
        "type": "true_false",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "memory types"
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "**Span<T>** ref struct bo'lgani uchun heap da saqlanishi mumkin emas.\n\n**Ref struct limitations (C# 7.2+):**\n- Stack-only allocation\n- Heap da saqlash mumkin emasmi?\n- Class field sifatida ishlatish mumkin emasmi?\n- Boxing mumkin emasmi?",
        "answer": "true",
        "explanation": "✓ **To'g'ri statement**\n\n✓ **Ref struct limitations:**\n- Heap da saqlash mumkin emas ✓\n- Class field bo'la olmaydi ✓\n- Boxing mumkin emas ✓\n- Async method da ishlatish mumkin emas ✓\n\n✓ **Heap uchun alternativ:** `Memory<T>` - heap va stack ikkalasida ham ishlaydi"
    },
    {
        "id": 61,
        "type": "true_false",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "memory types"
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "**Memory<T>** async metodlarda ishlatish mumkin, lekin **Span<T>** ishlatib bo'lmaydi.\n\n**Async/await compatibility:**\n- Memory<T> async method da ishlatish mumkinmi?\n- Span<T> async method da ishlatish mumkinmi?\n- Ref struct limitations\n- Async state machine requirements",
        "answer": "true",
        "explanation": "✓ **To'g'ri statement**\n\n✓ **Async compatibility:**\n- `Memory<T>` async method da ishlatish mumkin ✓\n- `Span<T>` async method da ishlatish mumkin emas ✗\n\n✓ **Sababi:** Ref struct lar async state machine da saqlanishi mumkin emas\n\n✓ **Yechim:** Async uchun `Memory<T>` ishlatish, keyin `Memory<T>.Span` orqali `Span<T>` ga o'tish"
    },
    {
        "id": 62,
        "type": "true_false",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "thread safety"
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "`Queue<T>` va `Stack<T>` ikkalasi ham generic collection bo'lib, thread-safe emas.",
        "answer": "true",
        "explanation": "To'g'ri. Queue<T> va Stack<T> thread-safe emas. Multi-threading uchun ConcurrentQueue<T> va ConcurrentStack<T> ishlatiladi."
    },
    {
        "id": 63,
        "type": "true_false",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "sorted collections"
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "`SortedDictionary<TKey, TValue>` elementlarni key bo'yicha tartiblab saqlaydi.",
        "answer": "true",
        "explanation": "To'g'ri. SortedDictionary elementlarni key bo'yicha avtomatik tartiblab saqlaydi, insertion order ga qaramay."
    },
    {
        "id": 64,
        "type": "true_false",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "indexing slicing"
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "Range operator `numbers[2..]` 2-indexdan boshlab oxirigacha bo'lgan elementlarni oladi.",
        "answer": "true",
        "explanation": "To'g'ri. [2..] degani 2-indexdan boshlab oxirigacha bo'lgan barcha elementlar (2-index ham kiritiladi)."
    },
    {
        "id": 65,
        "type": "true_false",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "list types"
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "`LinkedList<T>` collection random access ni qo'llab-quvvatlaydi va indexer operator `[]` ga ega.",
        "answer": "false",
        "explanation": "Yolg'on. LinkedList<T> sequential access collection bo'lib, indexer operator [] ga ega emas. Random access uchun List<T> ishlatiladi."
    },
    {
        "id": 66,
        "type": "true_false",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "memory types"
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "`ReadOnlySpan<T>` dan `Span<T>` ga implicit conversion mumkin.",
        "answer": "false",
        "explanation": "Yolg'on. ReadOnlySpan<T> immutable, Span<T> mutable. Readonly dan writable ga implicit conversion mumkin emas."
    },
    {
        "id": 67,
        "type": "true_false",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "memory types"
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "`CollectionsMarshal.AsSpan()` metodi `List<T>` ni `Span<T>` ga xavfsiz tarzda convert qiladi.",
        "answer": "true",
        "explanation": "To'g'ri. CollectionsMarshal.AsSpan() List<T> ning ichki array ga xavfsiz access beradi va Span<T> sifatida qaytaradi."
    },
    {
        "id": 68,
        "type": "true_false",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "collection expressions"
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "Spread operator `..` C# 12 da collection expressions uchun ishlatiladi.",
        "answer": "true",
        "explanation": "To'g'ri. C# 12 da spread operator (..) collection expressions ichida existing collections ni spread qilish uchun ishlatiladi."
    },
    {
        "id": 69,
        "type": "true_false",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "thread safety"
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "`ConcurrentDictionary<TKey, TValue>` thread-safe bo'lib, lock-free operatsiyalarni qo'llab-quvvatlaydi.",
        "answer": "true",
        "explanation": "To'g'ri. ConcurrentDictionary internal lock-free algorithm ishlatib, thread-safe operatsiyalarni ta'minlaydi."
    },
    {
        "id": 70,
        "type": "true_false",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "memory types"
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "`Memory<T>` va `ReadOnlyMemory<T>` ikkalasi ham ref struct hisoblanadi.",
        "answer": "false",
        "explanation": "Yolg'on. Memory<T> va ReadOnlyMemory<T> oddiy struct lar. Faqat Span<T> va ReadOnlySpan<T> ref struct hisoblanadi."
    },
    {
        "id": 71,
        "type": "fill",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "list operations"
        },
        "codeWithBlank": "var numbers = new List<int> { 1, 2, 3, 4, 5 };\nvar result = numbers.GetRange(______, ______);\n// result should be { 2, 3, 4 }",
        "prompt": "`List<T>.GetRange(int index, int count)` metodida bo'sh joylarni to'ldiring, shunda natija `{ 2, 3, 4 }` bo'lsin.",
        "answer": "var numbers = new List<int> { 1, 2, 3, 4, 5 };\nvar result = numbers.GetRange(1, 3);\n// result should be { 2, 3, 4 }",
        "explanation": "Elements 2, 3, 4 index 1 dan boshlanadi va 3 ta element kerak: GetRange(1, 3)."
    },
    {
        "id": 72,
        "type": "fill",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "dictionary"
        },
        "codeWithBlank": "var dict = new Dictionary<string, int> { [\"a\"] = 1, [\"b\"] = 2 };\nvar success = dict.________(\"c\", ______);\n// Agar key mavjud bo'lmasa, default qiymat qaytarsin",
        "prompt": "`Dictionary<TKey, TValue>` da key mavjud bo'lmasa default qiymat qaytaradigan metod va qiymatni yozing.",
        "answer": "var dict = new Dictionary<string, int> { [\"a\"] = 1, [\"b\"] = 2 };\nvar success = dict.TryGetValue(\"c\", out var value);\n// Agar key mavjud bo'lmasa, default qiymat qaytarsin",
        "explanation": "TryGetValue metodі safe access ta'minlaydi: success false, value default qiymat bo'ladi."
    },
    {
        "id": 73,
        "type": "fill",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "indexing slicing"
        },
        "codeWithBlank": "var text = \"Hello World\";\nvar slice = text[______];\n// slice should be \"World\"",
        "prompt": "String dan \"World\" so'zini olish uchun Range operatorini yozing.",
        "answer": "var text = \"Hello World\";\nvar slice = text[6..];\n// slice should be \"World\"",
        "explanation": "'World' index 6 dan boshlanadi: text[6..] = 'World'."
    },
    {
        "id": 74,
        "type": "fill",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "memory types"
        },
        "codeWithBlank": "Span<int> span = stackalloc int[5];\nspan.Fill(________);\nvar slice = span.Slice(______, ______);\n// Fill with 42, then get middle 3 elements",
        "prompt": "`Span<T>` ni 42 bilan to'ldiring va o'rtadagi 3 ta elementni oling.",
        "answer": "Span<int> span = stackalloc int[5];\nspan.Fill(42);\nvar slice = span.Slice(1, 3);\n// Fill with 42, then get middle 3 elements",
        "explanation": "Fill(42) barcha elementlarni 42 ga o'rnatadi. O'rtadagi 3 element: index 1 dan 3 ta - Slice(1, 3)."
    },
    {
        "id": 75,
        "type": "fill",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "priority queue"
        },
        "codeWithBlank": "var queue = new PriorityQueue<string, int>();\nqueue.Enqueue(\"low\", ______);\nqueue.Enqueue(\"high\", ______);\n// \"high\" should be dequeued first",
        "prompt": "`PriorityQueue` da \"high\" birinchi chiqishi uchun priority qiymatlarini yozing.",
        "answer": "var queue = new PriorityQueue<string, int>();\nqueue.Enqueue(\"low\", 10);\nqueue.Enqueue(\"high\", 1);\n// \"high\" should be dequeued first",
        "explanation": "PriorityQueue min-heap: kichik raqam yuqori priority. 'high' birinchi chiqishi uchun 1 (kichik), 'low' uchun 10 (katta)."
    },
    {
        "id": 76,
        "type": "fill",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "set operations"
        },
        "codeWithBlank": "var hashSet1 = new HashSet<int> { 1, 2, 3 };\nvar hashSet2 = new HashSet<int> { 3, 4, 5 };\nhashSet1.________(hashSet2);\n// Result: { 1, 2, 3, 4, 5 }",
        "prompt": "Ikki `HashSet` ni birlashtirib, barcha unique elementlarni olish uchun metod nomini yozing.",
        "answer": "var hashSet1 = new HashSet<int> { 1, 2, 3 };\nvar hashSet2 = new HashSet<int> { 3, 4, 5 };\nhashSet1.UnionWith(hashSet2);\n// Result: { 1, 2, 3, 4, 5 }",
        "explanation": "UnionWith matematik union operatsiyasi - ikkala to'plamning barcha unique elementlarini birlashtirib, hashSet1 ni o'zgartiradi."
    },
    {
        "id": 77,
        "type": "fill",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "collection expressions"
        },
        "codeWithBlank": "var list1 = new List<int> { 1, 2 };\nvar list2 = new List<int> { 3, 4 };\nvar combined = [______];\n// Use collection expression with spread",
        "prompt": "C# 12 collection expression da spread operator yordamida ikki listni birlashtiring.",
        "answer": "var list1 = new List<int> { 1, 2 };\nvar list2 = new List<int> { 3, 4 };\nvar combined = [..list1, ..list2];\n// Use collection expression with spread",
        "explanation": "Collection expression da .. spread operator existing collection larni expand qiladi: [..list1, ..list2] = [1, 2, 3, 4]."
    },
    {
        "id": 78,
        "type": "fill",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "memory types"
        },
        "codeWithBlank": "var numbers = new int[] { 1, 2, 3, 4, 5 };\nvar memory = numbers.AsMemory();\nvar slice = memory.Slice(______, ______);\n// Get elements 2, 3, 4",
        "prompt": "`Memory<T>` dan elementlar 2, 3, 4 ni olish uchun `Slice` parametrlarini yozing.",
        "answer": "var numbers = new int[] { 1, 2, 3, 4, 5 };\nvar memory = numbers.AsMemory();\nvar slice = memory.Slice(1, 3);\n// Get elements 2, 3, 4",
        "explanation": "Elements 2, 3, 4 index 1 dan boshlanadi va 3 ta element: Memory.Slice(1, 3)."
    },
    {
        "id": 79,
        "type": "fill",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "sorted collections"
        },
        "codeWithBlank": "var sortedDict = new SortedDictionary<int, string>();\nsortedDict.Add(3, \"three\");\nsortedDict.Add(1, \"one\");\nsortedDict.Add(2, \"two\");\nvar firstKey = sortedDict.________.________;\n// Get the first key",
        "prompt": "`SortedDictionary` da birinchi key ni olish uchun property chain ni yozing.",
        "answer": "var sortedDict = new SortedDictionary<int, string>();\nsortedDict.Add(3, \"three\");\nsortedDict.Add(1, \"one\");\nsortedDict.Add(2, \"two\");\nvar firstKey = sortedDict.Keys.First();\n// Get the first key",
        "explanation": "SortedDictionary avtomatik tartiblab saqlaydi. Keys property sorted keys collection, First() birinchi key (1) ni qaytaradi."
    },
    {
        "id": 80,
        "type": "fill",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "memory types"
        },
        "codeWithBlank": "ReadOnlySpan<char> text = \"Hello\";\nvar index = text.IndexOf(________);\nif (index >= 0)\n{\n    var found = text[index];\n}",
        "prompt": "`ReadOnlySpan<char>` da 'l' harfini qidirish uchun parametrni yozing.",
        "answer": "ReadOnlySpan<char> text = \"Hello\";\nvar index = text.IndexOf('l');\nif (index >= 0)\n{\n    var found = text[index];\n}",
        "explanation": "IndexOf() metodi char parameter qabul qiladi. Single quotes bilan character literal 'l' ishlatiladi."
    },
    {
        "id": 81,
        "type": "error_spotting",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "memory types"
        },
        "codeWithError": "var list = new List<int> { 1, 2, 3, 4, 5 };\nvar span = list.AsSpan();\nlist.Add(6);\nConsole.WriteLine(span.Length);",
        "prompt": "`List<T>` ga element qo'shgandan so'ng `Span<T>` ishlatishda xatolik bor. Xatoni toping va tushuntiring.",
        "answer": "var list = new List<int> { 1, 2, 3, 4, 5 };\nvar span = CollectionsMarshal.AsSpan(list);\n// list.Add(6); // Bu dangerous - span invalid bo'ladi\nConsole.WriteLine(span.Length);",
        "explanation": "List ga element qo'shish internal array ni reallocate qilishi mumkin, span invalid bo'ladi. CollectionsMarshal ishlatib, list ni modify qilmaslik kerak."
    },
    {
        "id": 82,
        "type": "error_spotting",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "dictionary"
        },
        "codeWithError": "var dict = new Dictionary<string?, int>();\ndict.Add(null, 1);\ndict.Add(null, 2);\nConsole.WriteLine(dict.Count);",
        "prompt": "`Dictionary` da `null` key bilan bog'liq xatolikni toping va to'g'rilang.",
        "answer": "var dict = new Dictionary<string?, int>();\ndict.Add(null, 1);\n// dict.Add(null, 2); // Exception - duplicate key\ndict[null] = 2; // Bu to'g'ri - key ni update qiladi\nConsole.WriteLine(dict.Count);",
        "explanation": "Add() metodi duplicate key uchun exception beradi, null ham key hisoblanadi. Update uchun indexer [] ishlatiladi."
    },
    {
        "id": 83,
        "type": "error_spotting",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "indexing slicing"
        },
        "codeWithError": "var numbers = new int[] { 1, 2, 3, 4, 5 };\nvar range = 2..^0;\nvar slice = numbers[range];\nConsole.WriteLine(slice.Length);",
        "prompt": "Range operatorida xatolik bor. `^0` nima anglatadi va qanday to'g'rilash kerak?",
        "answer": "var numbers = new int[] { 1, 2, 3, 4, 5 };\nvar range = 2..^1; // ^0 is beyond end, ^1 is last element\nvar slice = numbers[range];\nConsole.WriteLine(slice.Length);",
        "explanation": "^0 array length pozitsiyasi (bounds dan tashqari). Range uchun ^1 ishlatiladi (oxirgi element, exclusive boundary)."
    },
    {
        "id": 84,
        "type": "error_spotting",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "memory types"
        },
        "codeWithError": "async Task ProcessAsync()\n{\n    Span<byte> buffer = stackalloc byte[1024];\n    await SomeAsyncMethod(buffer);\n}",
        "prompt": "`Span<T>` ni async metod ichida ishlatishdagi xatolikni toping va to'g'rilang.",
        "answer": "async Task ProcessAsync()\n{\n    Memory<byte> buffer = new byte[1024];\n    await SomeAsyncMethod(buffer);\n    // Yoki: var buffer = new byte[1024].AsMemory();\n}",
        "explanation": "Span<T> ref struct bo'lib, async metodlarda ishlatib bo'lmaydi. Memory<T> async-safe alternative hisoblanadi."
    },
    {
        "id": 85,
        "type": "error_spotting",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "queue"
        },
        "codeWithError": "var queue = new Queue<int>();\nqueue.Enqueue(1);\nqueue.Enqueue(2);\nvar result = queue.Peek();\nqueue.Clear();\nvar next = queue.Peek();",
        "prompt": "Bo'sh `Queue` dan element olishdagi xatolikni toping va to'g'rilang.",
        "answer": "var queue = new Queue<int>();\nqueue.Enqueue(1);\nqueue.Enqueue(2);\nvar result = queue.Peek();\nqueue.Clear();\nvar next = queue.Count > 0 ? queue.Peek() : 0; // Check before peek",
        "explanation": "Bo'sh Queue dan Peek() InvalidOperationException beradi. Count > 0 check qilib, safe access ta'minlash kerak."
    },
    {
        "id": 86,
        "type": "error_spotting",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "collection expressions"
        },
        "codeWithError": "var numbers = new List<int> { 1, 2, 3 };\nvar combined = [numbers, 4, 5];\nConsole.WriteLine(combined.Count);",
        "prompt": "Collection expression da spread operatorisiz ishlatishdagi xatolikni toping.",
        "answer": "var numbers = new List<int> { 1, 2, 3 };\nvar combined = [..numbers, 4, 5]; // Need spread operator\nConsole.WriteLine(combined.Count);",
        "explanation": "Collection expression da existing collection ni spread qilmasdan embed qilib bo'lmaydi. [..numbers, 4, 5] syntax kerak."
    },
    {
        "id": 87,
        "type": "error_spotting",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "memory types"
        },
        "codeWithError": "ReadOnlySpan<int> span = new int[] { 1, 2, 3 };\nspan[0] = 10;\nConsole.WriteLine(span[0]);",
        "prompt": "`ReadOnlySpan<T>` da elementni o'zgartirishdagi xatolikni toping.",
        "answer": "Span<int> span = new int[] { 1, 2, 3 }; // Use Span<T> instead\nspan[0] = 10;\nConsole.WriteLine(span[0]);",
        "explanation": "ReadOnlySpan<T> immutable - elementlarni o'zgartirib bo'lmaydi. Mutable operation uchun Span<T> ishlatiladi."
    },
    {
        "id": 88,
        "type": "error_spotting",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "stack"
        },
        "codeWithError": "var stack = new Stack<string>();\nstack.Push(\"first\");\nstack.Push(\"second\");\nvar items = stack.ToArray();\nConsole.WriteLine(items[0]);",
        "prompt": "`Stack<T>.ToArray()` metodining natijasida elementlar tartibini to'g'ri tushuntiring.",
        "answer": "var stack = new Stack<string>();\nstack.Push(\"first\");\nstack.Push(\"second\");\nvar items = stack.ToArray();\n// items[0] is \"second\" (LIFO order)\nConsole.WriteLine(items[0]); // Prints \"second\"",
        "explanation": "ToArray() LIFO tartibni saqlaydi: oxirgi push qilingan element array ning birinchi elementi bo'ladi."
    },
    {
        "id": 89,
        "type": "error_spotting",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "indexing slicing"
        },
        "codeWithError": "var text = \"Hello World\";\nvar slice = text[5..^5];\nConsole.WriteLine(slice);",
        "prompt": "String slicing da index va range xatoligini toping va to'g'rilang.",
        "answer": "var text = \"Hello World\";\nvar slice = text[6..^0]; // Start from 6 (space after Hello), go to end\n// Or: var slice = text[6..]; for \"World\"\nConsole.WriteLine(slice);",
        "explanation": "\"Hello World\" uzunligi 11. [5..^5] = [5..6] = \" \" (faqat space). \"World\" uchun [6..] kerak."
    },
    {
        "id": 90,
        "type": "error_spotting",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "memory types"
        },
        "codeWithError": "var memory = new Memory<int>();\nvar span = memory.Span;\nspan[0] = 42;\nConsole.WriteLine(span[0]);",
        "prompt": "Bo'sh `Memory<T>` dan `Span<T>` olish va ishlatishdagi xatolikni toping.",
        "answer": "var memory = new Memory<int>(new int[10]); // Initialize with array\nvar span = memory.Span;\nspan[0] = 42;\nConsole.WriteLine(span[0]);",
        "explanation": "Default Memory<T>() constructor bo'sh memory yaratadi. Array bilan initialize qilish kerak: new Memory<int>(new int[10])."
    },
    {
        "id": 91,
        "type": "output_prediction",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "dictionary"
        },
        "snippet": "var dict = new Dictionary<int, string> { [1] = \"one\", [2] = \"two\" };\ndict.TryAdd(1, \"ONE\");\ndict.TryAdd(3, \"three\");\nConsole.WriteLine($\"{dict[1]}, {dict.Count}\");",
        "prompt": "`Dictionary.TryAdd()` metodi mavjud key uchun qanday ishlaydi?",
        "answer": "one, 3",
        "explanation": "TryAdd mavjud key (1) ni update qilmaydi, faqat yangi key (3) ni qo'shadi. dict[1] = \"one\" qoladi, Count = 3."
    },
    {
        "id": 92,
        "type": "output_prediction",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "indexing slicing"
        },
        "snippet": "var numbers = new int[] { 10, 20, 30, 40, 50 };\nvar slice1 = numbers[1..4];\nvar slice2 = numbers[^3..^1];\nConsole.WriteLine($\"{slice1.Length}, {slice2.Length}\");",
        "prompt": "Range operatorlari bilan slice olishda uzunliklar qanday bo'ladi?",
        "answer": "3, 2",
        "explanation": "slice1[1..4] = {20,30,40} (length=3), slice2[^3..^1] = {30,40} (index 2..4, length=2)."
    },
    {
        "id": 93,
        "type": "output_prediction",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "set operations"
        },
        "snippet": "var hashSet = new HashSet<int> { 1, 2, 3, 1, 2 };\nConsole.WriteLine(hashSet.Count);\nvar list = new List<int> { 1, 2, 3, 1, 2 };\nConsole.WriteLine(list.Count);",
        "prompt": "`HashSet` va `List` da duplicate elementlar qanday ishlanadi?",
        "answer": "3\n5",
        "explanation": "HashSet faqat unique elementlarni saqlaydi (Count=3), List barcha elementlarni saqlaydi including duplicates (Count=5)."
    },
    {
        "id": 94,
        "type": "output_prediction",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "memory types"
        },
        "snippet": "Span<int> span = stackalloc int[3] { 1, 2, 3 };\nspan.Reverse();\nvar array = span.ToArray();\nConsole.WriteLine(string.Join(\", \", array));",
        "prompt": "`Span<T>.Reverse()` metodining natijasi qanday bo'ladi?",
        "answer": "3, 2, 1",
        "explanation": "Reverse() span ni in-place reverse qiladi: {1,2,3} → {3,2,1}. ToArray() reversed contentni array ga convert qiladi."
    },
    {
        "id": 95,
        "type": "output_prediction",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "queue"
        },
        "snippet": "var queue = new Queue<char>();\nforeach (char c in \"ABC\")\n    queue.Enqueue(c);\nwhile (queue.Count > 0)\n    Console.Write(queue.Dequeue());",
        "prompt": "`Queue<T>` FIFO tartibda elementlarni qanday chiqaradi?",
        "answer": "ABC",
        "explanation": "Queue FIFO: birinchi kiritilgan (A) birinchi chiqadi. Enqueue order: A→B→C, Dequeue order: A→B→C."
    },
    {
        "id": 96,
        "type": "output_prediction",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "stack"
        },
        "snippet": "var stack = new Stack<char>();\nforeach (char c in \"ABC\")\n    stack.Push(c);\nwhile (stack.Count > 0)\n    Console.Write(stack.Pop());",
        "prompt": "`Stack<T>` LIFO tartibda elementlarni qanday chiqaradi?",
        "answer": "CBA",
        "explanation": "Stack LIFO: oxirgi kiritilgan (C) birinchi chiqadi. Push order: A→B→C, Pop order: C→B→A."
    },
    {
        "id": 97,
        "type": "output_prediction",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "collection expressions"
        },
        "snippet": "var list1 = new List<int> { 1, 2 };\nvar list2 = new List<int> { 3, 4 };\nvar combined = [..list1, 5, ..list2];\nConsole.WriteLine(string.Join(\", \", combined));",
        "prompt": "Collection expression da spread operator qanday ishlaydi?",
        "answer": "1, 2, 5, 3, 4",
        "explanation": "Collection expression left-to-right evaluate: ..list1 (1,2), then 5, then ..list2 (3,4) = [1,2,5,3,4]."
    },
    {
        "id": 98,
        "type": "output_prediction",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "priority queue"
        },
        "snippet": "var priorityQueue = new PriorityQueue<string, int>();\npriorityQueue.Enqueue(\"C\", 3);\npriorityQueue.Enqueue(\"A\", 1);\npriorityQueue.Enqueue(\"B\", 2);\nConsole.WriteLine(priorityQueue.Dequeue());",
        "prompt": "`PriorityQueue` eng kichik priority ni birinchi chiqaradi. Natija nima?",
        "answer": "A",
        "explanation": "PriorityQueue min-heap: eng kichik priority (1) birinchi chiqadi. \"A\" ning priority si 1 - eng kichik."
    },
    {
        "id": 99,
        "type": "output_prediction",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "memory types"
        },
        "snippet": "ReadOnlySpan<char> text = \"Hello World\";\nvar index = text.LastIndexOf('l');\nConsole.WriteLine($\"{index}, {text[index]}\");",
        "prompt": "`ReadOnlySpan<char>` da oxirgi 'l' harfining indexi va qiymati?",
        "answer": "9, l",
        "explanation": "\"Hello World\" da 'l' lar: index 2, 3, 9. LastIndexOf() oxirgi occurrence (index 9) ni qaytaradi."
    },
    {
        "id": 100,
        "type": "output_prediction",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "memory types"
        },
        "snippet": "var memory = \"Hello\".AsMemory();\nvar span = memory.Span;\nvar slice = span[1..^1];\nConsole.WriteLine(slice.ToString());",
        "prompt": "String dan `Memory<T>` va `Span<T>` orqali slice olishda natija?",
        "answer": "ell",
        "explanation": "\"Hello\" → Memory → Span → slice[1..^1] = [1..4] = \"ell\" (index 1 dan 4 gacha, oxirgi char ni exclude qilib)."
    },
    {
        "id": 101,
        "type": "code_writing",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "system design"
        },
        "prompt": "### Generic Collection Manager\n\n`CollectionManager<T>` generic klassi yarating. Bu klass quyidagi collectionlarni boshqarsin:\n- `List<T>` - asosiy saqlash uchun\n- `HashSet<T>` - unique elementlar uchun\n- `Queue<T>` - FIFO operatsiyalar uchun\n\nMetodlar:\n- `AddItem(T item)` - barcha collectionlarga qo'shadi\n- `RemoveItem(T item)` - barcha collectionlardan olib tashlaydi\n- `GetUniqueCount()` - unique elementlar sonini qaytaradi\n- `GetNextInQueue()` - queue dan keyingi elementni oladi\n\n`where T : IEquatable<T>` constraint ishlating.",
        "examples": [
            "var manager = new CollectionManager<int>();\nmanager.AddItem(1);\nmanager.AddItem(1); // duplicate\nConsole.WriteLine(manager.GetUniqueCount()); // 1"
        ]
    },
    {
        "id": 102,
        "type": "code_writing",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "array operations"
        },
        "prompt": "### Array Slicer with Range/Index\n\n`ArraySlicer` static klassi yarating. Quyidagi metodlarni implement qiling:\n- `GetSlice<T>(T[] array, Range range)` - Range operatori bilan slice oladi\n- `GetFromEnd<T>(T[] array, Index index)` - Oxiridan sanab index oladi\n- `GetMiddle<T>(T[] array)` - O'rtadagi elementlar (1/4 dan 3/4 gacha)\n- `SplitArray<T>(T[] array, int parts)` - Arrayni teng qismlarga bo'ladi\n\nHar bir metod appropriate range/index operatorlarini ishlating.",
        "examples": [
            "var numbers = new[] { 1, 2, 3, 4, 5, 6, 7, 8 };\nvar middle = ArraySlicer.GetMiddle(numbers); // { 3, 4, 5, 6 }\nvar fromEnd = ArraySlicer.GetFromEnd(numbers, ^2); // 7"
        ]
    },
    {
        "id": 103,
        "type": "code_writing",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "memory management"
        },
        "prompt": "### Memory-Efficient Buffer Processor\n\n`BufferProcessor` klassi yarating. Katta massivlar bilan ishlash uchun `Memory<T>` va `Span<T>` dan foydalaning:\n\n- `ProcessChunks<T>(Memory<T> memory, int chunkSize, Action<Span<T>> processor)`\n- `FindPattern<T>(ReadOnlyMemory<T> memory, ReadOnlySpan<T> pattern) where T : IEquatable<T>`\n- `ReverseInPlace<T>(Memory<T> memory)`\n- `CopyWithTransform<T>(ReadOnlyMemory<T> source, Memory<T> destination, Func<T, T> transform)`\n\nStackalloc va heap allocation ni optimal tarzda ishlating.",
        "examples": [
            "var data = new int[1000].AsMemory();\nprocessor.ProcessChunks(data, 100, chunk => {\n    // Process each 100-element chunk\n});"
        ]
    },
    {
        "id": 104,
        "type": "code_writing",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "data storage systems"
        },
        "prompt": "### Multi-Collection Data Store\n\n`DataStore<T>` klassi yarating, quyidagilarni implement qiling:\n- `Dictionary<string, T>` - key-value storage\n- `SortedDictionary<DateTime, T>` - chronological storage\n- `PriorityQueue<T, int>` - priority-based processing\n\nMetodlar:\n- `Store(string key, T value, int priority = 0)`\n- `GetByKey(string key)` - dictionary dan\n- `GetByTimeRange(DateTime start, DateTime end)` - time range bo'yicha\n- `ProcessNext()` - priority queue dan\n- `GetStatistics()` - har bir collection bo'yicha ma'lumot\n\nTurli collection typelarining xususiyatlarini to'g'ri ishlating.",
        "examples": [
            "var store = new DataStore<string>();\nstore.Store(\"task1\", \"Important task\", priority: 1);\nstore.Store(\"task2\", \"Urgent task\", priority: 10);\nvar next = store.ProcessNext(); // \"Important task\" (lower priority first)"
        ]
    },
    {
        "id": 105,
        "type": "code_writing",
        "metadata": {
            "category": "kolleksiyalar-ma'lumot-tuzilmalari",
            "subcategory": "modern collection features"
        },
        "prompt": "### Collection Expression Builder\n\nC# 12 collection expressions va spread operator ishlatib `CollectionBuilder` static klassi yarating:\n\n- `Combine<T>(params IEnumerable<T>[] collections)` - spread bilan birlashtirishc\n- `Interleave<T>(IEnumerable<T> first, IEnumerable<T> second)` - elementlarni navbatma-navbat\n- `CreateRange(int start, int count, int step = 1)` - arithmetic progression\n- `FilterAndCombine<T>(Func<T, bool> predicate, params IEnumerable<T>[] collections)`\n\nCollection expressions `[..]` sintaksisini ishlatib, performance optimized bo'lsin.",
        "examples": [
            "var list1 = [1, 2, 3];\nvar list2 = [4, 5, 6];\nvar combined = CollectionBuilder.Combine(list1, list2); // [1, 2, 3, 4, 5, 6]\nvar range = CollectionBuilder.CreateRange(0, 5, 2); // [0, 2, 4, 6, 8]"
        ]
    },
    {
        "id": 106,
        "type": "mcq",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "basic linq operations"
        },
        "codeBefore": "```csharp\nvar numbers = new[] { 1, 2, 3, 4, 5, 6 };\nvar result = numbers\n    .Where(x => x % 2 == 0)\n    .Select(x => x * x)\n    .Sum();\n```",
        "codeAfter": "",
        "prompt": "LINQ chain operatsiyalari: juft sonlarni tanlab, kvadratga ko'tarib, yig'indisini hisoblamoqda. `result` nima bo'ladi?",
        "options": [
            {
                "id": "A",
                "option": "`56` - (2² + 4² + 6² = 4 + 16 + 36)"
            },
            {
                "id": "B",
                "option": "`36` - faqat 6²"
            },
            {
                "id": "C",
                "option": "`91` - barcha sonlarning kvadrati yig'indisi"
            },
            {
                "id": "D",
                "option": "`12` - juft sonlar yig'indisi"
            }
        ],
        "answer": [
            "A"
        ],
        "explanation": "Where(x => x % 2 == 0): [2,4,6] → Select(x => x * x): [4,16,36] → Sum(): 56"
    },
    {
        "id": 107,
        "type": "mcq",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "grouping operations"
        },
        "codeBefore": "```csharp\nvar students = new[]\n{\n    new { Name = \"Ali\", Grade = 85 },\n    new { Name = \"Bobur\", Grade = 92 },\n    new { Name = \"Zara\", Grade = 78 }\n};\nvar result = students\n    .GroupBy(s => s.Grade >= 80 ? \"High\" : \"Low\")\n    .ToDictionary(g => g.Key, g => g.Count());\n```",
        "codeAfter": "",
        "prompt": "Students ni grade bo'yicha grouping qilib, har guruhda nechta student borligini hisoblamoqda. `result` nima?",
        "options": [
            {
                "id": "A",
                "option": "`{ \"High\": 2, \"Low\": 1 }` - 80+ va 80- bo'yicha guruhlash"
            },
            {
                "id": "B",
                "option": "`{ \"High\": 1, \"Low\": 2 }` - teskari hisoblash"
            },
            {
                "id": "C",
                "option": "`{ \"85\": 1, \"92\": 1, \"78\": 1 }` - har grade bo'yicha"
            },
            {
                "id": "D",
                "option": "Exception - anonymous type bilan muammo"
            }
        ],
        "answer": [
            "A"
        ],
        "explanation": "GroupBy key: Grade≥80 ? \"High\" : \"Low\" → Ali,Bobur: High(2), Zara: Low(1)"
    },
    {
        "id": 108,
        "type": "mcq",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "set operations"
        },
        "codeBefore": "```csharp\nvar list1 = new[] { 1, 2, 3, 4 };\nvar list2 = new[] { 3, 4, 5, 6 };\nvar union = list1.Union(list2).OrderBy(x => x);\nvar intersect = list1.Intersect(list2);\nConsole.WriteLine($\"{union.Count()}, {intersect.Count()}\");\n```",
        "codeAfter": "",
        "prompt": "Set operatsiyalari: `Union` barcha unique elementlar, `Intersect` umumiy elementlar. Natija?",
        "options": [
            {
                "id": "A",
                "option": "`6, 2` - union: {1,2,3,4,5,6}, intersect: {3,4}"
            },
            {
                "id": "B",
                "option": "`8, 4` - barcha elementlar va duplicate"
            },
            {
                "id": "C",
                "option": "`4, 2` - faqat birinchi array"
            },
            {
                "id": "D",
                "option": "`6, 0` - intersection yo'q"
            }
        ],
        "answer": [
            "A"
        ],
        "explanation": "Union: {1,2,3,4,5,6} unique = 6 elements, Intersect: {3,4} common = 2 elements"
    },
    {
        "id": 109,
        "type": "mcq",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "sorting operations"
        },
        "codeBefore": "```csharp\nvar data = new[] { \"apple\", \"banana\", \"apricot\", \"cherry\" };\nvar result = data\n    .Where(x => x.StartsWith(\"a\"))\n    .OrderByDescending(x => x.Length)\n    .ThenBy(x => x)\n    .First();\n```",
        "codeAfter": "",
        "prompt": "Multi-level sorting: avval uzunlik bo'yicha kamayish, keyin alfavit bo'yicha o'sish. Birinchi element?",
        "options": [
            {
                "id": "A",
                "option": "`\"apricot\"` - eng uzun 'a' bilan boshlanuvchi"
            },
            {
                "id": "B",
                "option": "`\"apple\"` - alfabetik jihatdan birinchi"
            },
            {
                "id": "C",
                "option": "`\"banana\"` - eng uzun"
            },
            {
                "id": "D",
                "option": "Exception - 'a' bilan boshlanuvchi yo'q"
            }
        ],
        "answer": [
            "A"
        ],
        "explanation": "Where('a'): [apple,apricot] → OrderByDescending(length): apricot(7), apple(5) → First(): apricot"
    },
    {
        "id": 110,
        "type": "mcq",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "query syntax"
        },
        "codeBefore": "```csharp\nvar query = from n in Enumerable.Range(1, 10)\n            let square = n * n\n            where square % 2 == 0\n            select new { Number = n, Square = square };\nvar result = query.Take(3).Sum(x => x.Square);\n```",
        "codeAfter": "",
        "prompt": "Query syntax: `let` keyword va deferred execution. Birinchi 3 ta juft kvadratning yig'indisi?",
        "options": [
            {
                "id": "A",
                "option": "`56` - (4 + 16 + 36 from 2², 4², 6²)"
            },
            {
                "id": "B",
                "option": "`30` - (1² + 2² + 3² ning jufti)"
            },
            {
                "id": "C",
                "option": "`20` - (2 + 4 + 6)²"
            },
            {
                "id": "D",
                "option": "`84` - barcha juft kvadratlar"
            }
        ],
        "answer": [
            "A"
        ],
        "explanation": "Range(1,10) → let square → where even squares: [4,16,36,64,100] → Take(3): [4,16,36] → Sum: 56"
    },
    {
        "id": 111,
        "type": "true_false",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "operation semantics"
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "LINQ da `Where().Select()` chain `Select().Where()` bilan bir xil natija beradi, faqat performance farq qilishi mumkin.",
        "answer": "false",
        "explanation": "Yolg'on. Where() va Select() commutative emas. Where(condition).Select(transform) ≠ Select(transform).Where(condition) chunki condition original value lar uchun, transform uchun emas."
    },
    {
        "id": 112,
        "type": "true_false",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "execution behavior"
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "`IEnumerable<T>` da LINQ operatsiyalari deferred execution qo'llaydi, ya'ni `ToList()` chaqirilgunga qadar execute bo'lmaydi.",
        "answer": "true",
        "explanation": "To'g'ri. LINQ operatsiyalari deferred (lazy) execution ishlatadi. Query definition vaqtida execute bo'lmaydi, balki enumeration (ToList, foreach, Count) paytida execute bo'ladi."
    },
    {
        "id": 113,
        "type": "true_false",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "grouping operations"
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "`GroupBy()` metodi natijasi `IGrouping<TKey, TElement>` tipidagi elementlardan iborat `IEnumerable` qaytaradi.",
        "answer": "true",
        "explanation": "To'g'ri. GroupBy() natijasi IEnumerable<IGrouping<TKey, TElement>> qaytaradi. Har bir IGrouping bir group ni represents qiladi va Key property va elements ga access beradi."
    },
    {
        "id": 114,
        "type": "true_false",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "element selection"
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "`First()` va `FirstOrDefault()` farqi shundaki, birinchisi exception beradi, ikkinchisi default qiymat qaytaradi.",
        "answer": "true",
        "explanation": "To'g'ri. First() bo'sh collection yoki condition match qilmaydigan holda InvalidOperationException beradi. FirstOrDefault() default(T) qaytaradi."
    },
    {
        "id": 115,
        "type": "true_false",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "provider support"
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "LINQ query syntax faqat `IEnumerable<T>` bilan ishlaydi, `IQueryable<T>` bilan ishlatib bo'lmaydi.",
        "answer": "false",
        "explanation": "Yolg'on. LINQ query syntax IQueryable<T> bilan ham ishlaydi. Bu LINQ to SQL, Entity Framework va boshqa query provider lar uchun juda muhim."
    },
    {
        "id": 116,
        "type": "fill",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "basic linq chain"
        },
        "codeWithBlank": "var numbers = new[] { 1, 2, 3, 4, 5 };\nvar result = numbers\n    .________(x => x > 2)\n    .________(x => x * 2)\n    .________();\n// Result should be [6, 8, 10]",
        "prompt": "LINQ chain: 2 dan katta sonlarni filterlash, 2 ga ko'paytirish, array ga aylantirish.",
        "answer": "var numbers = new[] { 1, 2, 3, 4, 5 };\nvar result = numbers\n    .Where(x => x > 2)\n    .Select(x => x * 2)\n    .ToArray();\n// Result should be [6, 8, 10]",
        "explanation": "Where(filtering) → Select(transformation) → ToArray(materialization) chain pattern."
    },
    {
        "id": 117,
        "type": "fill",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "grouping and aggregation"
        },
        "codeWithBlank": "var words = new[] { \"hello\", \"world\", \"linq\", \"query\" };\nvar grouped = words\n    .________(w => w.Length)\n    .________(g => g.Key, g => g.______());\n// Group by length, then create dictionary with counts",
        "prompt": "So'zlarni uzunlik bo'yicha guruhlab, har guruhda nechta element borligini dictionary sifatida qaytaring.",
        "answer": "var words = new[] { \"hello\", \"world\", \"linq\", \"query\" };\nvar grouped = words\n    .GroupBy(w => w.Length)\n    .ToDictionary(g => g.Key, g => g.Count());\n// Group by length, then create dictionary with counts",
        "explanation": "GroupBy(length) creates groups → ToDictionary(key, count) creates Dictionary<int, int>."
    },
    {
        "id": 118,
        "type": "fill",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "pagination and filtering"
        },
        "codeWithBlank": "var source = Enumerable.Range(1, 100);\nvar result = source\n    .________(10)        // Skip first 10\n    .________(5)         // Take next 5\n    .________(x => x % 2 == 1)  // Only odd numbers\n    .Sum();",
        "prompt": "Pagination va filtering: birinchi 10 tani o'tkazib yuborish, keyingi 5 tani olish, faqat toqlarini yig'ish.",
        "answer": "var source = Enumerable.Range(1, 100);\nvar result = source\n    .Skip(10)        // Skip first 10\n    .Take(5)         // Take next 5\n    .Where(x => x % 2 == 1)  // Only odd numbers\n    .Sum();",
        "explanation": "Skip(10) → Take(5) → Where(odd) → Sum(): pagination keyin filtering, oxirida aggregation."
    },
    {
        "id": 119,
        "type": "fill",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "quantifier methods"
        },
        "codeWithBlank": "var people = new[]\n{\n    new { Name = \"Ali\", Age = 25 },\n    new { Name = \"Sara\", Age = 30 }\n};\nvar result = people\n    .________(p => p.Age > 20)\n    .________(p => ________);\n// Check if any person older than 20, then check if all are older than 18",
        "prompt": "Quantifier methods: biror kishi 20 yoshdan katta bo'lsa, barcha kishilar 18 dan katta ekanligini tekshiring.",
        "answer": "var people = new[]\n{\n    new { Name = \"Ali\", Age = 25 },\n    new { Name = \"Sara\", Age = 30 }\n};\nvar hasOlder = people.Any(p => p.Age > 20);\nvar allAdults = people.All(p => p.Age > 18);\n// Check if any person older than 20, then check if all are older than 18",
        "explanation": "Any(condition) checks existence, All(condition) checks universal truth. Separate variables for clarity."
    },
    {
        "id": 120,
        "type": "fill",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "join operations"
        },
        "codeWithBlank": "var customers = new[] { \"Alice\", \"Bob\", \"Charlie\" };\nvar orders = new[] { \"Alice\", \"Alice\", \"Bob\", \"David\" };\nvar result = customers\n    .________(orders, c => c, o => o, (c, orderGroup) => \n        new { Customer = c, OrderCount = orderGroup.________ });\n// Group join to count orders per customer",
        "prompt": "Group join: har bir customer uchun order sonini hisoblash. Ba'zi customerlarning orderi yo'q bo'lishi mumkin.",
        "answer": "var customers = new[] { \"Alice\", \"Bob\", \"Charlie\" };\nvar orders = new[] { \"Alice\", \"Alice\", \"Bob\", \"David\" };\nvar result = customers\n    .GroupJoin(orders, c => c, o => o, (c, orderGroup) => \n        new { Customer = c, OrderCount = orderGroup.Count() });\n// Group join to count orders per customer",
        "explanation": "GroupJoin() creates left join with grouped results. Count() calculates orders per customer, including zero."
    },
    {
        "id": 121,
        "type": "error_spotting",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "deferred execution"
        },
        "codeWithError": "var numbers = new[] { 1, 2, 3, 4, 5 };\nvar query = numbers.Where(x => x > 2);\nnumbers[0] = 10;\nvar result = query.ToList();\nConsole.WriteLine(result.Count);",
        "prompt": "Deferred execution muammosi: query yaratilgandan keyin source data o'zgardi. Natija qanday bo'ladi?",
        "answer": "var numbers = new[] { 1, 2, 3, 4, 5 };\nvar query = numbers.Where(x => x > 2);\n// query hali execute bo'lmagan (deferred)\nnumbers[0] = 10;  // source data o'zgardi\nvar result = query.ToList();  // endi execute bo'ladi: [10, 3, 4, 5]\nConsole.WriteLine(result.Count);  // 4",
        "explanation": "Deferred execution: query creation vaqtida execute bo'lmaydi, ToList() chaqirilganda execute bo'ladi va o'zgartrilgan source data ishlatiladi."
    },
    {
        "id": 122,
        "type": "error_spotting",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "pipeline correctness"
        },
        "codeWithError": "var data = new[] { 1, 2, 3 };\nvar result = data\n    .Select(x => x * 2)\n    .Where(x => x > 3)\n    .First();\n// Should get first element > 3 after doubling",
        "prompt": "LINQ chain mantiqan to'g'ri, lekin qiymatlarni tekshirib ko'ring. 4 dan katta birinchi element topiladi?",
        "answer": "var data = new[] { 1, 2, 3 };\nvar result = data\n    .Select(x => x * 2)    // [2, 4, 6]\n    .Where(x => x > 3)     // [4, 6]\n    .First();              // 4\n// Natija: 4 (to'g'ri ishlaydi)",
        "explanation": "Bu 'trick question' - kod aslida to'g'ri ishlaydi. Select(x2): [2,4,6] → Where(>3): [4,6] → First(): 4."
    },
    {
        "id": 123,
        "type": "error_spotting",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "enumeration safety"
        },
        "codeWithError": "var items = new List<int> { 1, 2, 3, 4, 5 };\nforeach (var item in items.Where(x => x % 2 == 0))\n{\n    items.Remove(item);\n}\nConsole.WriteLine(items.Count);",
        "prompt": "Collection modification during enumeration xatosi. LINQ query execute bo'layotganda source collection o'zgartirilmoqda.",
        "answer": "var items = new List<int> { 1, 2, 3, 4, 5 };\n// To'g'ri yondashuv: avval natijani materialize qiling\nvar toRemove = items.Where(x => x % 2 == 0).ToList();\nforeach (var item in toRemove)\n{\n    items.Remove(item);\n}\nConsole.WriteLine(items.Count);",
        "explanation": "Collection modification during enumeration InvalidOperationException beradi. Avval ToList() qilib materialize qilish kerak."
    },
    {
        "id": 124,
        "type": "error_spotting",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "element selection"
        },
        "codeWithError": "var numbers = new[] { 1, 2, 3 };\nvar result = numbers\n    .GroupBy(x => x % 2)\n    .Select(g => g.Sum())\n    .Single();",
        "prompt": "`Single()` method faqat bitta element bo'lgan collection uchun ishlatiladi. Bu yerda nechta group bor?",
        "answer": "var numbers = new[] { 1, 2, 3 };\nvar result = numbers\n    .GroupBy(x => x % 2)    // 2 ta group: {0: [2], 1: [1,3]}\n    .Select(g => g.Sum())   // [2, 4]\n    .ToArray();             // Single() o'rniga ToArray() yoki First()/Last()\n// Single() exception beradi chunki 2 ta element bor",
        "explanation": "GroupBy(x % 2) 2 ta group yaratadi (even va odd). Single() faqat 1 ta element kutadi, 2 ta bo'lgani uchun exception beradi."
    },
    {
        "id": 125,
        "type": "error_spotting",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "null safety"
        },
        "codeWithError": "var words = new[] { \"apple\", \"banana\", null, \"cherry\" };\nvar result = words\n    .Where(w => w.Length > 5)\n    .Count();",
        "prompt": "Null reference exception: array da `null` element bor va `Length` property access qilinmoqda.",
        "answer": "var words = new[] { \"apple\", \"banana\", null, \"cherry\" };\nvar result = words\n    .Where(w => w != null && w.Length > 5)  // Null check kerak\n    .Count();\n// Yoki: .Where(w => w?.Length > 5)",
        "explanation": "Null element da Length property access NullReferenceException beradi. Null check yoki safe navigation operator kerak."
    },
    {
        "id": 126,
        "type": "output_prediction",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "selectmany operations"
        },
        "snippet": "var numbers = new[] { 1, 2, 3, 4, 5 };\nvar result = numbers\n    .SelectMany(x => Enumerable.Repeat(x, x))\n    .Sum();\nConsole.WriteLine(result);",
        "prompt": "`SelectMany` har raqamni o'sha raqam marta takrorlaydi. Masalan, 3 ni 3 marta: [3,3,3]. Yig'indi?",
        "answer": "30",
        "explanation": "1→[1], 2→[2,2], 3→[3,3,3], 4→[4,4,4,4], 5→[5,5,5,5,5] flatten→[1,2,2,3,3,3,4,4,4,4,5,5,5,5,5] Sum=30"
    },
    {
        "id": 127,
        "type": "output_prediction",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "character analysis"
        },
        "snippet": "var data = \"hello world\";\nvar result = data\n    .Where(c => char.IsLetter(c))\n    .GroupBy(c => c)\n    .OrderByDescending(g => g.Count())\n    .First()\n    .Key;\nConsole.WriteLine(result);",
        "prompt": "String dagi eng ko'p uchraydigan harfni topish. `hello world` da qaysi harf eng ko'p?",
        "answer": "l",
        "explanation": "\"hello world\" letters: h,e,l,l,o,w,o,r,l,d → 'l' appears 3 times (most frequent) → Key='l'"
    },
    {
        "id": 128,
        "type": "output_prediction",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "zip operations"
        },
        "snippet": "var list1 = new[] { 1, 2, 3 };\nvar list2 = new[] { 2, 3, 4 };\nvar result = list1.Zip(list2, (a, b) => a + b).ToArray();\nConsole.WriteLine(string.Join(\", \", result));",
        "prompt": "`Zip` method ikki collection elementlarini juftlab birlashtiradi. Har juftikning yig'indisi?",
        "answer": "3, 5, 7",
        "explanation": "Zip pairs: (1,2)→3, (2,3)→5, (3,4)→7 → string.Join(\", \") → \"3, 5, 7\""
    },
    {
        "id": 129,
        "type": "output_prediction",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "conditional operations"
        },
        "snippet": "var numbers = new[] { 5, 2, 8, 1, 9 };\nvar result = numbers\n    .TakeWhile(x => x != 8)\n    .Concat(numbers.SkipWhile(x => x != 8).Skip(1))\n    .ToArray();\nConsole.WriteLine(string.Join(\", \", result));",
        "prompt": "8 raqamini olib tashlash: 8 gacha olib, 8 dan keyingilarni olib, birlashtirish. Natija?",
        "answer": "5, 2, 1, 9",
        "explanation": "TakeWhile(≠8): [5,2] + SkipWhile(≠8).Skip(1): skip [5,2,8], then skip 1 more → [1,9] = [5,2,1,9]"
    },
    {
        "id": 130,
        "type": "output_prediction",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "nested flattening"
        },
        "snippet": "var ranges = new[] { \n    Enumerable.Range(1, 3), \n    Enumerable.Range(4, 2) \n};\nvar flattened = ranges.SelectMany(r => r).Sum();\nConsole.WriteLine(flattened);",
        "prompt": "`SelectMany` nested IEnumerable larni flatten qiladi. Range(1,3)=[1,2,3], Range(4,2)=[4,5]. Yig'indi?",
        "answer": "15",
        "explanation": "Range(1,3)→[1,2,3], Range(4,2)→[4,5] → SelectMany flatten→[1,2,3,4,5] → Sum=15"
    },
    {
        "id": 131,
        "type": "code_writing",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "data analysis projects"
        },
        "prompt": "### LINQ ma'lumotlar tahlili dasturi\n\nStudent ma'lumotlari bilan ishlaydigan konsol dasturini yozing.\n\n`Student` record yarating: `Name`, `Age`, `Grade`, `Subject` maydonlari bilan.\n\nQuyidagi LINQ operatsiyalarini implement qiling:\n- Barcha studentlarni grade bo'yicha guruhlab, har guruhda nechta student borligini chiqarish\n- Eng yosh va eng katta yoshdagi studentlarni topib chiqarish\n- Ma'lum subject bo'yicha o'rtacha grade ni hisoblash\n- Grade 80+ bo'lgan studentlarni name bo'yicha tartiblash\n\nDeferred execution va immediate execution farqini ko'rsating.",
        "examples": [
            "Students by grade groups:\nA: 3 students\nB: 5 students\n\nAge range: Min=18, Max=25\nMath average grade: 87.5"
        ]
    },
    {
        "id": 132,
        "type": "code_writing",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "text analysis projects"
        },
        "prompt": "### LINQ bilan matn tahlili\n\nMatn faylini tahlil qiladigan dastur yozing (yoki hardcoded string ishlating).\n\nQuyidagi funksiyalarni LINQ bilan implement qiling:\n- Eng uzun so'zni topish\n- Har harfning necha marta uchrashini hisoblash\n- Palindrom so'zlarni topish  \n- So'zlarni uzunlik bo'yicha guruhlab, har guruhdan eng kichik alfabetik tartibdagisini olish\n\nQuery syntax va method syntax ikkalasidan ham foydalaning.\n\n`SelectMany`, `GroupBy`, `OrderBy`, `Where` metodlarini ishlating.",
        "examples": [
            "Text: \"hello world level deed\"\nLongest word: world (5 letters)\nPalindromes: level, deed\nLetter 'l' appears 3 times"
        ]
    },
    {
        "id": 133,
        "type": "code_writing",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "business logic projects"
        },
        "prompt": "### LINQ bilan e-commerce ma'lumotlari\n\n`Product`, `Order`, `Customer` recordlarini yarating.\n\nQuyidagi business logikani LINQ bilan yozing:\n- Eng ko'p sotilgan 5 ta mahsulot\n- Har bir customer ning jami xarid summasi\n- Oylik sotuvlar statistikasi (group by month)\n- Hech narsa sotib olmagan customerlar ro'yxati\n\n`Join`, `GroupJoin`, `Aggregate`, `Sum` metodlaridan foydalaning.\n\nNull safety va edge caselarni handle qiling (bo'sh collections, null values).",
        "examples": [
            "Top products:\n1. Laptop - 15 orders\n2. Phone - 12 orders\n\nCustomer spending:\nAli: $1,250\nSara: $890"
        ]
    },
    {
        "id": 134,
        "type": "code_writing",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "performance optimization"
        },
        "prompt": "### LINQ Performance Comparison\n\nKatta collection lar bilan ishlash uchun performance test dasturini yozing.\n\nQuyidagilarni taqqoslang:\n- `Where().Count()` vs `Count(predicate)`\n- `Where().First()` vs `First(predicate)`  \n- `ToList().Where()` vs `Where().ToList()`\n- Deferred vs Immediate execution\n\n`Stopwatch` ishlatib, execution time ni o'lchang.\n\n1 million elementli `List<int>` yarating va turli LINQ operatsiyalarini test qiling.\n\nNatijalarni console ga formatted holda chiqaring.",
        "examples": [
            "Performance Test Results:\nWhere().Count(): 145ms\nCount(predicate): 98ms\n\nDeferred query creation: 0ms\nImmediate execution: 234ms"
        ]
    },
    {
        "id": 135,
        "type": "code_writing",
        "metadata": {
            "category": "linq-funksional-dasturlash",
            "subcategory": "extension methods"
        },
        "prompt": "### Custom LINQ Extension Methods\n\nO'zingizning LINQ extension methodlarini yarating:\n\n- `Batch<T>(this IEnumerable<T> source, int size)` - elementlarni chunk larga bo'lish\n- `DistinctBy<T, TKey>(this IEnumerable<T> source, Func<T, TKey> keySelector)` - key bo'yicha unique\n- `ForEach<T>(this IEnumerable<T> source, Action<T> action)` - har elementga action apply qilish\n- `IsEmpty<T>(this IEnumerable<T> source)` - collection bo'sh ekanligini tekshirish\n\nHar bir extension method uchun:\n- Null checking\n- Deferred execution (kerak bo'lsa)\n- `yield return` ishlatish\n- Generic constraints (kerak bo'lsa)\n\nTest kodini ham yozing.",
        "examples": [
            "var numbers = Enumerable.Range(1, 10);\nvar batches = numbers.Batch(3).ToList();\n// Result: [[1,2,3], [4,5,6], [7,8,9], [10]]\n\nvar people = GetPeople();\nvar unique = people.DistinctBy(p => p.Email);"
        ]
    },
    {
        "id": 136,
        "type": "mcq",
        "metadata": {
            "category": "exception-handling",
            "subcategory": "try-catch basics"
        },
        "codeBefore": "```csharp\ntry\n{\n    int result = int.Parse(\"abc\");\n    Console.WriteLine(result);\n}\ncatch (FormatException ex)\n{\n    Console.WriteLine(\"Format error\");\n}\ncatch (Exception ex)\n{\n    Console.WriteLine(\"General error\");\n}\n```",
        "codeAfter": "",
        "prompt": "Yuqoridagi kodda qaysi catch block ishlaydi?",
        "options": [
            {
                "id": "A",
                "option": "FormatException catch block"
            },
            {
                "id": "B",
                "option": "Exception catch block"
            },
            {
                "id": "C",
                "option": "Ikkala catch block ham"
            },
            {
                "id": "D",
                "option": "Hech qaysi catch block"
            }
        ],
        "answer": [
            "A"
        ],
        "explanation": "int.Parse(\"abc\") FormatException tashlay, va FormatException uchun aniq catch block mavjud bo'lgani uchun u ishlatiladi."
    },
    {
        "id": 137,
        "type": "true_false",
        "metadata": {
            "category": "exception-handling",
            "subcategory": "exception best practices"
        },
        "codeBefore": "",
        "codeAfter": "",
        "prompt": "Exception handling performance overhead yaratadi va ularni oddiy control flow uchun ishlatmaslik kerak.",
        "answer": "true",
        "explanation": "Exception lar expensive operatsiya hisoblanadi va faqat haqiqiy error holatlar uchun ishlatilishi kerak, oddiy control flow uchun emas."
    },
    {
        "id": 138,
        "type": "fill",
        "metadata": {
            "category": "exception-handling",
            "subcategory": "try-catch syntax"
        },
        "codeWithBlank": "try\n{\n    int.Parse(\"invalid\");\n}\n______ (FormatException ex)\n{\n    Console.WriteLine(\"Format error: \" + ex.Message);\n}\n______ (Exception ex)\n{\n    Console.WriteLine(\"General error: \" + ex.Message);\n}",
        "prompt": "Try-catch strukturasini to'ldiring. Exception larni catch qilish uchun kerakli kalit so'zni yozing.",
        "answer": "try\n{\n    int.Parse(\"invalid\");\n}\ncatch (FormatException ex)\n{\n    Console.WriteLine(\"Format error: \" + ex.Message);\n}\ncatch (Exception ex)\n{\n    Console.WriteLine(\"General error: \" + ex.Message);\n}",
        "explanation": "Catch kalit so'zi exception larni ushlash uchun ishlatiladi. Har bir catch block ma'lum exception turini handle qiladi."
    },
    {
        "id": 139,
        "type": "error_spotting",
        "metadata": {
            "category": "exception-handling",
            "subcategory": "catch block order"
        },
        "codeWithError": "try\n{\n    int.Parse(\"abc\");\n}\ncatch (Exception ex)  // General exception first\n{\n    Console.WriteLine(\"General error\");\n}\ncatch (FormatException ex)  // Specific exception after - ERROR!\n{\n    Console.WriteLine(\"Format error\");\n}",
        "prompt": "Catch block tartibida xato bor. Compiler error beradi. Tuzating.",
        "answer": "try\n{\n    int.Parse(\"abc\");\n}\ncatch (FormatException ex)  // Specific exception first\n{\n    Console.WriteLine(\"Format error\");\n}\ncatch (Exception ex)  // General exception after\n{\n    Console.WriteLine(\"General error\");\n}",
        "explanation": "Aniq exception turlar umumiy turlardan oldin kelishi kerak. Exception eng umumiy tur bo'lgani uchun oxirida bo'lishi kerak."
    },
    {
        "id": 140,
        "type": "output_prediction",
        "metadata": {
            "category": "exception-handling",
            "subcategory": "exception flow"
        },
        "snippet": "try\n{\n    throw new ArgumentNullException(\"param\");\n}\ncatch (ArgumentException ex)\n{\n    Console.Write(\"Argument\");\n}\ncatch (ArgumentNullException ex)\n{\n    Console.Write(\"Null\");\n}\ncatch (Exception ex)\n{\n    Console.Write(\"General\");\n}\nConsole.Write(\"End\");",
        "prompt": "ArgumentNullException inheritance hierarchy: Exception > SystemException > ArgumentException > ArgumentNullException. Qaysi natija?",
        "answer": "ArgumentEnd",
        "explanation": "ArgumentNullException ArgumentException dan inherit qilgani uchun birinchi ArgumentException catch ishlaydi (first-match rule). Keyin \"End\" chiqadi."
    },
    {
        "id": 141,
        "type": "mcq",
        "metadata": {
            "category": "exception-handling",
            "subcategory": "Custom Exceptions"
        },
        "prompt": "C# da custom exception class yaratganda nima sodir bo'ladi?",
        "options": [
            {
                "id": "a",
                "option": "U System.Exception yoki uning subclasslaridan meros olishi kerak"
            },
            {
                "id": "b",
                "option": "U avtomatik ravishda stack trace ma'lumotlarini o'z ichiga oladi"
            },
            {
                "id": "c",
                "option": "U generic Exception handlerlar tomonidan ushlana oladi"
            },
            {
                "id": "d",
                "option": "Barchasi to'g'ri"
            }
        ],
        "answer": [
            "d"
        ],
        "explanation": "Custom exceptionlar Exception yoki uning subclasslaridan meros olishi kerak, avtomatik ravishda stack trace ma'lumotlarini o'z ichiga oladi va meros tufayli generic Exception handlerlar tomonidan ushlana oladi."
    },
    {
        "id": 142,
        "type": "true_false",
        "metadata": {
            "category": "exception-handling",
            "subcategory": "Finally Blocks"
        },
        "prompt": "Finally blok doimo bajariladi, hatto try blokda return statement bo'lsa ham.",
        "answer": "true",
        "explanation": "Finally blok try blok qanday chiqishidan qat'i nazar bajariladi - oddiy, return orqali yoki exception orqali. U tozalash maqsadlari uchun bajarilishi kafolatlanadi."
    },
    {
        "id": 143,
        "type": "fill",
        "metadata": {
            "category": "exception-handling",
            "subcategory": "Exception Filtering"
        },
        "codeWithBlank": "try\n{\n    // xavfli operatsiya\n}\ncatch (ArgumentException ex) _____ (ex.ParamName == \"userId\")\n{\n    // maxsus parametr exceptionni boshqarish\n}",
        "prompt": "Exception filtering uchun kerakli kalit so'zni kiriting:",
        "answer": "when",
        "explanation": "C# da exception filtering uchun 'when' kalit so'zi ishlatiladi. U catch blok bajarilishi uchun qo'shimcha shartlarni belgilash imkonini beradi."
    },
    {
        "id": 144,
        "type": "error_spotting",
        "metadata": {
            "category": "exception-handling",
            "subcategory": "Exception Re-throwing"
        },
        "codeWithError": "try\n{\n    SomeRiskyOperation();\n}\ncatch (Exception ex)\n{\n    LogError(ex);\n    throw ex;\n}",
        "prompt": "Ushbu exception *re-throw* kodida xatoni toping:",
        "answer": "Stack trace ni saqlab qolish uchun 'throw ex;' o'rniga 'throw;' ishlatish kerak",
        "explanation": "'throw ex;' ishlatish stack trace ni qayta o'rnatadi, asl call stack ma'lumotlarini yo'qotadi. Asl stack trace ni saqlab qolish uchun 'throw;' ishlatish kerak."
    },
    {
        "id": 145,
        "type": "output_prediction",
        "metadata": {
            "category": "exception-handling",
            "subcategory": "Exception Propagation"
        },
        "snippet": "try\n{\n    try\n    {\n        throw new ArgumentException(\"Inner\");\n    }\n    finally\n    {\n        Console.WriteLine(\"Inner finally\");\n    }\n}\ncatch (Exception ex)\n{\n    Console.WriteLine($\"Caught: {ex.Message}\");\n}\nfinally\n{\n    Console.WriteLine(\"Outer finally\");\n}",
        "prompt": "Ushbu kodning natijasi nima bo'ladi?",
        "answer": "Inner finally\nCaught: Inner\nOuter finally",
        "explanation": "Exception tashlanganida ichki finally blok birinchi bajariladi, keyin tashqi catch blok exception ni boshqaradi va nihoyat tashqi finally blok bajariladi."
    },
    {
        "id": 146,
        "type": "mcq",
        "metadata": {
            "category": "exception-handling",
            "subcategory": "Exception Hierarchy"
        },
        "prompt": "Quyidagi catch bloklardan qaysi biri to'g'ri tartibda joylashgan?",
        "options": [
            {
                "id": "a",
                "option": "catch (Exception) → catch (ArgumentException) → catch (ArgumentNullException)"
            },
            {
                "id": "b",
                "option": "catch (ArgumentNullException) → catch (ArgumentException) → catch (Exception)"
            },
            {
                "id": "c",
                "option": "catch (ArgumentException) → catch (Exception) → catch (ArgumentNullException)"
            },
            {
                "id": "d",
                "option": "Tartib muhim emas"
            }
        ],
        "answer": [
            "b"
        ],
        "explanation": "Catch bloklar eng maxsus (specific) dan eng umumiy (general) ga qarab tartiblanishi kerak. ArgumentNullException → ArgumentException → Exception to'g'ri tartibdir, chunki har biri keyingisining subclass'i."
    },
    {
        "id": 147,
        "type": "true_false",
        "metadata": {
            "category": "exception-handling",
            "subcategory": "Performance"
        },
        "prompt": "Exception'lar performance jihatdan qimmat operatsiyalar bo'lib, ular odatiy flow control uchun ishlatilmasligi kerak.",
        "answer": "true",
        "explanation": "Exception'lar stack trace yaratish va call stack'ni unwinding qilish tufayli performance jihatdan qimmat. Ular faqat haqiqiy xato holatlar uchun ishlatilishi kerak, oddiy flow control uchun emas."
    },
    {
        "id": 148,
        "type": "fill",
        "metadata": {
            "category": "exception-handling",
            "subcategory": "Custom Exception Constructors"
        },
        "codeWithBlank": "public class CustomException : Exception\n{\n    public CustomException(string message, Exception innerException)\n        : _____(message, innerException)\n    {\n    }\n}",
        "prompt": "Custom exception constructor'ida base class constructor'ini to'g'ri chaqiring:",
        "answer": "base",
        "explanation": "Custom exception'larda base class (Exception) constructor'ini chaqirish uchun 'base' kalit so'zi ishlatiladi. Bu message va inner exception'ni base class'ga o'tkazadi."
    },
    {
        "id": 149,
        "type": "error_spotting",
        "metadata": {
            "category": "exception-handling",
            "subcategory": "Exception Filtering Errors"
        },
        "codeWithError": "try\n{\n    ProcessData();\n}\ncatch (Exception ex) when (LogException(ex))\n{\n    // handle exception\n}\n\nbool LogException(Exception ex)\n{\n    Console.WriteLine($\"Error: {ex.Message}\");\n    return true;\n}",
        "prompt": "Ushbu exception filtering kodida qanday muammo bor?",
        "answer": "When clause'da side effect'li funksiyalar ishlatilmasligi kerak, LogException har doim chaqiriladi",
        "explanation": "When clause'da side effect'li operatsiyalar (logging, file yozish) ishlatilmasligi kerak. Bu holda LogException har doim chaqiriladi va exception handle qilinadi, bu kutilmagan behavior'ga olib keladi."
    },
    {
        "id": 150,
        "type": "output_prediction",
        "metadata": {
            "category": "exception-handling",
            "subcategory": "Using Statement Exception Handling"
        },
        "snippet": "public class TestResource : IDisposable\n{\n    public string Name { get; set; }\n    public void Dispose()\n    {\n        Console.WriteLine($\"Disposing {Name}\");\n    }\n}\n\ntry\n{\n    using (var resource = new TestResource { Name = \"Resource1\" })\n    {\n        Console.WriteLine(\"Using resource\");\n        throw new InvalidOperationException(\"Test error\");\n    }\n}\ncatch (Exception ex)\n{\n    Console.WriteLine($\"Caught: {ex.Message}\");\n}",
        "prompt": "Ushbu kodning natijasi nima bo'ladi?",
        "answer": "Using resource\nDisposing Resource1\nCaught: Test error",
        "explanation": "Using statement exception tashlanganida ham resurs dispose qilinishini kafolatlaydi. Avval 'Using resource' chop etiladi, keyin exception tashlanadi, using blok chiqishida 'Disposing Resource1' chop etiladi, va nihoyat catch blok exception'ni ushlaydi."
    }
]